<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 版本控制工具之Ｒａｂｂｉｔｖｃｓ]]></title>
    <url>%2F2017%2F11%2F04%2FLinux-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E4%B9%8BRabbitvcs%2F</url>
    <content type="text"><![CDATA[新公司的文档管理居然使用ｓｖｎ，不知道适合原因．很久不用有一些忘却了.之前在ｗｉｎ下用的是TortoiseSVN，在ｕｂｕｎｔｕ下，与之及其相似的是ｒａｂｂｉｔｖｃｓ．官网地址下面是来自官方打介绍 特性介绍NautilusSeamlessly integrates into Nautilus workflow GeditProvides menus for accessing version control tools ThunarSeamlessly integrates into Thunar workflow Command Line InterfaceAn easy to use tool to launch our dialogs SubversionSupports most Subversion functionality GitSupports most Git functionality Fully InternationalizedPartial-to-full support for 26 languages! Ubuntu安装方法1234567891011### 添加源$ sudo add-apt-repository ppa:rabbitvcs/ppa### 导入key$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 34EF4A35### 更新源$ sudo apt-get update### 安装依赖$ sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld### 安装ＲabbitVCS$ sudo apt-get install rabbitvcs-cli rabbitvcs-core rabbitvcs-gedit rabbitvcs-nautilus3### 如安装失败使用 rabbitvcs-nautilus3 替换为 rabbitvcs-nautilus 使用方法]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（一）：无线技术分类]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[物联网的关键技术包括三个方面：物体的识别、物体的连接以及对数据的操作。随着联网物体的数量越来越多，无线技术在物联网中发挥的作用也越来越大。 物联网无线技术分类 常见的物联网无线技术可以按照覆盖范围分为两大类： 一类是长距离（几百米到几公里）覆盖的无线广域网（WWAN）技术。代表技术有：NBIOT、eMTC、GPRS、802.11ah、LoRa、SigFox、Weightless等。 另一类是短距离（100米以内）覆盖的无线局域网（WLAN）或者无线个域网（WPAN）技术。代表技术有：WiFi、Bluetooth、Zigbee、RFID、NFC、Z-Wave等。 短距无线技术的应用场景由于智能手机的普及，平时生活中接触比较多的无线技术就是WiFi、Bluetooth（蓝牙）及NFC，这些都是智能手机普遍提供的无线连接能力。 与NFC类似的RFID的主要功能不是用来连接和通信，而是用于物体的识别（Object Identification）, NFC目前主要用于移动支付，比如银联IC卡闪付、Apple Pay等。 NFC广泛用于支付场景 WiFi、蓝牙、Zigbee以及Z-Wave等短距离无线技术，常用于智能家居这样的应用场景。目前国内智能家居市场WiFi、蓝牙以及Zigbee技术应用得比较多。Z-Wave与Zigbee类似，是由丹麦Zensys公司主导的技术标准，在国内比较少用。 对于WiFi连接的物联网设备，一般都支持TCP/IP协议，带有IP地址，这样可以直接通过IP协议接入互联网的服务器上。用户也可以用手机APP，通过物联网服务器来远程查看或控制物联网设备。 对于蓝牙或者Zigbee连接的物联网设备，没有IP地址，一般需要借助一个网关设备，才能接入网络。智能家居网关都带有网络连接，通过WiFi或有线接入到路由器，另外网关一般都集成了多种通信协议，还起到协议转换的作用。 大范围覆盖：LPWA技术对于室外需要大范围覆盖的场景，以上这些无线技术就不适合应用了。因为物联网节点分布非常广而且非常分散，如果要让每个节点都接入附近的路由器，就需要布设大量的路由节点，这样成本高，而且部署复杂。所以对于这种应用场景，非常适合远距离无线技术。 与我们平时手机上网用的3G、4G不同，物联网所需要的远距离无线技术，对传输速率的要求不高，同时要求具有极低的功耗，属于低速率低功耗的无线通信技术。对于这类技术，目前一般统称为LPWA（Low Power Wide Area），NB-IoT和LoRa都是其中的代表。 关于NB-IoT以及LoRa的技术详解，请继续关注我们的头条频道：“微说互联网”及“纵论物联网无线技术”。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（六）：基于Linux的物联网操作系统]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8ELinux%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[提到物联网操作系统，就不能不提Linux，因为Linux可能是目前在物联网设备中应用最广的操作系统了。前面的文章刚刚介绍了不少非Linux类的物联网操作系统，本文就来介绍一下目前常用的基于Linux的物联网操作系统。在传统Linux内核基础上，经过裁剪，就可以移植到嵌入式系统上运行。不过，还有很多开源组织和商业公司对Linux进行了一番改造，使其更符合嵌入式系统或物联网应用的需求，比如改为实时操作系统。 RTLinuxRTLinux（Real-Time Linux）是Linux中的一种实时操作系统。它由新墨西哥矿业及科技学院的V. Yodaiken开发。现在已被WindRiver公司（大名鼎鼎的嵌入式操作系统VxWorks就是这家公司的产品）收购。RT-Linux开发者并没有针对实时操作系统的特性而重写Linux的内核，因为这样做的工作量非常大，而且要保证兼容性也非常困难。RTLinux是将Linux的内核代码做了一些修改，将Linux本身的任务以及Linux内核作为优先级很低的任务，而实时任务作为优先级最高的任务。 uClinuxuClinux（www.uclinux.org）表示micro-control linux，即“微控制器领域中的Linux系统”，是Lineo公司的主打产品，同时也是开放源码的嵌入式Linux的典范之作。uCLinux主要是针对目标处理器没有存储管理单元MMU（Memory Management Unit）的嵌入式系统而设计的。它已经被成功地移植到了很多平台上。由于没有MMU，在uCLinux上实现多任务需要一定的技巧。 Brillo谷歌提出了Project IoT物联网计划，并发布了Brillo操作系统。Brillo是一个物联网底层操作系统。Brillo是源于Android，是对Android底层的一个细化，得到了Android的全部支持，比如蓝牙、Wifi等技术，并且能耗很低，安全性很高，任何设备制造商都可以直接使用。LiteOS2015年5月在华为网络大会上，华为发布了敏捷网络3.0，主要包括最轻量级的物联网操作系统LiteOS、敏捷物联网关、敏捷控制器三部分。其中LiteOS声称可以作为只有10KB大小的内核来部署。在华为的官方网站（www.huawei.com/minisite/liteos/cn/）上，可以了解到更多关于LiteOS的信息。 OpenWrt很多智能路由器都基于OpenWrt的衍生版本开发而成轻量级OpenWrt（www.openwrt.org.cn）是一个基于Linux的操作系统，市场上很多智能路由器固件都是基于OpenWrt及其衍生版本的。OpenWrt包括很多衍生版本，这些衍生版本还有很多分支版本。LEDE（lede-project.org）。LEDE全称是Linux嵌入式开发环境(Linux Embedded Development Environment)项目，LEDE就是一个基于OpenWrt的OS。其他衍生版本还有DD-Wrt，以及面向Arduino的Linino，等等。 Ostro Linux Ostro? OS is a Linux* distribution optimized for the development of connected and embedded devices. In fact, Ostro Project is designed specifically to support IoT device development. It integrates connectivity and networking, device-to-device interconnectivity standards, pre-configured sensors, and over-the-air update capabilities. Ostro（ostroproject.org）是一套基于Linux并且为物联网智能设备特别量身订做的开源操作系统，支持蓝牙、WiFi和NFC等等的连接方式，并且支持多种如IoTivity的设备对设备互联互通标准。提到Ostro，不得不再说一下Linux基金会的Yocto Project。Yocto不是一款Linux发行版，而是一个开源协作项目，为开发人员提供构建自定义嵌入式堆栈的模块、工具和方法。Yocto Project构成了大多数商用嵌入式Linux发行版的基础，比如Ostro Linux、Qt for Device Creation都是基于这个项目。 其他Linux物联网项目（1）RaspbianRaspbian成为树莓派爱好者的最佳选择Raspbian是一个专门面向树莓派（Raspberry Pi）计算机的Linux发行版，基础是Debian操作系统。两位志愿者针对树莓派硬件对Debian进行了专门的优化和移植。而Raspbian不仅仅是一个OS，它附带着35000个软件包以及预编译的软件。 （2）Snappy Ubuntu CoreUbuntu希望继续让Linux成为让物联网更智能和可扩展的核心。Snappy Ubuntu Core是面向智能设备的最新平台，其承诺可以运行存储在本地或依赖于云端的相同软件。 （3）TizenLinux基金会托管的这个嵌入式Linux项目主要得到了三星的支持。Tizen广泛用于三星的电视和智能手表中，包括新的Gear S3，也零星地实施在三星的相机和消费级设备中。 结语在Linux系统基础上发展起来的面向物联网应用的项目非常多，Linux的碎片化程度也挺严重。至于哪个版本的Linux会成为主流，取决于应用场景、文档及开发资源支持和整个开发者生态的建立。在移动互联网时代，基于Linux的Android系统和互联网应用大放异彩；在物联网时代，Linux仍然会发挥着巨大作用。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（二）：LPWAN技术 - 物联网]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALPWAN%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[不同的物联网技术适用于不同的应用场景。对于需要远距离大范围覆盖的场景来说，我们熟悉的蓝牙、WiFi、Zigbee这些技术都不适合，我们需要低功耗广域网（LPWAN：Low Power Wide Area Network）技术。LPWAN技术的特点是： 覆盖远，支持大范围组网；连接终端节点多，可以同时连接成千上万的节点；功耗低，只有功耗低，才能保证续航能力，减少更换电池的麻烦；传输速率低，因为主要是传输一些传感数据和控制指令，不需要传输音视频等多媒体数据，所以也就不需要太高的速率，而且低功率也限制了传输速率。当然还有就是成本要低，这样才有应用推广的可能性。本文主要介绍一些目前比较有代表性的LPWAN技术，特别是使用免授权频段的无线技术。无线物联原本是GPRS的天下当移动蜂窝网络发展处于2G、3G和4G时代，对于需要广域覆盖的物联网应用来说，比如物流行业的车辆定位与跟踪，或者无人值守系统的故障监控，一般都采用传统的GPRS技术。但GPRS数据传输单元（DTU: Data Transfer unit）的功耗和续航能力都不够理想，而且受限于GPRS网络的覆盖，对于没有GPRS信号就没法使用GPRS来传输数据了。 GPRS的物联网应用架构图 为了应对日益强烈的物联网需求，国际电联ITU-T也在LTE以及后续的5G移动通信标准中推进适合物联网应用的广域网标准，如eMTC、NB-IoT等，目前这些新的M2M技术标准尚未达到可大规模商用的成熟度。在移动蜂窝网络面向物联网的新标准推出前，也有很多公司和组织开发了比GPRS更低功耗且容易部署的替代方案，一些方案目前正在被广泛应用中，比如LoRa，SigFox等。SigFox2009年，法国公司SigFox展示了自己的超窄带（UNB: Ultra Narrow Band）技术，被业界视为是LPWAN领域最早的开拓者。UNB技术每秒只能处理10到1000比特的数据，传输功耗水平非常低，却能支持成千上万的连接。SigFox无线链路使用免授权的ISM射频频段。频率根据国家法规有所不同，在欧洲广泛使用868MHz，在美国是915MHz。SIGFOX网络中单元的密度，在农村地区大约30-50km，在城市中常有更多的障碍物和噪声距离可能减少到3-10km之间。SigFox的UNB技术使用标准的二进制相移键控（BPSK: Binary Phase Shift Keying）的无线传输方法，采用非常窄的频谱改变无线载波相位对数据进行编码。 SigFox公司不仅是标准的制定者，同时也是网络运营者和云平台提供商，目标是与合作伙伴建造一个覆盖全球的IoT网络，独立于现有电信运营商的移动蜂窝网络。目前SigFox在欧洲已经部署了不少网络，在中国还没有部署。LoRaLoRa是美国Semtech公司推广的一种超远距离无线传输方案。2013年8月，Semtech公司发布了一种基于1GHz以下的超长距低功耗数据传输技术的芯片, LoRa是长距离（Long Range）的缩写。 其接受灵敏度达到了惊人的-148dbm，与业界其他先进水平的sub-GHz芯片相比，最高的接收灵敏度改善了20db以上，这确保了网络连接可靠性。LoRa使用线性调频扩频调制技术，工作在非授权频段，数据传输速率在0.3kbps~37.5kbps。LoRa还采用了自适应速率(ADR: Adaptive Data Rate)方案来控制速率和终端设备的发射功率，从而最大化终端设备的续航能力。LoRa与Sigfox最大的不同之处在于LoRa是技术提供商，不是网络运营商。谁都可以购买和运行LoRa设备，LoRa联盟也鼓励电信运营商部署LoRa网络。目前国内已经有一些LoRa的方案商。WeightlessWeightless是由一个非盈利全球标准组织Weightless SIG（Weightless Special Interest Group）提出的技术。与LoRa、SigFox类似，Weightless也是一种专为物联网设计的无线技术。Weightless既可以工作在Sub-GHz免授权频段，也可以工作在授权频段。通信距离可以达到10公里。Weightless有三个不同的开放标准：Weightless-N、Weightless-P和Weightless-W。如果考虑成本，可选择单向通信的Weightless-N。如果考虑高性能，可选择双向通信Weightless-P。如果当地TV空白频段可用，可选择Weightless-W。RPMARPMA技术的全称是随机相位多址接入（Random Phase Multiple Access）。由美国Ingenu公司开发，Ingenu在2008年成立，公司在2015年9月前的名称是ONRAMP。RPMA技术工作在2.4GHz免授权频段，支持全双工通信，这点是比SigFox和LoRa强的地方。SigFox采用的是单向传输，LoRa采用的是半双工的通讯方式。Ingenu为开发人员提供了收发器模组，这些模组可以连接到RPMA网络，这个网络是由Ingenu公司及其合作伙伴在全球范围内建立的网络，这与SigFox比较类似。RPMA网络将来自终端节点的信息转发至使用者的IT系统。RPMA也可适用于想要搭建私有网络的客户人群。结语随着各大电信运营商在原来LTE网络基础上大范围部署NB-IoT以及eMTC网络，未来物联网的无线技术竞争将更加激烈。 在各种技术在基本技术指标上没有明显差异的情况下，成本、整体解决方案、开发者生态以及整个产业链将会决定最终技术的命运。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（五）：除了Linux，还有什么物联网操作系统]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E9%99%A4%E4%BA%86Linux%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[在前面介绍物联网终端设备的文章中，我们已经简单地介绍了物联网操作系统。物联网操作系统的种类非常多，不过其中有很大一部分是基于Linux系统改造的，还有一些系统是商业公司或开源组织开发的，当然微软公司也开发了一系列面向嵌入式应用的操作系统。 出于成本或者定制化的需求，开发者往往更青睐开源的物联网操作系统。开源系统可以大致分为两大类：一类是基于Linux系统改造的物联网OS，如uCLinux、谷歌的Brillo、华为的Lite OS等；一类是非Linux类物联网OS，由开源社区或商业公司按照某种开源许可独立设计实现，如uCOS、FreeRTOS、mbed等。篇幅有限，本文重点介绍一下非Linux类的物联网OS，这类系统通常是比较轻量级的实时操作系统，更适合应用于存储性能有限的MCU。 FreeRTOSFreeRTOS（www.freertos.org）是一个迷你的实时操作系统内核，但麻雀虽小，五脏俱全，包括了任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等操作系统的基本功能。FreeRTOS创始人是Richard Barry，最初他设计这个系统的初衷，就是出于自身为工作项目中寻找RTOS的过程很痛苦。商业系统很贵，开源系统也缺乏好的文档支持。相对μC/OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，源码公开、可移植、可裁减，可移植到各种单片机上运行，在嵌入式系统尤其是实时操作系统方面应用者众多，比如著名的智能手表Pebble就是用了FreeRTOS。 μC/OS-IIμC/OS-II 是一种基于优先级的抢占式多任务实时操作系统，包含了实时内核、任务管理、时间管理、任务间通信同步（信号量，邮箱，消息 队列）和内存管理等功能。μC/OS-II绝大部分的代码是用ANSII的C语言编写的，包含一小部分汇编代码，使之可供不同架构的微处理器使用。μC/OS-II经过了非常严格的测试，甚至都已经运用到美国航空管理局的飞行器上。μC/OS-II由Micrium公司以源代码的形式发布，但并不意味着它是免费软件。可以将其用于教学和私下研究（peaceful research）；但是如果将其用于商业用途，那么必须通过Micrium获得商用许可。 mbedmbed SDK 体系及目录结构mBed（mbed.org）是ARM公司官方提供的一套用于快速开发ARM架构单片机应用原型的工具集，包括免费的软件库（SDK），硬件设计参考（HDK）和基于Web的在线编译环境（mBed Compiler）三部分。由于mBed的代码和大部分硬件设计都是以开源（permissive Apache 2.0 licence）的方式提供的，再加上它面向的ARM系列单片机具有较高的性价比和广泛的应用基础，所以mBed在世界范围内已经吸引了大量的电子产品开发者，其产业生态链已经初级规模。 MiCOMICO系统架构2014年7月，MiCO号称是中国首款物联网操作系统，由上海庆科（MXCHIP）发布。根据官方解释，MiCO的意思是Micro-controller based Internet Connectivity Operating system，是基于微控制器（MCU）的互联网接入操作系统，这个解释其实和物联网操作系统的意思一回事。MiCO本身包括：接口，框架，核心功能和非核心功能四部分。开发者可以在各种微控制器平台上，基于MiCO来设计接入互联网的创新智能产品。庆科与阿里有合作关系，阿里云的物联网套件的C-SDK，也有MiCO系统的版本。关于MiCO的更多信息，可以去MiCO开发者论坛（mico.io）了解。 MynewtMynewt（mynewt.apache.org）是Apache软件基金会（ASF: Apache Software Foundation）发起的一个开源项目，专注于物联网应用的实时操作系统。Mynewt的最大特色是包括了低功耗蓝牙（BLE4.2）无线传输协议栈NimBLE。Mynewt支持丰富的实时操作系统特征，可以在不同的硬件平台上运行，包括ARM Cortex M0-M4微控制器，以及基于MIPS和RISC-V架构的处理器。 ContikiContiki （www.contiki-os.org）是一个适用于有内存的嵌入式系统的开源的、高可移植的、支持网络的多任务操作系统。包括一个多任务核心、TCP/IP 堆栈、程序集以及低能耗的无线通讯堆栈。Contiki起源于瑞典的大学，基础内核以及大部分的核心功能是Swedish Institute of Computer Science的Adam Dunkels开发的。Contiki 采用 C 语言开发的非常小型的嵌入式操作系统，运行只需要几K的内存。Contiki都很受学术机构以及高校的科研人员青睐，常用于无线传感器网络（WSN：Wireless Sensor Network）的研究项目中。 NuttXNuttx（www.nuttx.org） 是一个实时嵌入式操作系统，它很小巧，在微控制器环境中使用，可用于8位到32位系统。NuttX的特色在于完全符合POSIX API标准，完全实时，并完全开放。目前常用于无人机的飞控系统中。 RIOT OSRIOT（riot-os.org）的目标是在物联网领域起到Linux在互联网领域那样的影响力。RIOT是一个开源、免费的操作系统。支持8位到32位的微控制器，可以运行在大多数低功耗物联网设备上。在GitHub（github.com/RIOT-OS）上可以找到RIOT的源码。 TinyOSTiny OS是UC Berkeley（加州大学伯克利分校）开发的开放源代码操作系统，专为嵌入式无线传感网络设计。与Contiki类似，Tiny OS同样来自于高校，由于其文档非常完善，其受欢迎程度甚至超过Contiki，不过国内使用者不多。操作系统基于组件（component-based）的架构使得快速更新成为可能，同时又减小了受传感网络存储器限制的代码尺寸。Tiny OS只需要几KB的内存空间和几十KB的编码空间。 ZephyrZephyr尽管是由 Linux 基金会托管的开源项目, 但 Zephyr 是一款完全独立的操作系统, 并未采用 Linux 代码。Zephyr微内核能运行在只有10KB RAM的32位微控制器上，相比之下基于Linux的微控制器项目uClinux需要200KB RAM。 结语除了上面列出来的操作系统，其实还有更多没有列出来的。就连谷歌也没闲着，正在秘密开发一个完全独立于Android的新系统，叫做Fuchsia（灯笼海棠），据说这个系统有可能采用iOS策略，走封闭路线。难道谷歌被安卓碎片化问题伤心了？物联网操作系统要比PC OS以及移动OS体量小，开发起来门槛也没那么高，很多很小的系统都可以作为商用，所以对于物联网产品设计者来说还是有很多选择的。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（九）：物联网设备的标识技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A0%87%E8%AF%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[导语物联网主要由三个方面关键技术：连接、标识以及数据的操作。 在前面的文章中，我们已经谈了很多关于物联网中物体如何连接网络的技术，而实际上物体的标识才是物联网实现的第一步，就是我们要唯一地标识和区分每一个物体。以RFID为代表的物体标识技术曾经几乎就是物联网的代名词，而今RFID的演进技术NFC又在各个领域发挥着重要作用。通过这篇文章，我们来聊一聊物联网设备的标识技术，RFID与NFC究竟有什么关系？ RFID非接触式射频识别(RFID)本质上也是一种无线通信技术，也是通过无线电磁波来传送数据。不过和一般的通信技术不一样的是它的用途，不是打电话，或者发短信，RFID主要用来识别和跟踪物体上绑定的标签，从而实现对物体的管理。RFID技术广泛应用于仓储物流中，用于对货物进行跟踪 RFID系统使用标签（Tag）来识别物体。除了标签，RFID系统还有一个双向无线收发机，被称为读写器（Interrogator/Reader），向标签发送信号，并读取标签的反馈。RFID系统由读写器与标签组成RFID分为被动式RFID与主动式RFID。被动RFID一般是指不带电池的无源RFID，其完全依赖于接收电磁波来驱动电路工作，标签的可识别距离不会变化。主动RFID系统一般指有源的RFID标签，其可识别距离会随着电量的减少而降低。采用RFID技术的ETC系统让通行更加方便 主动RFID一般识别距离都比较长，比如高速公路自动收费站以及自动停车场的ETC系统，一般都采用工作于2.4GHz的主动RFID。不过ETC标签中有一个电池，要是电池没电，就需要更换电池才可以工作。 RFID标签RFID标签由集成电路（IC: Integrated Circuit）和天线两个部分组成：IC用来存储和处理数据，对RF信号进行调制和解调，另外还需要从读写器发出的信号中收集能量驱动自身工作。天线的作用就是发射和接收无线信号。 EPC码格式，EPC码可能逐渐会取代传统的UPC码，即商品条码 RFID标签中存着什么？RFID标签中存储的数据格式一般是EPC（Electronic Product Code）码。EPC码可以识别世界上所有的物体。EPC码的结构由EPCglobal Tag Data Standard标准定义，这个标准是一个公开标准，可以从EPCglobal Inc网站上面免费下载。 NFC技术说完RFID，再来说说近场通信（NFC: Near Field Communication）。NFC是目前手机非常常见的一个通信接口。可以让智能设备通过相互靠近的方式来交换数据。NFC设备也可以与一个无源的NFC标签之间进行通信，这个通信方式就和RFID是一样的。NFC的通信方式NFC技术是由RFID技术演变而来，除了通信协议，NFC标准还规定了数据交换格式。在NFC单一芯片上结合了感应式读卡器、感应式卡片和点对点的功能，能在短距离内与兼容设备进行识别和数据交换。 NFC与RFID的区别（1）工作频段NFC可以理解为RFID技术的一个子集，使用的是13.56MHz频段，而RFID还包括其他频段。RFID的工作频段有很多，低频段有125KHz，高频段有13.56MHz，超高频段有433.92MHz、915MHz，还有微波频段的2.45GHz等。（2）通信距离NFC被称为近场通信，通信距离确实非常近，不超过0.1m。RFID种类很多，可识别距离也不一样。像RFID门禁卡，识别距离和NFC差不多。但对于ETC这种应用场景，就要求识别距离比较长。长距离RFID的识别距离可达几十米甚至上百米。（3）应用场景RFID无论主动还是被动，主要工作还是用于对物体的识别，物流、运输、仓储都广泛使用了RFID技术来跟踪货物。NFC芯片的集成度更高，包括了读卡器与标签于一体。另外NFC的双向通信能力得到了加强。也就是说，NFC不仅可以当做标签来做识别，还可以作为一种双向通信方式用于数据交换。目前NFC最常用于支付领域。NFC技术被广泛应用于支付场景 总的来说，虽然NFC是在RFID技术基础上发展而来的，但是面向不同的应用场景，并不存在替代作用。况且现在RFID的应用场景还是非常多的，NFC暂时还比不了。即使在支付领域和近距离物体识别领域，二维码在很多场景下也能起到NFC的作用，目前对智能手机来说，NFC还不是一个必需的通信接口。如果希望了解更多关于物联网的信息，请继续关注“微说互联网”的“纵论物联网”系列。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（三）：3GPP物联网技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A3GPP%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[导语随着物联网应用的发展，对于大范围组网的需求越来越多，LPWAN技术备受关注。前面的LPWAN技术文章介绍过，LPWAN技术可根据工作频段分为两类：一类是工作于未授权频段的无线技术，以LoRa、SigFox为代表；一类是工作于授权频段下的无线技术，以3GPP支持的2/3/4G蜂窝通信技术为代表。 本文重点介绍一下国际电联下的标准化组织3GPP为物联网应用推进的技术标准，其中最具知名度的技术就是NB-IoT了。 3GPP是什么？ 为了解决各国2G蜂窝通信系统互不兼容的问题，各国通信标准化组织在1998年12月成立了3GPP，最初成立的目标是实现由2G网络到3G网络的平滑过渡，保证未来技术的后向兼容性，支持系统间的漫游。现在3GPP已经发展成为最具权威的国际移动通信标准制订机构，4G以及未来5G的通信标准都是由3GPP来制订。3GPP每一个标准规范都叫做一个Release，简称R-xx，xx是标准的数字编号，比如最早1999年的R99，之后的版本号是R4，R5，等等。3GPP与各种标准化组织的关系 GPRS是在GSM网络基础上发展起来的数据通信技术，用来解决2G网络中数据传输的业务需求。现在广泛应用于物联网项目中。不过由于GPRS的功耗较高、系统容量有限等缺点，所以业界一直寻求GPRS的低功耗低成本的替代方案，也就是LPWAN技术。前文介绍过的LoRa、SigFox都属于这类技术。不过LoRa，SigFox都是公司提出的私有标准，3GPP作为国际性的标准化组织当然也没闲着，针对物联网的技术需求，3GPP也提出了一系列物联网技术标准，总的来说可以分为三类：基于LTE网络演进的LTE-M技术基于GSM/EDGE网络演进的EC-GSM以NB-IoT为代表的Clean Slate技术。LTE-M（eMTC）LTE-M，即LTE-Machine-to-Machine，是基于LTE演进的物联网技术。LTE-M在3GPP标准R12中叫低功耗MTC（Low-Cost MTC），其中MTC是Machine Type Communications的缩写。在R13中LTE-M被称为enhanced MTC，也就是目前媒体在宣传的eMTC。旨在基于现有的LTE载波满足物联网设备需求。为了适应物联网应用场景，3GPP在早期的LTE标准中，曾定义了最低速率的UE设备为Cat-1，这种设备不支持MIMO，使用单天线传输速率低，功耗也低，上行速率为5Mbps，下行速率为10Mbps。为了进一步降低功耗并满足低速率需求，3GPP到了R12中又定义了更低成本、更低功耗的Cat-0，其上下行速率为1Mbps。一般的LTE设备的信道带宽可以达到20MHz，对于低速率的IoT设备来说，完全不需要这么宽的工作带宽。在R13标准中制定了Cat-M1设备标准，最大工作带宽只有1.4MHz，所能支持的最大速率是1Mbps。下图可以看出LTE cat-M1与LTE cat-1、LTE cat-0的传输速率比较。 各种物联网技术的速率比较 EC-GSM3GPP下面有好几个技术规范组（TSG），比如TSG RAN是负责制订LTE标准的。另外还有一个专门负责GSM/EDGE标准的TSG GERAN。GERAN是GSM/EDGE Radio Access Network是缩写，意思是GSM/EDGE无线接入网络。基于GSM演进的物联网标准自然也由TSG GERAN来负责。 3GPP组织结构 2014年3月，3GPP GERAN 提出，要将窄带（200 kHz）物联网技术迁移到GSM上，寻求比传统GPRS高20dB的更广的覆盖范围，并提出了5大目标：提升室内覆盖性能、支持大规模设备连接、减小设备复杂性、减小功耗和时延。这些目标也可以认为是LPWAN技术的共同追求。2015年，TSG GERAN #67会议报告表示，制订的EC-GSM技术已满足5大目标。EC-GSM，即扩展覆盖GSM技术（Extended Coverage-GSM）。虽然标准化已经完成，但没有什么落地的应用。NB-IoT3GPP在R12/R13在LTE标准中加入了MTC相关技术标准，但其本质是在既有LTE技术与架构上进行优化，并不是针对物联网全新设计。不同于MTC，蜂窝物联网(Cellular Internet of Thing, CIoT)项目建议针对物联网特性全新设计，不一定要兼容既有的LTE技术框架。2015年8月，3GPP的TSG RAN开始立项研究窄带无线接入全新的空口技术，称为Clean Slate CIoT。Clean Slate的字面意思就是清白历史，意味着抛掉LTE技术的历史包袱，重新开始设计。在正式标准开始制订以前，企业早已动手开始设计新的空中接口，并形成了两个主要的技术提案：NB-CIoT方案是由华为、沃达丰和高通联合提出，NB-LTE方案是由爱立信、诺基亚等厂家提出。最终，在2015年9月的RAN #69会议上经过激烈撕逼后协商统一，两大阵营相互妥协，最终版本的NB-IoT标准可认为是NB-CIoT和NB-LTE的融合。未来展望今年不断有消息称，国内三大运营商有计划关掉2G网络或者重耕900M频段，将其用于NBIoT网络，估计国内物联网未来eMTC和NBIoT会成为主流技术。但LoRa有先发优势，已经有成熟的商用项目。短期内估计NBIoT的芯片成本还降不下来，预计未来2~3年，多种LPWAN物联网技术会长期共存]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（十）：物联网应用层协议]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[导语物联网的关键技术主要解决三个方面的问题：物体的识别、物体的连接、物体的数据交换。每个方面都有一些技术解决方案，在前面的文章中，我们介绍了RFID、NFC等物体识别及电子标签的技术，也介绍了物联网节点组网与接入的技术。这篇文章主要讲一下物联网的数据是如何处理的。物联网关键技术大全 物联网应用层协议LoRa、NB-IoT以及Zigbee、蓝牙主要解决的是物体互联以及接入网络的问题，从网络协议分层来看，基本上都属于数据链路层协议。对于物联网的数据交换，主要依靠应用层协议来解决。在移动互联网中，最常用的应用层协议就是HTTP协议，HTTP协议同样可以用于物联网系统中。HTTP协议采取的是请求-响应（Request-Response）的通信机制，服务器没有办法主动给客户端发送消息。如果要实现这种消息推送，就需要借助WebSocket这种全双工的通信机制。不过对于很多计算和存储资源有限的物联网节点，不太适合使用HTTP协议。除了HTTP协议以外，也有很多更适合于物联网应用的协议，比如MQTT、CoAP、AMQP、STOMP等。各个物联网软件平台最常使用的物联网协议 发布-订阅机制很多物联网应用层协议都是基于发布-订阅(Publish-Subscribe)机制，这种机制非常适合物联网系统应用。MQTT协议、STOMP协议、AMQP协议以及DDS协议都属于这种发布-订阅的机制。每个传感器节点，采集的数据需要上传到网络，相当于是一个消息的发布，这个消息需要基于某个主题，比如传感器的类型。所有关心这个主题的节点，都可以通过订阅这个主题的消息，实时获取最新的数据。消息的发布和订阅是基于某个主题的，实现机制一般依赖于消息队列 MQTT协议消息队列遥测传输协议（MQTT : Message Queuing Telemetry Transport）是为大量计算能力有限，工作带宽有限、网络环境不可靠的传感器或控制器而设计的协议。MQTT协议基于TCP协议 MQTT协议原来是IBM开发的一个即时通讯协议，基于TCP协议实现。MQTT客户端需要通过消息代理（MQTT Broker）来进行消息的发布和订阅。MQTT协议的兼容性非常好，几乎支持所有平台，可以把各种物联网设备都连接起来。所以MQTT协议也是目前应用最广泛的物联网应用层协议。 CoAP协议受限应用协议（CoAP：Constrained Application Protocol）是6LowPAN协议栈中的应用层协议，基于REST（表述性状态传递）架构风格，支持REST交互。CoAP协议基于UDP协议 CoAP基于UDP协议，其设计初衷就是尽可能地方便地转换为HTTP协议。CoAP让用户可以像使用HTTP协议一样，在资源受限的物联网设备中使用CoAP协议。 AMQP协议高级消息队列协议（AMQP：Advanced Message Queuing Protocol）是一个提供统一消息服务的应用层标准高级消息队列协议，为面向消息的中间件设计。AMQP的工作原理 AMQP的工作原理与MQTT类似，也是基于发布-订阅机制。消息代理Broker的交换机组件（Exchange）会把接收到的消息，根据消息的主题，分配到不同的队列中，以便订阅者接收。RabbitMQ就是在AMQP协议基础上实现的一个消息系统，遵循Mozilla Public License开源协议。RabbitMQ在互联网应用中常被用作消息服务器。 STOMP协议简单(流)文本定向消息协议（STOMP: Simple (or Streaming) Text Orientated Messaging Protocol)，提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。当前非常流行的开源消息服务器ActiveMQ、Apollo、RabbitMQ（需要插件）都支持STOMP协议。ActiveMQ支持TCP、XMPP、STOMP等协议进行消息传输 STOMP基于TCP协议，客户端和服务器之间的通信是通过“帧”（Frame）来实现，每个帧由多“行”（Line）组成。STOMP协议定义了帧结构。 Stomp帧格式STOMP帧第一行是命令，紧跟着键值对形式的Header内容。然后是一个空行，最后是Body内容。数据分发服务DDS数据分发服务（DDS：Data Distribution Service for Real-Time Systems），是面向实时系统的数据分布服务，是由OMG组织提出的协议。 DDS的数据分发的实时效率非常高，能做到秒级内同时分发百万条消息到众多设备。DDS在服务质量（QoS）上提供非常多的保障途径，因此适用于国防军事、工业控制这些高可靠性、可安全性应用领域的原因。不过DDS目前还只限于在有线网络部署，无线网络的可靠性可能满足不了DDS的QoS要求。 总结上面列出了一些比较常见的物联网应用层协议，但并不全面，还有一些相对更加小众的协议，公开资料也比较少。目前很难说哪种物联网应用层协议会实现垄断局面，还要看各自生态和市场需求的未来发展。如果希望了解更多关于物联网的信息，请继续关注“微说互联网”的“纵论物联网”系列。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[最近在网上看到一篇介绍物联网的系列文章《纵论物联网》，但是很遗憾，都是来回转载的，也没有找到出处，零零散散的，东一篇西一篇，看起来很不方便。现汇总收集如下，既做整理，也做收藏。纵论物联网（一）：无线技术分类纵论物联网（二）：LPWAN技术纵论物联网（三）：3GPP物联网技术纵论物联网（五）：除了Linux，还有什么物联网操作系统纵论物联网（六）：基于Linux的物联网操作系统纵论物联网（七）：面向智能家居的物联网解决方案纵论物联网（八）：面向可穿戴设备的无线物联网技术纵论物联网（九）：物联网设备的标识技术纵论物联网（十）：物联网应用层协议]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（八）：面向可穿戴设备的无线物联网技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E6%97%A0%E7%BA%BF%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[导语智能手环、智能手表为代表的可穿戴设备，在短短几年时间内，就已经在全世界普及开来。可穿戴设备是物联网领域很重要的一种设备类型，特点是功耗低、体积小、电量有限 。本文主要介绍可应用于可穿戴设备的无线技术有哪些？ 蓝牙最流行 蓝牙无疑是可穿戴设备最流行的技术，蓝牙耳机就是一种非常常见的可穿戴设备。不过蓝牙耳机所使用的蓝牙技术还属于比较早的版本，一般是蓝牙2.1+EDR版。可穿戴设备中最流行的蓝牙技术都是BLE（Bluetooth low energy ）技术，也就是蓝牙低功耗。目前BLE一般都是蓝牙4.0或4.1版本。可穿戴设备一般体积都比较小，无法容纳电量很大的电池，所以要求无线功耗必须很低，这样才能有较长的续航时间，而不需要经常性地充电。 ANT+：运动家的最爱各种基于ANT+技术的运动传感器 除了蓝牙BLE经常用于手环、智能手表以外，针对运动类的可穿戴产品，ANT+协议也应用得很广泛。可以说，在运动领域，ANT+技术是蓝牙最大的竞争对手。ANT是一个无线传感器网络技术，由Dynastream Innovations下面的ANT Wireless部门设计和推广。ANT工作于2.4GHz ISM频段，有一套完整的通信协议栈。ANT技术与BLE类似，不过只面向传感器应用。ANT+是由ANT+联盟设计和推广的基于ANT协议的兼容性标准，可以认为是ANT的子集。ANT+与ANT的关系，就像WiFi与802.11一样。ANT+的缺点显而易见，就是大多数手机都不支持，只有少数手机，比如Sony的几款手机，支持ANT+技术。不过国际上大多数运动设备，如心率带、踏频器等，都是基于ANT+的。 GPSGPS是一种定位技术，不是用来通信的，但实际上GPS就是一个无线通信系统，只不过GPS接收器是与卫星进行通信，接收卫星的数据然后确定自己的位置。GPS在手环上不常见，一般在高端的运动手表上经常可以看到。尤其对于户外运动爱好者，GPS运动手表是必需品。 其他技术（1）WiFi像Apple Watch这样的智能手表还有上网功能，也就是说，可穿戴设备不必借助手机就可以联网。对于这类可穿戴设备，不再是智能手机的附属品，本身就是一个独立的互联网终端。 （2）GPRS/LTE/eMTC通过WiFi联网只能在有无线AP的地方才行，对于户外就无能为力了。针对老人或者儿童的安全手表，需要有户外联网的能力。GPRS是目前最常采用的技术。对于可穿戴设备来说，LTE是比较少见的，毕竟功耗还是有点高。除非是一些对数据流量有特别需求的产品，比如Apple Watch有LTE版。但要注意的是：LTE与续航不可兼得。面向物联网应用的eMTC，可以支持语音功能，也具有一定的数据传输能力，且功耗比GPRS要低得多，相信在未来将是可穿戴设备联网的首选技术。 结语相信随着技术的进步，可穿戴设备的联网能力越来越强，携带的电池容量很变大，通信的功耗也会降低。到了一定的程度，智能手机可能会以可穿戴设备形式出现在我们的日常生活中。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（七）：面向智能家居的物联网解决方案]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[导语智能家居是非常广泛的一类物联网应用。目前国内最常用的面向智能家居的无线协议有WiFi、Zigbee、433MHz无线技术，另外还有基于电力线载波的有线解决方案。今天我们聊一下常用于智能家居的技术有哪些？ 433MHz及红外 红外与433MHz常用于对家电或照明系统的遥控上。电视、空调通常配备的遥控器都是红外的。如果要通过网络实现远程控制的话，需要有一个能够联网的红外转发设备，把网络指令转换为遥控电器的红外信号。 BroadLink万能遥控器由手机通过WiFi控制，集成了红外及433MHz遥控能力433MHz与2.4GHz一样，也是一个免授权的频段，常用于遥控。与红外相比，433MHz的传输距离更远，不受视距限制，不需要对准被控物体，适合比较大的环境。目前有一些遥控电灯、遥控开关面板，都是基于433MHz的。 ZigbeeZigBee应用广泛Zigbee与WiFi都常用于智能家居的解决方案中。Zigbee协议基于IEEE 802.15标准，主要针对低功耗的射频节点组网而设计。Zigbee使用OQPSK调制技术，传输速率为250kbps，传输距离在10m到100m。Zigbee节点可以扮演中继的作用，组建Mesh网络，因此Zigbee设备可以经过多跳将数据传输到很远范围以外的节点。国内有很多公司都开发了基于Zigbee协议的智能家居解决方案。但相比WiFi来说，Zigbee方案中必须需要网关设备。网关起到协议转换的作用，否则Zigbee设备无法与手机进行互操作，也无法直接接入互联网。 WiFiWiFi可以说是目前最常见的智能家居解决方案。所有的设备都可以接入无线路由器，手机也可以对设备直接进行控制，不需要网关的协议转换，比Zigbee方案更容易被接受。基于WiFi的设备还可以直接接入网络，很容易实现远程控制。不过WiFi的耗电量相比Zigbee略高一些，所以可能不太适合对功耗要求比较苛刻的应用场景。 Z-WaveZ-Wave是由丹麦公司Zensys主导的专门面向智能家居应用的无线组网协议。Z-Wave使用GFSK调制技术，工作于ISM免授权频段。传输速率最高可以达到100kbps，没有Zigbee高。单跳的传输距离要比Zigbee远。与Zigbee类似，Z-Wave也有一个产业联盟，不过没有Zigbee联盟那么强大。Z-Wave联盟中包括了不少智能家居的相关产品，如HVAC、照明、安防等。目前Z-Wave在国内没有得到广泛应用，远远不如Zigbee更受市场青睐。 其他解决方案（1）OpenHABOpenHAB全称为open Home Automation Bus，即开放式家庭自动化总线，该项目旨在为家庭自动化构建提供一个通用的集成平台。OpenHAB是一个基于Java的开源项目，其设计是厂商中立的，与硬件/协议无关。OpenHAB通过绑定，汇集了不同的总线系统、硬件设备和接口协议。 （2）C-BusC-Bus 系统由澳大利亚奇胜（Clipsal）公司开发，该公司是施耐德的子公司。C-Bus 是一种以非屏蔽双绞线作为总线载体，应用于建筑物内照明、空调、火灾探测、出入口、安防等综合管理的智能化控制系统。 （3）InsteonInsteon是一种复杂度低，功耗低，数据传输速率低，成本低的双向混合通信技术，具有即时响应，易安装，易使用，经济可靠的特点，且与X10兼容。之所以说Insteon是混合通信技术，是因为Insteon同时支持电力线通信与无线射频通信两种方式。 （4）KNXKNX是Konnex的缩写。1999年5月，欧洲三大总线协议EIB、BatiBus和EHSA合并成立了Konnex协会，提出了KNX协议。该协议以EIB为基础，兼顾了BatiBus和EHSA的物理层规范，并吸收了BatiBus和EHSA中配置模式等优点，提供了家庭、楼宇自动化的完整解决方案。 （5）UPBUPB是Universal powerline bus的简写，即通用电力线载波总线。UPB也是专门用于家居自动化（home automation）的通信协议，使用电力线传输信令与控制指令。UPB在1999年由美国的PCS Powerline System公司开发。（6）X10X10是一种国际通用的智能家居电力载波协议，用X10的兼容产品可以通过电力线相互沟通，无需重新布线，被控制的电器可多达256路。20世纪80年代，美国SmartHome概念兴起,也就是现在智能家居的原型，在上世纪，X10技术被广泛应用。结语应该说智能家居在互联网兴起以前就发展了一段时间了，因此有很多历史遗留的协议，比如X10, KNX等等。随着互联网的普及，基于IP的协议与传统协议之间就在智能家居领域存在很多竞争和共存的问题。现在智能家居的最大问题就是协议太多，即使底层用一套协议，各家厂商的上层协议也都互不兼容，最后导致用户使用起来很麻烦。这是智能家居没有得到广泛应用的主要问题。想要了解物联网的其他领域应用，请继续关注“微说互联网”及“纵论物联网”系列文章。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音交互系统的自动化测试思考]]></title>
    <url>%2F2017%2F09%2F01%2F%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 机器人OS 不同于传统的OS，不同之处在于交互方式的不同。人机交互界面（HMI)，简化思考无外乎就是输入输出（I/O)，之前的自动化测试可以很大程度上覆盖需求，是否就是很大程度上模拟了输入输出，并分析了输出的结果（不知者无畏）? 长远考虑，从稳定性或者测试效率考虑，搞搞自动化测试应该利大于投入吧？ 原理上能否实现？基本思路如下图：结合机器人OS，输入有（asr/keyevent/mic matrix/visual) 输出有（tts/display/app/motion)，这些在framework部中基本都对应一个server，真实的输入输出由与其绑定的运行在其他进程中的service实现。server的作用基本就是消息转发。对应于系统的整体框架图，基本就是下图中红线框出的部分。特别说明AppServer 也作为一个输出Server，它输出的是对应用的调度动作。综上：在架构实现上需要在（替换/插入）测试service的地方需要在现有代码中做判断：在正常使用时加载正常的service，在测试环境下替换加载测试用的service。测试用service在独立apk中实现，通过service的绑定机制绑定到对应server中。 可以这样实现：基于以上原理，实现一个autotest的apk，在测试模式下替换了正常的AsrService，当机器人开始listen的时候从模拟asr的service中返回预先写好的剧本中的一句话，实现可控输入。操作说明：1、打开自动测试开关修改配置项 auto_test_replace_asr的值为true。2、编写剧本文件目前是固定的文件名（autotest.txt)，稍后实现可选择加载不同的剧本文件每行一个输入语句，换行即为下一条输入。将剧本 push 到 机器人的 sdcard下。例如：123456# 这是注释你好slient 2loop 5今天天气怎么样？end 3、安装机器人AutoTest.apk。4、重启机器人，等待进入执行脚本，执行过程中可根据具体测试用例，认为制造些异常（例如断网等），目前还不支持模拟摸头，唤醒词模拟等(lll￢ω￢)，所以需要手动5、测试过程中，更新autotest.txt 文件修改完重新push后，打开autotest 应用的界面，点击重新加载剧本即可。 长远实现：1、补全可自动化测试的模块实现HeadServiceTest, MicServiceTest, VisualServiceTest, 在自动化时挂载入系统模拟 这几类输入实现TTSServiceTest，DisplayServiceTest, MotionServiceTest, AppServiceTest, 在自动化时插入系统中，获取相应模块执行的结果并记录。2、脚本语法丰富（注释/Listen/Head/Mic/Visual）关键字的简单实现，记录结果的简单语法实现（Speak/App/Show/Do)3、分析：比较输入脚本和记录的输出结果，分析bug4、报告：根据分析结果提供可视化的报告。]]></content>
      <categories>
        <category>旧日往昔</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RT-Linux机器人控制系统实时性的探讨]]></title>
    <url>%2F2017%2F08%2F31%2F%E5%9F%BA%E4%BA%8ERT-Linux%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%97%B6%E6%80%A7%E7%9A%84%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 在机器人控制器的设计中，如何最大程度的提高机器人控制的实时性是一个关键问题。这里我们运用了将软件任务划分实时域与非实时域的思想，实现了一种将RT-Linux与Linux结合的实时机器人控制系统。该系统的优点是：提供了非常高效的满足底层硬件设备的实时性能，可以充分利用 Linux的强大功能；而且RT-Linux是完全开放源代码的免费软件，降低了开发成本。本文是一篇不知从何处舶来的文章，作于2016年11月3日… RT-Linux的系统结构 RT-Linux的基本思想就是使Linux运行在实时核心之下，如图1所示。RT—Linux是一个可加载的核心模块。一个小的RT-Linux实时内核同原来的Linux内核共同控制处理器。实时内核直接管理硬件中断，因此实时内核操纵着机器的响应时间，原来的Linux就无法影响实时任务了。在RT- Linux中设计了两类中断。软中断是正常的Linux中断，硬中断则是真正的实时中断，执行时几乎没有任何延迟。实现时，RT-Linux是通过在 Linux核心和中断处理器之间设计一个仿真软件来达到其目的的。 在RT-Linux中采用两种调度策略。一种是基于优先级的抢占式调度算法；另一种是lsmaelRipoll实现的 EDF（EarliestDeadlineFirst）算法。对于周期性任务可以采用单调率调度算法，即周期短的任务能够获得较高的优先级。调度策略将 Linux视为赋予最低优先级的实时任务。 Linux仅仅在实时系统没有其它任务时运行。Linux和实时任务之间的转换依据上述提及的软中断状态而定。RT-Linux通过这样一种设计方法，将标准的Linux核心改成一个可抢占的、具有低延迟中断处理的实时系统。 实时机器人控制系统的软／硬件结构硬件系统结构 整个实时机器人控制系统主要的硬件部件为：与IBM—PC兼容PentiumIII733MHzq-业控制微机（IPC），内存l28MB；三轴位置控制卡（PCL一832）；l0／100M自适应网卡、集线器等以太网连接设备；机器人本体为具有5个自由度的日产PT500机器人。 机器人控制器运行于一台工业控制微型计算机（IPC）上。在该IPC上安装了两块三轴位置控制卡。每块三轴位置控制卡能对三轴进行联动插补控制。每轴有专用位置芯片控制，构成一个伺服位置和速度环。放在DDA脉冲缓冲器中的脉冲数被传到DDA发生器，在下一个DDA周期中输出。然后由三轴位置控制卡将各轴对应的脉冲数解释为相应的电平信号，驱动伺服驱动器以驱动机器人本体的运动。 软件系统结构 整个机器人实时控制器的系统结构如图2所示，整个系统分为2个域：实时域和非实时域。实时域中实现的是实时设备驱动程序，负责PCL-832位置控制卡的控制与中断响应，驱动机器人本体运动；非实时域中实现的是上层的机器人控制界面和远程监控子系统；二者之问通过实时先进先出（RT-FIFO）缓冲队列进行数据交换。内核调度策略将Linux视为赋予最低优先级的实时任务，Linux中的非实时任务仅仅在实时系统没有其它任务时运行，以确保实时任务的最高实时优先级。 RT-Linux中的实时模块 实时域中的软件模块主要是三轴位置控制卡（PCL一832）的设备驱动程序。驱动程序是能够直接访问硬件的模块，具有应用程序不具备的处理中断和读写端口的能力，是嵌入操作系统核心的底层软件。三轴位置控制卡以毫秒级发出DDA中断请求，对DDA中断的响应的快慢是决定整个机器人控制器实时性能的关键指标。RT-Linux中的三轴位置控制卡的实时设备驱动程序必须处理以下事务： ① 响应三轴位置卡的插补周期中断（DDA），并输出位置脉冲数值； ② 响应三轴位置卡的误差溢出中断（Ov），通知应用程序进行相应处理； ③ 为应用程序提供服务，如读写I／O端口、设置参数、读取状态等。 Linux中的非实时模块 非实时域中的软件模块由机器人控制器和远程监控子系统组成。本地的机器人控制器负责将文本机器人指令解释成相应的位置脉冲数据，通过先进先出（RT- FIFO）缓冲队列发送给实时域中的驱动程序驱动机器人本体运动。同时具有权限的用户能够以离线编程方式或在线操作方式通过高速以太网分别与离线编程与仿真数据发生器和机器人控制器进行连接，实现离线编程和对机器人的实际控制。 实时系统的性能评估 实时系统的性能评估主要在8个方面进行。它们分别是任务换道性能、任务优先级性能、内存分配性能、任务内部通信性能、中断延迟时间、操作系统运行时效率、初始化时间和关机时间。而在机器人控制中最讲究的就是中断响应时问。因为就本项目而言，我们最关I～，RT-Linux系统对三轴位置控制卡（PCL一 832）的DDA中断的响应时间，所有工作的目的就是为了尽量减少中断响应时间。 测试环境及方法 用于测试的工业控制微机的硬件配置为IntelPentium（clockl20MHz），RAM64MB；服务器软件是用 RedHatLinux6.0（内核版本号2.2.5一l5），RT-Linux的版本号2.2；网络环境l0／100M自适应网卡。中断响应时间的快慢直接反映了这样一个过程的快慢：在用户层的用户进程通过系统调用将脉冲数据写入位于核心层的实时驱动程序的数据缓冲队列，在下一个DDA中断请求到来时，中断服务例程将数据缓冲队列中的脉冲数据写入三轴位置控制卡的动作控制芯片的缓冲区，驱动机器人本体运行。图3反映了上述过程。基于RT-Linux机器人控制系统实时性的探讨 测试结果 分别设置DDA周期为8、12、16、24ms的4种情况作了测试，经过计算，可以得出表1所示的结果。基于RT-Linux机器人控制系统实时性的探讨 表1 低负载下D DA中断响应处理时问测试结果 由此得出，在低负载下RT-Linux的测量时间要比Linux下快0.5—0.6ms左右，证明采用RT—Linux系统确实能够提高系统的实时性能。需要注意的是： ① RT—Linux直接接受硬件中断，所以我们将PCL一832卡的DDA中断和OV中断安装在实时域中，目的就是让RT-Linux最先捕获这两个实时中断，进行处理。 ② 如果用户应用层开辟大量的用户进程，则对于分时的标准Linux来说会受到很大程度的影响。 由测试结果可看出，RT-Linux系统中断响应比标准Linux延时时间短，这个结果也预示在系统高负载情况下RT-Linux系统中的实时性能的优势将更为明显。实际使用该实时机器人控制器时，机器人运行非常稳定，能够满足实时控制的需要。]]></content>
      <categories>
        <category>旧日往昔</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷. 硝烟中的scrum和xp]]></title>
    <url>%2F2017%2F08%2F31%2F%E6%95%8F%E6%8D%B7%EF%BC%9A%E7%A1%9D%E7%83%9F%E4%B8%AD%E7%9A%84scrum%E5%92%8Cxp%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 本文是一篇读书笔记，作于2012年3月6日…scrum不能解决问题，解决问题靠开发团队自己出色的团队最重要的是有良好素质的团队，这些素质包括进取心、责任心、良好的习惯、热情，其次才是技术、流程scrum提供了一套实践方法，帮助软件团队养成良好的习惯 scrum原理 目标驱动，在统一的软件交付目标下组织团队 依靠团队的智慧做项目评估、计划乃至设计、开发、测试（？） 抓住项目的最基本开发属性. 周期+质量周期用T表示，质量用B表示（bug数目量化），scrum有助于T*B 尽量小， scrum的角色和职责 产品负责人(product owner)，定义开发目标、需要实现的features和优先级 scrum master，保证团队高效而不受打扰的工作，优化工作条件、过程 团队(team)，自组织的完成项目开发,使用一切可行手段保证进度和质量外围有user,customer,Management scrum过程 前期. 产品负责人整理业务需求，形成product backlog库 执行. 以sprint为单位进行迭代完成sprint backlog，每日例会+issues，sprint结束时交付可运行的产品 后期. sprint完成后通过sprint回顾发现问题和改进点，制定下个sprint要引入的新的实践? scrum的精髓 以上过程也没什么特别的，和UP的迭代几乎一样。精髓在于“检查并适应”，在三个角色、三种仪式（sprint计划、sprint回顾、每日例会）、三种制品（backlog、sprint backlog、燃尽图）的基础上，可以根据公司和项目情况，因地制宜的引入任何有利于缩短开发周期、提高产品质量的实践。 具体细节 sprint前. 产品负责人收集需求，形成backlog，backlog以统一格式定义，重要的属性有. 名称、重要性、估算时间、简单描述、如何演示等，详细的需求可以在其他需求文档中定义。产品负责人可以通过任何渠道、方式获取和确认需求。 sprint启动会议. 一个sprint周期为两周，一次sprint会议约一个下午，参与人员为3个角色都参加，scrum master主持会议。会议内容详细沟通产品负责人选定的重要性高的产品backlog细节，确保团队对需求的理解无误。团队根据需求理解将backlog拆分成任务，并给出每个backlog的估算时间，产品负责人和团队根据sprint内可用的人天和backlog的时间估算，选定需要排入本次sprint的backlog，scrum master和团队分派任务，制定sprint计划。 sprint中. 整理一面任务墙，将sprint内的backlog和任务按照未开始、进行中、已完成等状态进行归类（任务单位以小于等于1天为宜），同时展示sprint的燃尽图scrum master每天早上固定时间组织团队的每日例会 （站立会议，控制时间为10-15分钟），确认每个成员前一天完成的工作、当天要进行的工作、工作中碰到的问题、并更新任务墙。任何需求变更都进行实时评估，超过规划人天的backlog视情况进行拆分或者推迟其他重要性低的backlog。任何完成的backlog都需要演示给产品负责人和QA后才能提交测试。 sprint后. scrum master召集、组织sprint回顾会议。回顾会议以头脑风暴的方式review sprint过程和结果，发现和列举存在的问题，与会人员投票决定需要在下个sprint中解决1-3个问题，探讨解决方案，确定实践方式。 scrum精神 团队目标终于岗位职责 团队工作优于独立作战 高效沟通强于标准化的文档 高能动性、自组织的团队胜于角色划分清晰的流水线 务实的解决问题的方法好于经典理论 快速实践、快速反馈、持续优化 我们怎样编写产品Backlog其他人也可以添加backlog条目，但重要性必须由产品负责人决定迭代开发基本需求. 迭代要有固定时长（时间盒），不能超过六个星期。 在每一次迭代的结尾，代码都必须经过OA的测试，能够正常工作。Nokia的Scrum标准 Scrum团队必须要有产品负责任，而且团队都清楚这个人是谁。 产品负责人必须要有产品Backlog，其中包括团队对他进行的估算。 团队必须要有燃尽图，而且要了解他们自己的生产率。 在一个Sprint中，外人不能干预团队的工作。产品backlog 包括需求、故事、特性组成的列表，按重要性排序，包含了客户想要的东西，用客户的术语加以排序如何让产品backlog停留在业务层次上“给Events表添加索引” 应该 被 “提高后台系统中搜索事件的响应速度” 代替添加索引只是一种解决方案，而且还未必能真正解决问题，回归到问题的原始出发点，这个可以用《你的灯亮着吗》来指导 backlog条目 标识符（ID）， 名称（name）， 重要性（Importance），这个故事有多重要 如. 10或150 分数越高越重要 初始估算（Initial estimate）， 工作量估算（把3个人关在一起，大约需要4天时间） 如何做演示（How to demo）， （先这样做，然后那样做，就应该得到…的结果） 注释（Notes）如.格外的故事字段 Track（类别） Components（组件） Requestor（请求者） 我们怎样准备Spring计划 产品Backlog必须存在 只能有高一产品Backlog和一个产品负责人（对于一个产品而言） 所有重要的Backlog条目都已经根据重要性被评分过，不同的重要程度对应不同的分数。注意. 产品负责任之外的人也可以向产品Backlog中添加故事，但是他们不能说这个故事有多重要，这是产品负责任独有的权利，他们不能添加时间估算，这是开发团队独有的权利。Spring计划会议 sprint目标 团队成员名单 sprint backlog 故事列表。 确定好sprint演示日期。 确定好时间地点，供举行每日scrum会议。 产品负责人必须参加？（scope（范围）和重要性（importance）由产品负责人设置 estimate（估算）有团队设置 ） 用本能反应来估算工作时间（如. 兄弟在三天能完成故事A吗？） sprint会议开始前需要定一个大致的时间计划， 每个sprint的目标要有一个概要的描述， 团队成员名单以及每个人的投入程度， 其他 一个sprint包含多少故事由团队决定，而不是产品负责人或其他人，产品负责人只能通过修改故事范围、优先级来让团队选择哪些故事进入sprint， 定义完成. 放入测试环境可以测试 时间估算. 团队所有成员对故事进行估算，包括测试人员、开发人员，集合大家的估算确定最终确定故事力求在1-5人天完成 故事拆分成任务，故事是可以交付的，任务是不可交付的 技术故事. 需要完成但又是不可交付的东西，比如安装持续集成服务器，编写系统设计概览。 技术故事不由产品负责人管理，如果产品负责人可以对技术故事的优先级进行评估为什么都交给他呢？ bug: 如果开发完的功能被测试出bug，bug用jira进行了管理，也有优先级，建议将bug当做是sprint backlog的一部分，按照优先级进行评估是否进入sprint， 怎样让别人了解我们的sprint我们要让整个公司了解我们在做些什么，这件事情至关重要。否则其他人就会发出抱怨，甚或对我们的工作做出臆断。 使用sprint信息页，将sprint列举出来，将sprint信息放到wiki上，邮件通知到家 怎样编写sprint backlog一块白板，记录没开始的故事，今天开始的故事，这个sprint完成的故事。故事用白纸，任务用黄色贴纸，燃尽图. 横坐标是日期（去掉非工作日），竖坐标是工作量，story point，可以用人*时表示， 怎样布置团队房间让团队坐在一起， 怎样进行每日例会团队每个人自觉更新sprint backlog的状态， 怎样进行sprint演示所有sprint都结束于演示快速演示，演示我们实现了什么而不是我们怎么实现的， 怎样做sprint回顾这是改进的最佳时机，你不需要在回顾会议上得到什么好点子，在家中的浴盆里就能做得到！轮流发言，scrum master最后总结哪些做法可以保持，哪些做法可以改进，具体改进的想法， sprints之间的休整片刻，在启动新的 sprint 之前，每个人都应该至少度过一个不需要考虑 sprint 的夜晚。更好的是sprint结束在周五，这样就一个周末，最好结束在周四，周五大家搞一个LAB Day，（lab day也是要准备的。。） 如何制定发布计划处理固定价格的合同 我们怎样组合使用 Scrum和 XPScrum 注重的是管理和组织实践，而XP 关注的是实际的编程实践。CI. 把这一切搭建起来需要大量工作，但付出的每一分钟都物有所值。 怎样做测试把测试人员加入到Scrum团队中，测试人员就是验收先生]]></content>
      <categories>
        <category>旧日往昔</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javah 命令详解]]></title>
    <url>%2F2017%2F08%2F30%2F2017-8-19-Javah-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JNI/NDK开发的过程中我们会遇到一个很关键的命令 javah 在ubuntu 上使用 man 命令查阅使用手册，可知 javah 命令的作用如下： javah - C Header and Stub File Generator. javah produces C header files and C source files from a Java class. These files provide the connective glue that allow your Java and C code tointeract.简单讲就是为java类中的navtive方法生成 c 语言的头文件。先看下ubuntu上的帮助如下：123456789101112131415$ javah --helpUsage: javah [options] &lt;classes&gt;where [options] include: -o &lt;file&gt; Output file (only one of -d or -o may be used) -d &lt;dir&gt; Output directory -v -verbose Enable verbose output -h --help -? Print this message -version Print version information -jni Generate JNI-style header file (default) -force Always write output files -classpath &lt;path&gt; Path from which to load classes -bootclasspath &lt;path&gt; Path from which to load bootstrap classes&lt;classes&gt; are specified with their fully qualified names(for example, java.lang.Object). 其中重要的几个参数 o d classpath 重点关注下。 遇到一坑在百度搜索 Android studio jni 开发，好多的文章都是这么写的： 再打开Terminal输入指令cd app/build/intermediates/classes/debug然后再输入指令javah -jni com.wobiancao.ndkjnidemo.ndk.JniUtils注意 这里javah -jni后面跟的是JniUtils类的全路径，如果javah报不存在之类的，是你的java环境没有配置好。摘自Android Studio ndk-Jni开发详细 注：本文不解决如何开始jni开发的问题，这个问题可参考Android Studio ndk-Jni开发详细 一般情况下这样写没啥问题，然后我的类是这个样子的时候，报错了：12345678910111213package com.test.mylibrary;import org.json.JSONObject;public class Test &#123; public static String doTest(JSONObject jsObj) &#123; test(); return ""; &#125; public static native void test();&#125; 错误如下：123456$ javah -jni com.test.mylibrary.TestError: Class org.json.JSONObject could not be found.$ javah -classpath ~/tools/adt-bundle/sdk/platforms/android-26/android.jar com.test.mylibrary.TestError: Could not find class file for &apos;com.test.mylibrary.Test&apos;.$ javah -classpath ./:~/tools/adt-bundle/sdk/platforms/android-26/android.jar com.test.mylibrary.TestError: Class org.json.JSONObject could not be found. 其实也没啥特别的就是import 了个JSONObject ，import 其他的类也没有问题，然后根据网上的各种经验指定classpath的路径，还是继续Error 。 解决其实也很简单，就是不要在build目录下执行即可，在src/main/java 目录下呢直接执行就可以了，不在src/main/java 目录下则指定classpath路径也可以，如下：12345$ javah -jni com.test.mylibrary.Test$ cd ../$ javah -classpath java -jni com.test.mylibrary.Test$ cd ../$ javah -classpath main/java -jni com.test.mylibrary.Test 其中 -jni 生成jni格式的头文件是默认的，所以不写也是可以的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android FileObserver 类使用指南]]></title>
    <url>%2F2017%2F08%2F30%2FAndroid-FileObserver%20%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[有一种知识就是知道与不知道的区别，我们遇到的很多困难都是这种类型，不知道死活都想不到，知道了也就不过如此最近我们的开发框架在做插件化的功能，用来已插件的形式加载场景和功能（这俩都是开发框架的概念），插件已一个独立apk的形式存在，放在固定的目录下不需要安装，框架启动时就会去加载apk中包裹的插件。有这么个需求，就是该目录下的这些个apk发生变动时 新增 , 删除 , 更新 时，能够load或unload或reload 其中对应的插件，说白了就是监控这个目录的变化。进入正文 inotify本文要讲的是android 的 FileObserver类，而inotify则是该类功能实现所依赖的基础。 Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。使用 inotify 很简单：创建一个文件描述符，附加一个或多个监视器（一个监视器 是一个路径和一组事件），然后使用 read 方法从描述符获取事件。read 并不会用光整个周期，它在事件发生之前是被阻塞的。 以上是百度百科对inotify的描述，FileObserver的原理大致就是如此，关于 inotify 了解到此即可。 FileObserver下面引用android源码中的注释，对于学习而言android的源码及源码的注释简直就是个巨大的宝藏123456789101112131415161718/** * Monitors files (using &lt;a href="http://en.wikipedia.org/wiki/Inotify"&gt;inotify&lt;/a&gt;) * to fire an event after files are accessed or changed by by any process on * the device (including this one). FileObserver is an abstract class; * subclasses must implement the event handler &#123;@link #onEvent(int, String)&#125;. * * &lt;p&gt;Each FileObserver instance monitors a single file or directory. * If a directory is monitored, events will be triggered for all files and * subdirectories inside the monitored directory.&lt;/p&gt; * * &lt;p&gt;An event mask is used to specify which changes or actions to report. * Event type constants are used to describe the possible changes in the * event mask as well as what actually happened in event callbacks.&lt;/p&gt; * * &lt;p class="caution"&gt;&lt;b&gt;Warning&lt;/b&gt;: If a FileObserver is garbage collected, it * will stop sending events. To ensure you keep receiving events, you must * keep a reference to the FileObserver instance from some other live object.&lt;/p&gt; */ FileObserver 可以监听的事件类型如下： 事件 说明 ACCESS 即文件被访问 MODIFY 文件被修改 ATTRIB 文件属性被修改，如 chmod、chown、touch 等 CLOSE_WRITE 可写文件被 close CLOSE_NOWRITE 不可写文件被 close OPEN 文件被 open MOVED_FROM 文件被移走，如 mv MOVED_TO 文件被移来，如 mv、cp CREATE 创建新文件 DELETE 文件被删除，如 rm DELETE_SELF 自删除，即一个可执行文件在执行时删除自己 MOVE_SELF 自移动，即一个可执行文件在执行时移动自己 CLOSE 文件被关闭，等同于(IN_CLOSE_WRITE IN_CLOSE_NOWRITE) ALL_EVENTS 包括上面的所有事件 FileObserver的实现也很简单，创建自己的obsever类继承自FileObserver即可，只需重写唯一的一个abstract方法 onEvent 。示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 class PluginFileObserver extends FileObserver &#123; private static final String TAG = "PluginFileObserver"; public static int PLUGIN_FILE_CHANGED = CREATE | DELETE | MODIFY | MOVED_FROM | MOVED_TO; private static ArrayList&lt;PluginFileObserver&gt; stubs = new ArrayList&lt;&gt;(); private Context mContext; private String mPath; private int mMask; public PluginFileObserver(Context context, String path) &#123; this(context, path, ALL_EVENTS); &#125; public PluginFileObserver(Context context, String path, int mask) &#123; super(path, mask); mContext = context; mPath = path; mMask = mask; stubs.add(this); &#125; @Override public void onEvent(int event, String path) &#123; Logger.i(TAG, "[PLUGIN] PluginFileObserver onEvent with event:" + event + " path:" + path); switch (event) &#123; case FileObserver.CREATE: case FileObserver.MOVED_TO: Logger.i(TAG, "[PLUGIN] PluginFileObserver will add plugin: " + path); break; case FileObserver.DELETE: case FileObserver.MOVED_FROM: Logger.i(TAG, "[PLUGIN] PluginFileObserver will remove plugin: " + path); break; case FileObserver.MODIFY: Logger.i(TAG, "[PLUGIN] PluginFileObserver will update plugin: " + path); break; default: Logger.i(TAG, "[PLUGIN] PluginFileObserver don't care this event"); break; &#125; &#125;&#125; 使用也很简单，创建FileObserver对象，指定要监控的路径，指定监控的事件 ，调用startWatching()启动监控，使用完毕调用stopWatching()停止监控。 12345 PluginFileObserver observer = new PluginFileObserver(mContext, pluginPath, PluginFileObserver.PLUGIN_FILE_CHANGED); //开始监控observer.startWatching();//停止监控observer.stopWatching(); 遇到一坑 必须调用startWatching()方法，否则接收不到事件 必须保证FileObserver对象不被GC回收，否则回收后接收不到事件 指定路径如果是个目录，对目录下的子目录内内容变动，接收不到事件，不过可以递归创建子目录的FileObserver。 有时候处理不当，会造成事件循环产生，先入死循环。 最坑 当你把代码写好了，要进行测试了，连接上adb shell 后，修改下目录下的文件已用来测试，结果收不到事件。对的，在adb shell 下操作对应的文件，收不到事件，若要测试，最好直接操作设备的文件管理器或者写代码创建删除文件测试。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom配置入门]]></title>
    <url>%2F2017%2F08%2F29%2Fatom%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[atom 编辑器就是这样一款利器，得益于其强大而方便的插件化安装，几乎可以满足你的任意写作需求。另外，它提供全平台支持，无论是windows还是ubuntu都有很好的支持，且使用体验完全一致。对于在多种操作系统上工作学习的同学来说，极大的减少了再各平台重复学习的成本。以上都是闲话… 获取atom 可从官方地址下载：Atom 各人有各人的需求，我主要是需要快速完成一些文档兼简要的写些另外的文档以记录一下完成这些文档学习到的新技能，理所当然的钟爱markdown。markdown 是一种可以使用普通的文本编辑器编写的标记语言。通过简单的语法标记，可以使文本具有一定的格式。 基本语法介绍 比如如下的简单格式： 123456789### 这是三级标题&gt;工欲善其事必先利其器——这是引用#### 简单语法- 标题- 列表- 待办事项- 引用- [ ] 这是未完成的待办事项- [x] 这是已完成的待办事项 经过markdown编辑器预览可以是： 再比如如下的内容是一个表格：1234| 序号 | 内容 || -- | -- || 1 | 这是第一行 || 2 | 这是第二行 | 经过markdown编辑器预览可以是： 另外还可以插入高亮的代码：1234567891011\```javapublic class Demo &#123; private String name; private int age; public Demo(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;\ 1234567891011121314151617181920经过markdown编辑器预览可以可以是：![markdown code](http://ovfro7ddi.bkt.clouddn.com/markdown%20code.png)### 实用插件配置#### __markdown 预览__![intro](https://user-images.githubusercontent.com/1908863/28227953-eb6eefa4-68a1-11e7-8769-96ea83facf3b.png)atom 默认已经安装了markdown的预览插件：markwon-preview 但是默认的往往功能不够强大，强烈建议卸载之（可以实用快捷键 __ctrl+shift+p__ 这个万能键，然后在弹出的框内输入uninstall package 就会列出提示，然后进入对应的界面卸载就可以了）建议安装插件：__markdown preview Enhanced__， 安装后使用快捷键 __ctrl+shift+m__ 进行预览，该预览插件支持 __mermaid__ 图形预览 和 __MathJax__ 数学公式预览markdown preview Enhanced 还有很多非常强大的功能： - 更多介绍可参考 [markdown preview enhanced 简介](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/) - 项目[gitup](https://github.com/shd101wyy/markdown-preview-enhanced)#### __atom-mermaid__ 图形预览如下是mermaid的官方说明：&gt;Generation of diagrams and flowcharts from text in a similar manner as markdown.在atom 中使用 则需要安装包 __atom-mermaid__下图是从官网的介绍中获取的一张图：![intro](http://y-takey.github.io/atom-mermaid-example.gif)正如官方的描述，mermaid的作用就是使用简单的文本语法，使用文本来绘制图。更多mermaid的用法可以参考 [mermaid 官方介绍](https://mermaidjs.github.io/)。__但是划重点了啊__ 在markdown中使用，需要将其当做代码块输入，示例如下： 12graph LRA --&gt;B 123456789而且必须指明语言类型为&quot;mermaid&quot;本文只解决了解的问题，此处不再做更详细的介绍，更多使用的详细语法，还请移步[官方介绍](https://mermaidjs.github.io/)#### __MathJax__ 数学公式如要在atom markdwon 预览使用 mathjax， 需要在 markdown-preview-enhanced 的设置项__【Math Rendering option】__选项中指明使用 mathjax 渲染。除此之外倒是没有发现需要独立安装其他package。- MathJax 项目的[github](https://github.com/mathjax/MathJax)- MathJax 具体的[使用文档](http://docs.mathjax.org/en/latest/start.html)在markdown 中使用math jax 有两种用法：一种是行内公式，公式内容写在两个$中间，例如： $(x^{(i)}, y^{(i)})$:ith training example, 代表训练集中的第i个数据123这种写法的展现效果如下：&gt;$(x^&#123;(i)&#125;, y^&#123;(i)&#125;)$:ith training example, 代表训练集中的第i个数据另外一种是独立行公式，公式前后以$$为标记，例如： $$h_\theta(X)=\theta_0+\theta_1X$$```这种写法的展现效果如下： $$h_\theta(X)=\theta_0+\theta_1X$$ 结语如上所述，介绍了atom 编辑markdown的一些插件和方法，至于一些更常用的操作，比如，如何导出pdf等，可以百度一下了。在atom 中使用markdown，可以有格式，有列表，有代码，有引用，有表格，有图标，有公式，基本可以满足所有的写作需求了。这还只是这些功能的皮毛而已，可见markdown真的是无敌的强大。]]></content>
      <categories>
        <category>Blog 写作 教程</category>
        <category>Atom 教程</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 编码规范]]></title>
    <url>%2F2017%2F08%2F12%2Fjava-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1 介绍本规范参考java 官方编码规范，简化而来，更详细的介绍请参考Code Conventions for the Java TM Programming Language本规范适用但不限于OS Lite项目使用。 2 文件名这项目组列出了常用的文件名及其后缀。 2.1 文件后缀Java程序应用下列文件后缀： 文件类别 文件后缀 Java源文件 .java Java字节码文件 .class 2.2 常用文件常用的文件名包含： 文件名 用处 README.md 大的独立模块下用来说明该模块打使用注意事项等 3 文件组织一个文件由被空行分隔而成的段落以及标识每个段落的注释共同构成。超过2000行的程序难以浏览，应当尽量避免。 3.1 Java源文件若private类或interface与一个public类关系紧密，可以将它们放入同一个源文件，但是public类必须是这个文件中的第一个类或接口。 Java源文件应遵守以下规范： 开首注释 包和引入语句 类和接口声明 3.1.1 文件头注释为了方便生成api ref，所有的源文件都应当有文件头注释例如：1234567/*** Version information** Date** Copyright notice*/ 3.1.2 包和引入语句在多半Java源文件中，第一个非注释行是包语句。在它之后可以跟引入语句123package com.turing123.robotframe;import android.content.Context; 3.1.3 类和接口声明下表描述了类和接口声明 序号 类/接口声明的各项目 注解 1 类/接口文档注释（/*……/） 该注释中所需包含的信息，拜见”文档注释” 2 类或接口的声明 3 类的（静态）变量 开头是类的公共常量，最后是私有常量。 4 实例变量 同上 5 构造方法 6 成员方法 这些方法应当按功能分组。例如，一个私有的类方法可以置于两个公有的实例方法之间。其目标是为了更便于浏览代码。 4 缩进排版4个空格作为缩进排版的一个单位。 4.1 行长度尽量避免一行的长度跨越100个字符。 4.2 换行当一个表达式无法容纳在一行内时，可以根据如下规则断开之： 在一个逗号后面断开 在一个操纵符前面断开 新的一行应当与上一行同一级别表达式的开首处对齐 12public void prepare(@NonNull MessageInterceptor interceptor, @NonNull final RobotFramePreparedListener listener) if语句的换行,例如：123456if (behaviors == null || behaviors.behaviors == null || behaviors.behaviors.size() == 0) &#123; //do something&#125; 三元运算表达式打换行，例如：12345alpha = （aLongBooleanExpression） ？ beta : gamma;alpha = （aLongBooleanExpression）？ beta : gamma; 5 注释5.1 注释的格式程序可以有4种实现注释的风格：块（block）、单行（single-line）、尾端（trailing）和行末（end-of-line）。 5.1.1 块注释块注释每个文件的开端处以及每个方法之前。它们也可以被用于方法内部。在功能和方法内部的块注释应当和它们所描述的代码具有一样的缩进格局。 块注释可以以/**开头123456/** * Set NLP Sever's ApiKey and Secret. * * @param apiKey Your ApiKey. * @param secret Your Secret. */ 5.1.2 单行注释短注释可以显示在一行内,单行注释之前应当有一个空行。12345if （condition） &#123; /* Handle thecondition. */ ...&#125; 5.1.4 行末注释1234567891011121314151617if （foo &gt; 1） &#123; // Do adouble-flip. ...&#125;else &#123; return false; // Explain why here.&#125;//if （bar &gt; 1）&#123;//// // Do a triple-flip.// ...//&#125;//else &#123;// return false;//&#125; 5.2 文档注释文档注释描述Java的类、接口、方法以及字段（field）。每个文档注释都邑被置于注释定界符/*…/之中，一个注释对应一个类、接口或成员。该注释应位于声明之前，该注释将被用来生成javadoc api ref.12345678910/** * Provide ASR function */public final class ASR extends FunctionBase&#123; /** * Chat Mode: CHAT_MODE_AUTO * Robot framework's chat will auto running, you needn't care about asr and ask the cloud. */ public static final int CHAT_MODE_AUTO = 0;&#125; 6 声明6.1 每行声明变量的数量推荐一行一个声明，因为这样利于写注释12int level; // indentation levelint size; // size of table 6.2 初始化尽量在声明局部变量的同时初始化 6.3 布局只在代码块的开端处声明变量,不要在初次用到该变量时才声明它。12345678void myMethod（） &#123; int int1 = 0; // beginning of method block if （condition） &#123; int int2 = 0; // beginning of "if"block ... &#125;&#125; 6.4 类和接口的声明当编写类和接口是，应当遵守以下格局规范： 在方法名与其参数列表之前的左括号”（”间不要有空格 左大括号”{“位于声明语句同业的末尾 右大括号”}”另起一行，与响应的声明语句对齐，除非是一个空语句，”}”应紧跟在”{“之后1234567891011121314151617181920212223242526public class Behavior &#123; public String exception; public IntentInfo intent; public Recommend recommend; public List&lt;ResponseResult&gt; results; public List&lt;Sequence&gt; sequences; public Emotion emotion; public Behavior() &#123; &#125; public Behavior(String exception) &#123; this.exception = exception; &#125; public Behavior(String exception, IntentInfo intent, Recommend recommend, List&lt;ResponseResult&gt; results, List&lt;Sequence&gt; sequences, Emotion emotion) &#123; this.exception = exception; this.intent = intent; this.recommend = recommend; this.results = results; this.sequences = sequences; this.emotion = emotion; &#125;&#125; 7 语句7.1 简单语句123argv++; // Correctargc--; // Correctargv++; argc--; // AVOID! 7.2 复合语句 被括此中的语句应当较之复合语句缩进一个层次 左大括号”{“应位于复合语句开端行的行尾；右大括号”}”应另起一行并与复合语句首行对齐。 7.3 返回语句一个带返回值的return语句不应用小括号”（）” 7.4 if，if-else，if else-if else语句（if， if-else， if else-if elseStatements）if-else语句应当具有如下格示：1234567891011121314151617if （condition） &#123; statements;&#125;if （condition） &#123; statements;&#125; else &#123; statements;&#125;if （condition） &#123; statements;&#125; else if （condition） &#123; statements;&#125; else &#123; statements;&#125; 7.5 for语句一个for语句应当具有如下格示：123for （initialization; condition; ） &#123; statements;&#125; 一个空的for语句应当具有如下格示：1for （initialization; condition; ）; 7.6 while语句一个while语句应当具有如下格示：123while （condition） &#123; statements;&#125; 一个空的while语句应当具有如下格示：1while （condition）; 7.7 do-while语句一个do-while语句应当具有如下格示：123do &#123; statements;&#125; while （condition）; 7.8 switch语句一个switch语句应当具有如下格示：12345678910111213141516switch （condition） &#123;case ABC: statements; /* falls through */case DEF: statements; break;case XYZ: statements; break;default: statements; break;&#125; 7.9 try-catch语句一个try-catch语句应当具有如下格示：12345try &#123; statements;&#125; catch （ExceptionClass e） &#123; statements;&#125; 或1234567try &#123; statements;&#125; catch （ExceptionClass e） &#123; statements;&#125; finally &#123; statements;&#125; 8 空白8.1 空行空行将逻辑相干的代码段分隔开。 下列景象应当是应用两个空行： 一个源文件的两个片段（section）之间 类声明和接口声明之间 下列景象应当是应用一个空行： 两个方法之间 方法内的局部变量和方法的第一条语句之间 8.2 空格下列情况当应用空格： 一个紧跟着括号的关键字应当被空格分隔，例如：123while （true） &#123; ...&#125; 注意：空格不该该置于法名与其左括号之间。这将有助于区分关键字和方法调用。 空白应当位于参数列表中逗号的后面 所有的二元运算符，除了”.”，应当应用空格将之与操纵数分隔。一元操纵符和操纵数之间不因该加空格，比如：负号（”-“）、自增（”++”）和自减（”–”）。例如： 9 命名规范 标识符类型 命名规范 例子 包 一个独一包名的前缀老是全部小写的ASCII字母并且是一个域名，这类命名规范可能以特定目次名的构成来区分部 门（department），项目（project）。 com.turing123.robotframe 类 命名规范：类名是个一名词，采取大小写混淆的体式格式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。应用完全单词，避免缩写词 class Behavior 接口 命名规范：大小写规范与类名类似 interface IASRCallback 方法 方法名是一个动词，采取大小写混淆的体式格式，第一个单词的首字母小写，其后单词的首字母大写。 void onStartRecord() 变量 除了变量名外，所有实例，包含类，类常量，均采取大小写混淆的体式格式，第一个单词的首字母小写，其后单词的首字母大写。变量名不该以下划线或美元符号开首，尽管这在语法上是容许的。变量名应简短且富于描述。变量名的选用应当易于记忆，即，可以或许指出其用处。尽量避免单个字符的变量名，除非是一次性的姑且变量。姑且变量凡是被取名为i，j，k，m和n，它们一般用于整型；c，d，e，它们一般用于字符型。 char c; 实例变量 大小写规范和变量名类似 常量 类常量应当全部大写，单词间用下划线隔开 public static final int CHAT_MODE_AUTO = 0 10 Java源文件示例下面的例子，显示了一公共类的Java源程序（仅作为示例）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.turing123.robotframe;import android.content.Context;/** * &lt;p&gt; * The entry to use RobotFrame.&lt;br/&gt;&lt;br/&gt; * Usage:&lt;br/&gt; * The method &lt;font color="blue"&gt;prepare&lt;/font&gt; must be called prior to any method calling on this frame. * The normal steps to use this frame are as blow:&lt;br/&gt; * 1. call &lt;font color="blue"&gt;getInstance()&lt;/font&gt;&lt;br/&gt; * 2. call &lt;font color="blue"&gt;prepare(prepareListener)&lt;/font&gt;&lt;br/&gt; * 3. waiting for prepareListener callback&lt;br/&gt; * 4.1 if success, call &lt;font color="blue"&gt;start()&lt;/font&gt; to launch the robot up&lt;br/&gt; * 4.2 if error occurred, check and fix the issue according to error message&lt;br/&gt; * 5. if robot is attempting to shutdown, call method &lt;font color="blue"&gt;shutDown(shutdownListener)&lt;/font&gt; * first and wait until the shutdownListener called back.&lt;br/&gt; * &lt;p&gt; * &lt;strong&gt;&lt;font color="red"&gt;WARNING: Any violation from the steps above will cause unpredictable * behaviors.&lt;/font&gt;&lt;/strong&gt; */public class RobotFrameManager &#123; /** * Chat Mode: CHAT_MODE_AUTO * Robot framework's chat will auto running, you needn't care about asr and ask the cloud. */ public static final int CHAT_MODE_AUTO = 0; /** * Chat Mode: CHAT_MODE_MANUAL * Robot framework‘s Chat requires manual call ASR and ask the cloud. * In this mode, the output mode only is &#123;@link #OUTPUT_MODE_ASSEMBLE&#125; */ public static final int CHAT_MODE_MANUAL = 1; private static RobotFrameManager mInstance = null; private FrameService mService; private Context mContext; public RobotFrameManager(Context context) &#123; mContext = context; SystemProperties.getInstance().init(context); mService = new FrameService(context); PluginService.setUp(mContext); &#125; /** * Be RobotFrame prepared, must be called prior to any calling to other method * * @param states the Frame working mode and states(if has) * @param listener the callback listener */ public void prepare(int states, @NonNull final RobotFramePreparedListener listener) &#123; mService.prepare(states,listener); &#125; /** * The robot starting run */ public void start() throws IllegalStateException &#123; mService.start(); &#125; /** * Set NLP Sever's ApiKey and Secret. * * @param apiKey Your ApiKey. * @param secret Your Secret. */ public void setApiKeyAndSecret(String apiKey, String secret) &#123; Preconditions.checkNotNull(apiKey, true); Preconditions.checkNotNull(secret, true); Settings.init(mContext); Settings.put(SettingsKey.TURING_APIKEY, apiKey); Settings.put(SettingsKey.TURING_SECRET, secret); Settings.deInit(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习笔记（二）]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习资源 6、2 - 1 - Model Representation 【中文】 学习内容监督学习的特点：针对每一个问题都给出了正确的答案 监督学习的过程可描述为：通过把Training Set 喂给 Learning algorithm 得出一个 hypothesis，然后传入要预测的特征值给得到的 hypothesis，从而得到预测的结果。 线性回归模型 是典型的且最简单的监督学习模型。 符号表示监督学习中关于Traning Set 定义了一些符号： m: number of Training set x’s: “input” variable/features y’2: “output” variable/“target” variable (x, y): one training example, 代表一个训练集中的数据 $(x^{(i)}, y^{(i)})$:ith training example, 代表训练集中的第i个数据 单变量的线性回归可用如下表达式表示：$$h_\theta(X)=\theta_0+\theta_1X$$]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习笔记（一）]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景介绍AI 已是大势所趋，况且又处在这个行业，又在一家人工智能的公司工作做聊天机器人的技术工作。然而，所做的工作又与机器学习基本毫不相干，这么高大上又前景颇好的东西近在眼前确触碰不到，多么可惜啊… 学习资源不知如何入门，在B站偶然发现Andrew Ng 的机器学习教程，争取可以坚持学完。第一天入门，主要学习以下内容: 1、1 - 1 - Welcome to Machine Learning【中英】 2、1 - 2 - Welcome【中英】 3、1 - 3 - What is Machine Learning【中英】 4、1 - 4 - Supervised Learning 【中英】 5、1 - 5 - Unsupervised Learning 【中文】 学习内容这几节主要其实主要是讲了机器学习的概念机器学习可以按照如下分类： 监督学习 无监督学习 监督学习主要分为两大问题：分类问题 和 回归问题。 分类问题预期的是有限个数的离散输出结果，典型的例子：根据已有的肿瘤大小与肿瘤恶性还是良性的数据，预测肿瘤是良性还是恶性的。 回归问题预期的是连续的输出结果，典型的例子：根据已有的房价与房屋面积的数据，已知房屋面积预测房屋价格。 无监督学习典型的算法有聚类算法： eg1: social network analysis 根据好友的互动数据，自动分组人群 eg2: market segmentation 根据客户数据，自动分类细分市场 使用工具的最佳建议学习机器学习，如果使用c++或java语言开发，代码会非常多，且需要链接到各种库去处理特殊功能。机器学习的研究者通常的做法是，先使用octave或Matlab语言实现好原型，在用其他的语言进一步开发。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Quick Start]]></title>
    <url>%2F2017%2F07%2F29%2FHexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" Create a new draft1$ hexo new "My new draft" Publish draft1$ hexo publish [layout] &lt;filename&gt; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog 写作 教程</category>
        <category>Hexo 教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
