<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Fuchsia模块化的四大组件之二]]></title>
    <url>%2F2019%2F12%2F05%2Fos%2Fmodular%20component2%2F</url>
    <content type="text"><![CDATA[参考前文：Fuchsia模块化Fuchsia模块化的四大组件之一 在前文对于Fuchsia模块化的介绍中提到，用户可以通过开发module、agent、entryprovider类别的组件来实现具体的业务逻辑，扩展系统的能力。这三大组件再结合由module组合而成的story，可以称之为是fuchsia系统内的四大组件。本文依次介绍这几种组件都是些什么。 AgentAgent组件运行于Story组件之外，agent没有UI界面。通常在单一的会话中，agent组件是单例的。Agent组件通常用来组织执行任务，可以将自己注册到系统框架中，在有需要时，框架可以唤起agent并执行任务。Agent用来向其他组件提供服务，其他组件（module、shell 或者是其他agent)可以连接到agent上，获取agent所提供的服务。 环境Agent可以访问模块化组件提供的如下两项服务： fuchsia.modular.ComponentContext 用来获取组件化架构中各组件提供的服务 fuchsia.modular.AgentContext 用来执行agent的特有功能，例如创建实体引用、调度任务等。 Agent通常需要向组件化框架提供如下两种服务： fuchsia.modular.Agent 使用该服务框架可以转发其他组件的请求给该agent，agent收到请求后运行任务。 fuchsia.modular.Lifecycle 用来接收框架的生命周期的管理信号 上述的几个服务在agent和框架之间建立了通信的通道，同时agent也可以向其他组件提供自定义的FIDL接口。 生命周期管理对于大多数agent，当其与框架建立连接时，框架将会分配AgentController给它。而当AgeentController与框架的连接断开且当前没有正在执行的任务时，agent将被框架终止。Agent的AgentController可以由session mgr进行管理，在session的活跃期间，agent也将处于活跃状态。 通信机制组件与agent通信，有两种方式：自定义fidl服务 或者 消息队列。采取哪种方式，取决于具体的使用情况，FIDL的方式要求客户端和服务端同时存活，而消息对列的方式，消息的发送者和接收者可以有不同的声明周期。 FIDL服务客户端通过调用fuchsia::modular::Agent.Connect向模块化框架中的fuchsia.sys.ServiceProvider请求agent服务，调用成功将返回给调用者所请求的agent的唯一标识。任何添加到ServiceProvider中的service都可以通过Connect调用被获取。当一个module在它的ComponetContext上调用ConnectToAgent，模块化框架将进行两步操作，一方面返回一个AgentController对象，用来控制被连接的agent的生命周期，直到调用AgentController的close方法，该agent将持续存活。当有多个客户端连接到该agent时，直到最后一个AgentController的close被调用，该Agent才会被框架所终止；另一方面框架通过ServiceProvider转发连接请求给正确的agent，并传递给agent一个唯一标识客户端的字符串。 消息队列通过消息队列发送的消息的方式，使得Module与Agent的生命周期分离，Agent向Module提供一个消息队列，Module可向该队列发送消息，而Agent监听该队列，当有消息到来时进行处理。 Entity Provider在之前的文章中曾经介绍过Entity，请参考Fuchsia：万物皆实体 Entity Provider实际上是个概念上的组件，Module、Agent等能对外提供Entity引用的组件皆可认为是一个组件的提供者。 何谓实体从概念上将，实体就是一坨数据，有固定的类型。Agent可以创建实体并且在Module或者其他Agent间传递实体，该实体是属于创建它的Agent的，此Agent需要在其他组件访问该实体时向该实体填充数据。实体是组件间传递结构化的语义数据的主要机制。举个例子，Google联系人Agent，可以创建com.fuchsia.Contact类型的实体对象用来表示一个联系人实体，联系人实体可以提供给需要联系人实体的组件使用，当其他组件需要一个联系人实体时，模块化组件调起Google联系人Agent，agent为其提供实体的应用及实体内部中的数据。 Agent如何产生实体Agent通过调用如下方法产生实体 1AgentContext.GetReferenceFactory().CreateReference(cookie) 其中的参数cookie用来标识一个实体对象。例如：cookie可以是字符串”joe@domain.com“，这个cookie可以用来标识一个名字叫joe的Contact类型的实体。当此方法被调用，将会返回一个实体应用的标识字符串。通过这个引用可以获取到实体中存储的数据，实体的应用可以被存储在磁盘上、ledger中，也可以在组件间传递。因为实体引用可以被存储在ledger中，意味着实体可以跨设备使用，可以在另外的设备上对该引用进行解引用，从而获取实体中存储的数据。如下为创建一个实体的代码 123456789auto component_context = sys::ComponentContext::Create();auto agent_ctx = component_context-&gt;svc() -&gt;Connect&lt;fuchsia::modular::AgentContext&gt;();fuchsia::modular::EntityReferenceFactory factory;agent_ctx-&gt;GetEntityReferenceFactory(factory.NewRequest());factory-&gt;CreateReference("iamaperson@google.com", [] (std::string entity_reference) &#123; // Pass the |entity_reference| to a Module or Agent for consumption.&#125;); Module如何产生实体Module产生的实体的声明周期只存在于Module存活期间，当组合该Module的Story被删除后，Story中的Module所制造的实体引用将全部失效。Moulde通过调用ModuleContext.CreateEntity()创建实体对象，该调用需要提供实体的类型和实体的数据。示例如下： 12345678910auto component_context = sys::ComponentContext::Create();auto module_ctx = component_context-&gt;svc() -&gt;Connect&lt;fuchsia::modular::ModuleContext&gt;();fuchsia::mem::Buffer data;fsl::StringFromVmo("iamaperson@google.com", &amp;data);module_ctx-&gt;CreateEntity("com.fuchsia.Contact", std::move(data).ToTransport(), entity.NewRequest(), [] (std::string entity_reference) &#123; // Pass the |entity_reference| to a Module or Agent for consumption.&#125;); Agent或者Module如何从实体中取得数据组件从实体中获取数据分两步，第一步将一个实体应用解析为一个实体接口，第二部通过此实体接口获得该实体的类型及数据。实体引用的解引用，如下 1ComponentContext.GetEntityResolver().ResolveEntity(reference) 然后通过如下两个方法获取实体类型及数据 12Entity.GetTypes()Entity.GetData(typename) 完整实例如下： 123456789101112auto component_context = sys::ComponentContext::Create();auto component_ctx = component_context-&gt;svc() -&gt;Connect&lt;fuchsia::modular::ComponentContext&gt;();fuchsia::modular::EntityResolverPtr resolver;fuchsia::modular::EntityPtr entity;component_ctx-&gt;GetEntityResolver(resolver.NewRequest());resolver-&gt;ResolveEntity(entity_reference, entity.NewRequest());entity-&gt;GetData("com.fuchsia.Contact", [] (fuchsia::mem::BufferPtr data) &#123; // ...&#125;); Agent如何为实体提供数据Agent通过实现EntityProvider接口并导出给矿浆的方式来为实体提供数据。当组件调用Entity.GetData(type)时，框架首先唤起创建该实体引用的Agent，然后调用该Agent实现了的EntityProvider.GetData(cookie, type)方法，在此方法中即可实现数据的提供逻辑。如此看来，也可将Entity Proider可以看做是实现了EntityProvider接口的组件。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia模块化的四大组件之一]]></title>
    <url>%2F2019%2F11%2F28%2Fos%2Fmodular%20component%2F</url>
    <content type="text"><![CDATA[在前文对于Fuchsia模块化的介绍中提到，用户可以通过开发module、agent、entryprovider类别的组件来实现具体的业务逻辑，扩展系统的能力。这三大组件再结合由module组合而成的story，可以称之为是fuchsia系统内的四大组件。本文依次介绍这几种组件都是些什么。 StoryStory实际上是一个逻辑上的概念，存在于运行的过程中，可以理解成是一系列Module的组合。Story本身及其所处的状态可以被存储在fuchsia的分布式存储系统Ledger中以方便在不同的设备间共享。 实现方式模块化框架使用fuchsia.modular.StoryShelll来显示Story的UI，可以认为StoryShell是Story的容身之所，为Story的运行提供一个运行所需的环境。类似的Fuchsia系统还有另外一个概念叫Runner，可以认为是组件Component运行的容身之所，为Component的运行提供执行的环境。 生命周期Story可以被创建、删除、开始和停止。创建和删除将影响Story在Ledger中是否存储。开始和停止将决定Story及其中的Module是否运行。 ModuleModule是一个用于显示UI的组件，通过作为story的组成部分来运行。多个Module可以被组合为一个Story，Module也可以再添加其他的Module到自己所在的Stroy中。Module中可以嵌套其他的Module，也可以集成到StoryShell中。 环境Module可以读取模块化框架提供给该module所在命名空间的两种服务： fuchsia.modular.ComponentContext 用来获取在组件（例如： module、agent、shell等）间共享的功能。 fuchsia.modular.ModuleContext 用来执行Module管理相关的功能，例如创建Entity或者添加Module到当前Storyshell中等。 一个Module通常需要对外提供如下的三种服务： fuchsia.ui.app.ViewProvider 用来显示Module的UI fuchsia.modular.Lifecycle 用来接受模块化框架发送的的信号来管理Module的生命周期 fuchsia.modular.IntentHandler 用来处理来自于模块化框架发来的Intent 生命周期Module的生命周期依赖于它所在的Story。同一个Module在Story中可以创建多个实例。当一个模块启动另一个模块时，会得到后一个模块的模块控制器，可以通过该控制器来控制被启动模块的生命周期。 通信机制Module之间通过intent 和 entity 进行通信。Module和Agent之间则使用FIDL 和 消息队列进行通信。 Module的声明Module通过在Component manifest中的module facet部分来描述Module在运行期所具备的能力。 Componet facet是Componet清单文件中的一块区域，在该区域中所做的配置不会被Componet Manager关心。组件化框架定义了fuchsia.module 这一facet。在这一facet中Module的作者可以指定Module特有的属性。 下面的示例是component清单文件中对于module facet部分的定义 1234567891011121314151617181920212223242526272829&#123; &quot;facets&quot;: &#123; &quot;fuchsia.module&quot;: &#123; //版本说明 &quot;@version&quot;: 2, // 当向用户推荐该Module时展示的该Module的人性化的说明 &quot;suggestion_headline&quot;: &quot;See details about person&quot;, // 定义一系列该Module可以处理的Action，当有多个Module被匹配时，将提 // 供Module列表供选择 &quot;intent_filters&quot;: [ &#123; // 表示一个该module可以处理的功能 &quot;action&quot;: &quot;com.google.fuchsia.preview.v1&quot;, // action 携带的参数 &quot;parameters&quot;: [ &#123; &quot;name&quot;: &quot;entityToPreview&quot;, &quot;type&quot;: &quot;https://fuchsia.com/types/Friend&quot; &#125; ] &#125; ], //用来说明该Module在Story中的组合方式 //取值：ticker 该module将显示在其他Module下面 //取值：comments-right 该module将显示在其他Module的下面 &quot;composition_pattern&quot;: &quot;ticker&quot; &#125; &#125;&#125; 该示例中的module可被action com.google.fuchsia.preview.v1调起，并传递类型为https://fuchsia.com/types/Friend的参数entityToPreview。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia模块化介绍]]></title>
    <url>%2F2019%2F11%2F20%2Fos%2Fmodular%2F</url>
    <content type="text"><![CDATA[Fuchisa的应用程序及应用程序框架是一个模块化的框架。Fuchsia系统中的组件包含着UI、数据、用户等内容，模块化框架将这些组合在一个逻辑概念上的可视化的被叫做story的容器中。从而实现对用户体验的统一管理。 组件化框架提供了各类扩展用户体验的组件，并为组件组成、如何通信、任务代理、状态管理、数据规范等制定了实现规范。 模块化框架如何使用模块化框架允许使用任何开发语言开发模块组件，例如：c++、flutter等，只要开发的模块作为fuchsia的组件可以在fuchsia系统中包含的runtime运行即可。模块化框架和它启动的组件之间通过FIDL进行通信，FIDL是Fuchisa上标准的IPC机制。 扩展点框架提供了几个不同的组件类型，开发者可以实现这些类型的组件来扩展用户体验： Modules 用来显示UI，可以组合进Story中作为可视化部分的组件 Agents 运行在后台，用来向其他代理和模块提供服务或数据的组件 Shells 用来管理系统UI和用户交互的组件 EntityProviders 数据对象（Entity）的提供者组件，通过EntityProviders，数据对象（Entity）将在以模块化运行的组件间进行共享。 basemgr 和 sessionmgr当fuchsia启动后，basemgr进程和sessionmgr进程将会被启动，这两个进程负责提供会话管理、组件声明周期管理和状态管理。 basemgr 负责用户认证和授权，它利用系统UI来呈现相关的UI。 sessionmgr 负责管理Story、Modules、Agents的声明周期，以及他们之间的服务调用和状态同步。它使用session、story容器来组合和管理Story、Module、Agent等组件。 如上，仅对模块化框架中出现的一些概念简要介绍下，后续将依次介绍模块化的各类型组件，及这些组件是如何组合为story，及如何被管理的。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Component 能力介绍]]></title>
    <url>%2F2019%2F11%2F12%2Fos%2Fcomponent%20capabilities%2F</url>
    <content type="text"><![CDATA[Capabilities 理解为能力、功能，就是赋予一个组件能够连接和读取其他组件提供的能力的权限。fuchsia 中组件的能力，有三种，分别是： Directory 能力 Service 能力 Storage 能力 Directory 能力Directory能力允许组件连接到其他组件提供的目录。 创建Directory能力当一个组件想让它的一个目录对其他组件可用时，可以使用以下两种方式之一导出目录的路径：方法一：使用expose关键字，将目录公开到包含域 123456&#123; &quot;expose: [&#123; &quot;directory&quot;: &quot;/data&quot;, &quot;from&quot;: &quot;self&quot;, &#125;],&#125; 方法二：使用offer关键字，将目录提供给组件的子目录 12345678910&#123; &quot;offer: [&#123; &quot;directory&quot;: &quot;/data&quot;, &quot;from&quot;: &quot;self&quot;, &quot;to&quot;: [&#123; &#123; &quot;dest&quot;: &quot;#child-a&quot; &#125;, &#123; &quot;dest&quot;: &quot;#child-b&quot; &#125;, &#125;], &#125;],&#125; 使用Directory能力如果组件想使用自己所在包含域内的目录，需要使用use关键字来使用目录，组件框架会连接组件到提供该目录的组件，这样组件再运行时就可以访问该目录了。示例如下： 12345&#123; &quot;use&quot;: [&#123; &quot;directory&quot;: &quot;/data&quot;, &#125;],&#125; 组件框架提供的Directory能力组件框架提供了一些预先定义好的Directory能力，在申请使用这些目录时同样使用use关键字，只是需要增加from字段，并且字段值为framework，来表明该目录来自于framework。 123456&#123; &quot;use&quot;: [&#123; &quot;directory&quot;: &quot;/hub&quot;, &quot;from&quot;: &quot;framework&quot;, &#125;],&#125; Dierctory的路径别名在使用关键字expose、offer向外提供目录能力、使用use请求目录能力时，可以使用as 关键字来为目录的引用路径起别名。在如下的实例中，有A、B、C三个组件如下： 12345A &lt;- offers directory &quot;/data&quot; from &quot;self&quot; to B as &quot;/intermediary&quot;|B &lt;- offers directory &quot;/intermediary&quot; from &quot;realm&quot; to B as &quot;/intermediary2&quot;|C &lt;- uses directory &quot;/intermediary2&quot; as &quot;/config&quot; 写清单文件时，则写为如下形式：A.cml 12345678910111213&#123; &quot;offer: [&#123; &quot;directory&quot;: &quot;/data&quot;, &quot;from&quot;: &quot;self&quot;, &quot;to&quot;: [&#123; &#123; &quot;dest&quot;: &quot;#B&quot;, &quot;as&quot;: &quot;/intermediary&quot; &#125;, &#125;], &#125;], &quot;children&quot;: [&#123; &quot;name&quot;: &quot;B&quot;, &quot;url&quot;: &quot;fuchsia-pkg://fuchsia.com/B#meta/B.cm&quot;, &#125;],&#125; B.cml 12345678910111213&#123; &quot;offer: [&#123; &quot;directory&quot;: &quot;/intermediary&quot;, &quot;from&quot;: &quot;self&quot;, &quot;to&quot;: [&#123; &#123; &quot;dest&quot;: &quot;#C&quot;, &quot;as&quot;: &quot;/intermediary2&quot; &#125;, &#125;], &#125;], &quot;children&quot;: [&#123; &quot;name&quot;: &quot;C&quot;, &quot;url&quot;: &quot;fuchsia-pkg://fuchsia.com/C#meta/C.cm&quot;, &#125;],&#125; C.cml 123456&#123; &quot;use&quot;: [&#123; &quot;directory&quot;: &quot;/intermediary2&quot;, &quot;as&quot;: &quot;/config&quot;, &#125;],&#125; Service 能力Service 服务，允许组件通过FIDL定义的接口，调用其他组件或者框架提供的服务。 Service 能力的创建当组件expose或者offer一个服务时，会将此服务导出给该组件的父组件expose的方式 123456&#123; &quot;expose&quot;: [&#123; &quot;service&quot;: &quot;/svc/fuchsia.example.ExampleService&quot;, &quot;from&quot;: &quot;self&quot;, &#125;],&#125; 像其子组件提供服务 12345678910&#123; &quot;offer&quot;: [&#123; &quot;service&quot;: &quot;/svc/fuchsia.example.ExampleService&quot;, &quot;from&quot;: &quot;self&quot;, &quot;to&quot;: [&#123; &#123; &quot;dest&quot;: &quot;#child-a&quot; &#125;, &#123; &quot;dest&quot;: &quot;#child-b&quot; &#125;, &#125;], &#125;],&#125; 使用service能力可使用use关键字获取在当前组件所在的包含域内的服务。组件框架将根据该定义为组件查找到提供此服务的组件，并在组件间简历通道。 12345&#123; &quot;use&quot;: [&#123; &quot;service&quot;: &quot;/svc/fuchsia.example.ExampleService&quot;, &#125;],&#125; 使用组件框架提供的服务fuchsia的组件框架提供了一些服务，供任意组件调用，使用组件框架提供的服务，使用use关键子申明，并且来源标记为framework即可。 123456&#123; &quot;use&quot;: [&#123; &quot;service&quot;: &quot;/svc/fuchsia.sys2.Realm&quot;, &quot;from&quot;: &quot;framework&quot;, &#125;],&#125; service别名同上directory能力的别名，使用as关键字定义，不再赘述。 Sotrage 能力Storage能力和Directory非常相似，但是也有不同。存储功能所提供的目录对于组件来说是唯一，不重叠的，每个组件有自己的区别于其他组件的存储目录。 Directory 和 Storage的比较例如，如果组件实例a从其领域得到访问一个目录的能力，然后又将该能力提供给b，则两个组件实例都可以看到同一个目录并与之交互。 12345678910111213141516171819202122&lt;a&apos;s realm&gt; | a | ba.cml:&#123; &quot;use&quot;: [ &#123;&quot;directory&quot;: &quot;/example_dir&quot; &#125; ], &quot;offer&quot;: [ &#123; &quot;directory&quot;: &quot;/example_dir&quot;, &quot;from&quot;: &quot;realm&quot;, &quot;to&quot;: [ &#123; &quot;dest&quot;: &quot;#b&quot; &#125; ], &#125;, ],&#125;b.cml:&#123; &quot;use&quot;: [ &#123;&quot;directory&quot;: &quot;/example_dir&quot; &#125; ],&#125; 如果组件a在目录 example_dir内创建了一个文件，则b组件是可以看到并且读取该文件的。而如果使用的是storage能力，例如： 12345678910111213141516171819202122&lt;a&apos;s realm&gt; | a | ba.cml:&#123; &quot;use&quot;: [ &#123; &quot;storage&quot;: &quot;data&quot;, &quot;as&quot;: &quot;/example_dir&quot; &#125; ], &quot;offer&quot;: [ &#123; &quot;storage&quot;: &quot;data&quot;, &quot;from&quot;: &quot;realm&quot;, &quot;to&quot;: [ &#123; &quot;dest&quot;: &quot;#b&quot; &#125; ], &#125;, ],&#125;b.cml:&#123; &quot;use&quot;: [ &#123; &quot;storage&quot;: &quot;data&quot;, &quot;as&quot;: &quot;/example_dir&quot; &#125; ],&#125; 则b组件是看不到a组件创建的文件的。b组件看到的example_dir目录和a组件看到的example_dir目录是各自独立的，不重叠的。直接使用directory能力是应当小心谨慎，因为每个拥有该目录访问能力的组件都可访问该目录。而基于该目录的storage能力，将会为每个访问该storage的组件创建子目录，这样各组件就可以放心使用该目录，而不用担心冲突问题。这也意味着在定义子组件时，使用不同的名字，将会为子组件分配到不同的sotrage的子目录。 创建Storage 能力使用storage关键字可以创建storage能力，storage能力创建后，别的组件可以通过能力名称来引用该能力。创建storage能力时，必须从directory能力创建，组件框架将从该目录为storage能力创建组件唯一的storage能力。 1234567891011121314151617181920&#123; &quot;storage&quot;: [ &#123; &quot;name&quot;: &quot;mystorage&quot;, &quot;from&quot;: &quot;#memfs&quot;, &quot;path&quot;: &quot;/memfs&quot;, &#125;, ], &quot;offer&quot;: [ &#123; &quot;storage&quot;: &quot;data&quot;, &quot;from&quot;: &quot;#mystorage&quot;, &quot;to&quot;: [ &#123; &quot;dest&quot;: &quot;#storage_user&quot; &#125; ], &#125;, ], &quot;children&quot;: [ &#123; &quot;name&quot;: &quot;memfs&quot;, &quot;url&quot;: &quot;fuchsia-pkg://...&quot; &#125;, &#123; &quot;name&quot;: &quot;storage_user&quot;, &quot;url&quot;: &quot;fuchsia-pkg://...&quot;, &#125;, ],&#125; 上例中，将使用子组件memfs提供的目录/memfs作为storage的目录创建storatge能力，能力的名称为mystorage, 并以mystorage为基础创建了storage能力data提供给了storage_user组件使用。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Component manifests介绍]]></title>
    <url>%2F2019%2F11%2F05%2Fos%2Fcomponent%20manifest%2F</url>
    <content type="text"><![CDATA[清单文件是用来描述组件的一个描述文件，扩展名为.cmx。通常位于工程的meta目录下。描述一个组件通常包含如下几部分： 关于如何运行组件的信息 子组件实例和组件集合的描述 描述如何在组件之间使用、发布和提供功能的路由规则。 自由形式的数据（“facets”）被组件框架忽略，但可以由第三方解释（类似android清单文件中的meta-data 数据）。 组件清单文件和组件声明这里由几个比较容易混淆的概念 component manifest、component manifest source 和 component declarations。component manifest组件清单，组件清单是对组件描述的编码实现，可以理解为组件描述通过对清单文件的编译而来。通常作为包的一部分随包一起发布，它和组件是一一对应的关系。扩展名为.cm是一个json文件。带有清单文件信息的的fuchsia-pkg URL用来唯一标识一个包里的组件。component manifest source组件清单文件的源文件。组件清单源文件使用CML(component manifest language)语言编写。后缀名为.cml，也是json格式的文件。使用cmc工具可将清单源文件编译为清单文件。cmc 为清单源文件编译工具，在fuchsia编译后会生成，生成的位置为：./out/default/host_x64/cmc使用方法如下：12345678910111213141516171819» ./out/default/host_x64/cmc help zhaojie@zhaojie-PCUSAGE: cmc [OPTIONS] &lt;SUBCOMMAND&gt;FLAGS: -h, --help Prints help information -V, --version Prints version informationOPTIONS: -s, --stamp &lt;stamp&gt; Stamp this file on successSUBCOMMANDS: compile compile a CML file format format a json file help Prints this message or the help of the given subcommand(s) merge merge the listed cmx files validate validate that one or more cmx files are valid component declarations清单文件会转换为ComponentDecl table对象，这是FIDL语言定义的一个数据结构。该数据结构在fuchsia的组件框架中代表一个具体的组件，在运行时，组件框架的api读取该数据向其他组件提供该组件的能力。 涉及到的一些概念先看一个两段清单文件的内容，有个大致的认识。示例如下： 12345678910111213// Component manifest for the `echo_client` example program, which sends a message to the Echo// service.&#123; &quot;program&quot;: &#123; &quot;binary&quot;: &quot;bin/echo_client&quot;, &quot;args&quot;: [&quot;Hippos&quot;, &quot;rule!&quot;], &#125;, &quot;use&quot;: [ &#123; &quot;legacy_service&quot;: &quot;/svc/fidl.examples.routing.echo.Echo&quot;, &#125;, ],&#125; 和 1234567891011121314151617// Component manifest for the `echo_server` example program, which hosts the Echo service used// by `echo_client`.&#123; &quot;program&quot;: &#123; &quot;binary&quot;: &quot;bin/echo_server&quot;, &#125;, &quot;expose&quot;: [ &#123; &quot;legacy_service&quot;: &quot;/svc/fidl.examples.routing.echo.Echo&quot;, &quot;from&quot;: &quot;self&quot;, &#125;, &#123; &quot;directory&quot;: &quot;/hub&quot;, &quot;from&quot;: &quot;framework&quot;, &#125;, ],&#125; 运行时字段【program】用来描述组件是如何运行的。对于包含elf格式的二进制可执行文件的组件，该字段的值为指向包中二进制文件的路径，同时可选的也可以携带传递给该二进制文件的参数。如何一个组件中不包含可执行文件，此字段可以省略。 能力路由组件清单中提供相应的语法用来描述能力是如何在组件之间进行路由的。如下的几类能力可在组件间进行传递路由： service：一种文件系统服务节点，通过该节点可以打开和使用服务提供者提供的服务。类似服务的客户端代理。 directory：文件系统中的目录 storge：与使用它的组件相隔离的文件系统目录。 使用下面几个关键字可对能力的路由进行定义： use 当一个组件使用某种能力时，该能力将被引入到组件的命名空间内，组件可以使用任意赋予给它的能力。 offer 一个组件可以将它的能力提供给它的子组件或者组件集合使用，获得该能力的组件也可以将能力再次提供出去。 expose 组件可以使用该关键字将自己的组件暴露出去，这样该组件的父组件就可以将该能力提供给该组件在同一颗树上的其他组件节点。 清单文件的语法清单文件由各段组成 programprogram 段由组件将执行的可执行文件决定，如果组件不包含可执行文件，该段可省略。如果组件使用elf runner执行，则program段包含两个属性： binary: 与包关联的可执行文件的路径， args(可选)：二进制文件执行的参数字符串数组。 1234&quot;program&quot;: &#123; &quot;binary&quot;: &quot;bin/hippo&quot;, &quot;args&quot;: [ &quot;Hello&quot;, &quot;hippos!&quot; ],&#125;, childrenchildren 段用来定义子组件实例，是一个描述子组件的数组。childer包含如下属性： name: 子组件实例的名字 url： 子组件实例的URL startup: 组件实例的启动方式 lazy(默认)：只有当由其他组件绑定它时它才启动 eager：父组件启动即启动子组件 1234567891011&quot;children&quot;: [ &#123; &quot;name&quot;: &quot;logger&quot;, &quot;url&quot;: &quot;fuchsia-pkg://fuchsia.com/logger#logger.cm&quot;, &#125;, &#123; &quot;name&quot;: &quot;pkg_cache&quot;, &quot;url&quot;: &quot;fuchsia-pkg://fuchsia.com/pkg_cache#meta/pkg_cache.cm&quot;, &quot;startup&quot;: &quot;eager&quot;, &#125;,], useuse 段用来描述组件将使用哪些能力，use的内容是包含如下属性的对象数组。 能力的定义：关键字分别为service/directory/storage as: 类似能力路径的别名 12345678910111213&quot;use&quot;: [ &#123; &quot;service&quot;: &quot;/svc/fuchsia.logger.LogSink&quot;, &#125;, &#123; &quot;directory&quot;: &quot;/data/themes&quot;, &quot;as&quot;: &quot;/themes&quot;, &#125;, &#123; &quot;storage&quot;: &quot;data&quot;, &quot;as&quot;: &quot;/my_data&quot;, &#125;,], exposeexpose 用于定义组件暴露的能力，属性如下： 能力定义 from：用来说明能力的来源，取值如下： self：当前组件 #：子组件实例的引用 as 1234567891011&quot;expose&quot;: [ &#123; &quot;directory&quot;: &quot;/data/themes&quot;, &quot;from&quot;: &quot;self&quot;, &#125;, &#123; &quot;service&quot;: &quot;/svc/pkg_cache&quot;, &quot;from&quot;: &quot;#pkg_cache&quot;, &quot;as&quot;: &quot;/svc/fuchsia.pkg.PackageCache&quot;, &#125;,], offeroffer 用来定义该组件为子组件提供能力的描述，属性： 能力的定义 from 能力的来源，取值为： self 当前组件 realm 组件所在域 # 子组件实例的名字 # 一个storage定义的引用 to 被赋予能力的目标组件1234567891011121314151617181920212223&quot;offer&quot;: [ &#123; &quot;service&quot;: &quot;/svc/fuchsia.logger.LogSink&quot;, &quot;from&quot;: &quot;#logger&quot;, &quot;to&quot;: [ &quot;#fshost&quot;, &quot;#pkg_cache&quot; ], &#125;, &#123; &quot;directory&quot;: &quot;/data/blobfs&quot;, &quot;from&quot;: &quot;self&quot;, &quot;to&quot;: [ &quot;#pkg_cache&quot; ], &quot;as&quot;: &quot;/blobfs&quot;, &#125;, &#123; &quot;directory&quot;: &quot;/data&quot;, &quot;from&quot;: &quot;realm&quot;, &quot;to&quot;: [ &quot;#fshost&quot; ], &#125;, &#123; &quot;storage&quot;: &quot;meta&quot;, &quot;from&quot;: &quot;realm&quot;, &quot;to&quot;: [ &quot;#logger&quot; ], &#125;,], facetsfacets 段中可定义第三方自行解析的json格式的内容，用于自定义组件的属性。 总体来讲，组件清单就是用来描述组件的基本构成，运行方式，以及能力获取提供的文件。在组件框架中用来代表一个组件。fuchsia的组件清单文件是一种类似于乐高积木的组合方式，提供的描述组件组合的方式并不多，但是这种方式，更强的限制了组件能力调用的权限。本文只是形式上对清单文件进行了描述，深层次的理解，还得后续深入。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchisa Component介绍]]></title>
    <url>%2F2019%2F10%2F28%2Fos%2Fcomponent%2F</url>
    <content type="text"><![CDATA[在Fuchsia系统中，Component是最基本的执行单元，他们对外提供能力也消费其他组件的能力。 Component 和 Component Framework在Ｆuchsia系统中，Component是运行于自己沙箱中的程序，他通过跨进程通信（FIDL）来与其他的Component的方式进行交互。ComponentFramework是Fuchsia系统中面向组件的开发框架，组件框架负责运行几乎所有的软件。 组件化框架的优势组件化框架关注与功能的分离，它帮助开发人员开发简单的组件，然后再使用这些简单的组件组合成负责的系统。每个组件只负责实现单一的功能。例如网卡驱动组件只向外暴露收发网络帧的硬件服务接口。这些组件都遵循一套共同的协议，而无需关心这些组件是否来自于不同的开发商或者使用不同的开发语言开发。软件组合具有的优点如下： 可配置性：系统可以通过增加、删除、升级、替换不同的组件而改变行为。 可扩展性：当增加一个组件时，系统的功能得到增长。 可靠性：系统可以独立关闭或者重启故障组件。 复用性：特定的组件可以通过组合来解决新问题。 可测试性：组件可以进行单独测试和bug修改。 一致性：组件使用相同的描述方式描述自己所能提供的能力。 Fuchsia使用组件化技术来构造整个具有组合能力的软件新系统，组件框架有利于新软件的发布和更新。 一切皆组件组件无处不在，他们以相同的机制运行并无缝衔接，在Fuchsia系统中几乎一切程序都是以组件的形式存在的： 命令行工具 设备驱动 用户应用 文件系统 多媒体编解码器 网络协议栈 测试程序 网页 但是有几个例外： bootloaders 设备固件 kernels 组件Manager自己的引导程序 虚拟访客操作系统 组件的独立性首先，组件是一个程序： 它是软件的执行单元 它使用一个唯一的URL进行标识，通过此URL可以查询并实例化组件 组件可以使用任何的编程语言实现，只要由合适的组件runner（类似运行环境，后文有描述）存在 它有一份声明用来描述它可以做什么和自己使用它的能力 然后，组件是一个独立的程序： 每一个组件的实例都运行在自己的独立沙箱中。 依据最小特权原则，组件被分配受限的权限以完成它的功能。 组件不可以读取未被授权的其他组件 组件的生命周期和状态独立于其他组件 它主要通过IPC的方式与其他组件交互 组件的错误和故障不会影响到整个系统的稳定。 其次，组件是一个可组合的程序： 组件可以组合其他的组件从而形成复杂的组件 组件可以通过静态或者动态的方式，使用其他组件的URL获得其他组件的实例作为当前组件的子组件。 它可以使用功能路由将自己的能力授权给自己的子组件。 最终，组件是一个封闭的可以组合独立程序： 组件有自己的封闭边界。 组件可以在不影响调用者的情况下，改变自己的实现。 组件以包含一切组件运行时所需的信息（包含共享库）的方式进行发布。 ComponentManager 及其启动ComponentManager是Fuchsia组件框架的核心，它负责管理各组件的生命周期，对各组件进行授权管理和保持各组件的独立运行。系统在启动的早期就启动组件管理器，然后组件管理器首先启动根组件，然后根组件像组件管理器发出请求，然后启动设备管理、文件系统、网络协议栈及其他必要的服务。随着越来越多的组件启动，整个Fuchsia恢复生机，最终通过session framework启动用户交互，然后用户就可以控制系统了。 sequenceDiagram participant BootProcess participant ComponentManager participant RootComponent participant OtherComponent participant SessionFramework BootProcess->>ComponentManager: 启动 ComponentManager->>RootComponent: 启动 RootComponent->>ComponentManager: 请求启动核心Component ComponentManager->>OtherComponent: 启动设备管理、文件系统等 BootProcess->>SessionFramework: 启动UI 组件实例组件的实例是一个组件运行时的副本，不同的组件实例之间互不影响，状态等也互不干扰。推断一个组件可以由多个组件实例，且他们之间互无关系。 组件实例的生命周期组件的实体有几个主要的生命周期事件：create、start、stop和destory。不同于进程，组件实例在不运行时依然存在，所以一个组件的实例可以被重复的启动和停止。 create当一个组件被创建时，ComponentManager将为它分配一个唯一标识符，并将它存储在ComponentManager的数据结构中，并使其功能可供其他组件使用。一旦创建，组件实例可被启动和销毁。 start启动组件实例，组件中的代码将得到执行并且可以调用被赋予的其他组件中的能力。每一个组件的运行都有其理由，ComponentManager只启动那些正的有事要做的组件，比方说有其他组件要调用该组件的能力。 stop停止一个组件将停止该组件的程序运行，但是会保存组件运行到的状态，以便在下次运行时能够恢复组件的运行状态。ComponentManager可能由于以下的原因而停止一个组件： 所有的客户端断开了连接 其父组被停止 当组件的包被更新 当没有足够的资源运行该组件 虽然有资源，但是其他的组件优先级更高 组件被销毁 系统关机 组件可以实现一个生命周期Handler用来接收生命周期事件，但是在资源耗尽，崩溃和系统关机的情况下组件将收不到事件的通知。一旦停止，组件实例可以被重启或者销毁。 destory销毁组件实例将释放他所占有的所有资源以及清楚其所有所状态。一旦被释放，组件实例将不能再被重启，再次启动同一组件，得到的将是不同的组件实例。 组件声明一个组件的声明是给机器看的，它描述了该组件可以做什么和如何运行。它包含ComponentManager实例化组件实例和与其他组件组合时所需的元数据。每一个组件都有一份组件声明，对于在包中分发的组件，组件的声明通常采用组件清单文件的方式（Component manifest file）。组件也可以通过其他的方式发布，例如通过web application的方式发布，这是需要与之配套的解析器和运行器（runner)，它们需要提供组件运行必须的声明。例如，一个计算器组件声明可能包含如下信息： 计算器的程序在包中所在的位置 运行该组件的runner的名字 保存计算器计算中间结果的持久化请求 使用当前用户界面的请求 请求公开允许其他组件使用进程间通信访问计算器累加器寄存器的功能。 组件URL组件的URL指明了组件声明、组件的程序及资源所在的位置。可以使用不同的URL Scheme从不同的源检索组件，例如： fuchsia-boot 该组件是从系统启动img中解析的，用于在包系统可用之前检索在早期引导期间对系统操作至关重要的组件。 1eg: fuchsia-boot:///#meta/devcoordinator.cm fuchsia-pkg 组件由Fuchsia包解析器解析。此方案用于以包的形式分发的组件，包可以按需下载并保持最新。 1eg: fuchsia-pkg://fuchsia.com/netstack#meta/netstack.cm http/https 组件被web解析器解析为web应用程序。该方案用于将基于web的内容集成到组件框架中。 1eg: https://fuchsia.dev 组件的拓扑结构组件的拓扑结构是一个抽象的数据结构，用来描述组件实例之间的交互关系，它有三部分组成： 组件实例树：描述组件实例以什么关系组合起来（他们之间的父子关系） 能力路由图：描述组件实例如何获得对其他实例功能的访问权（他们之间的供销关系） 共享资源树：描述隔离在各自沙箱中的各组件对共享资源使用方式（他们的隔离关系） 组件拓扑结构对组件的生命周期和功能的使用有很大的影响。 层次结构通过层次结构，一些简单的组件可以组合在一起形成一个复杂的组件。在层次结构中父组件创建其他组件的实例作为其子组件，父组件为其子组件赋予访问父组件能力的权限，同时通过功能路由的方式访问子组件的能力。子组件可以通过如下两种方式被创建： 静态 父组件在自己的声明中声明子组件，子组件在父组件更新声明删除子组件后将会自动销毁。 动态 父组件使用领域（ComponentManager组件树的一个子树）服务创建子组件并加载到父组件定义的组件集合中，对子组件的管理使用同样的方法。 子组件永远依赖父组件；他们不能被重新分配，也不能比父组件长寿。当父组件被销毁时，所有的子组件也会被销毁。组件之间的拓扑关系代表了组件之间的父子关系，这种关系以组件实例树的形式存在。 封装子组件的能力不能直接对外提供，必须经由其父组件，这些功能是被封装的。这个特性类似于面向对象编程中的组合。 领域领域是由层次结构组成的组件实例的子树。每个领域都由一个组件实例根，并包含该实例的所有子实例及其子实例。领域是组件拓扑结构中重要的封装边界。每个领域的根都有某些特权来影响组件的行为，例如： 声明能力如何在领域内 流入、流出和在流动 绑定到子组件以访问其服务。 创建和销毁子组件。 能力路由组件可以通过功能路由访问其他组件公开的功能。 CompartmentsCompartments是组件实例运行的隔离边界。它是维护组件的机密性、完整性和可用性的重要机制。运行于不同物理硬件、不同job、不同runner的组件之间是互相隔离的。上述的三层隔离是互相嵌套的。runner 运行于 job（类似于进程）中，而job运行于物理硬件上。kernel负责对job的调度。 综上，组件是fuchsia运行程序的一个基本单位，在fuchsia分发pacakge时，一个包可以携带多个组件，组件有点类似于android 四大组件的感觉，但是感觉要更加独立，且还有自己的层级结构。运行时，组件的依赖需要依赖runner，在fuchsia的框架中，这个runner是可扩展的，这将极大的丰富fuchsia的生态。runner有点像解析器或者虚拟机的感觉。runner运行于job，job则类似于进程的概念，由kernel进行调度。Fuchsia出现的新概念太多，需要类比学习帮助理解，多有不当之处，欢迎大家讨论。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchisa之PackageManager]]></title>
    <url>%2F2019%2F10%2F21%2Fos%2Fpm%2F</url>
    <content type="text"><![CDATA[上周，在Fuchsia OS上运行了第一个demo——HelloWorld，了解到编译完成后，需要使用fx的命令将编译好的Fuchisa的应用包传送到系统中，从而得到运行。本周简单介绍下Fuchsia Package。 Fuchsia 系统内的包的管理和控制，通过PackageManager实现。pm 是一个控制台的工具，通过pm可以对包进行相关的操作。 pmpm 是package manager的命令行接口，主要提供如下功能： 演示和执行pmd(解释见下文)的 api 供开发人员使用的包相关的功能 打包 安装包 列出所有的包 移除包 包检验 向Amber提供包的摘要信息pm可以运行在多个操作系统上，但在没有pmd的系统上只支持一部分操作。 pmdpmd 是包管理的守护进程，它的职责是： 激活包（使包在本地可用） 为包提供服务服务包（提供对包的文件系统类型访问） 管理包（对不在使用的包进行垃圾回收） 枚举系统中的包，列出系统中可用的包。pmd 只运行在fuchisia上。 fuchsia包的结构fuchsia包是为fuchsia系统提供一个或多个程序、组件或服务的一个或多个文件集合。包由一组元数据定义，这些元数据存储在Fuchsia顶层的目录中，如下： 123meta/ package contents metadata元数据文件包含一组基本的系统、开发人员和用户友好的数据。例如，包括人名、唯一名称、版本、开发人员名称、开发人员公钥和说明。 contents内容文件包含整个包中所有文件的严格完整清单。这些名称兼作打包路径和运行时表示路径。这些路径都有一个作为merkle树节点的hash值。merkle树在zircon中有大量的使用，后续专门介绍一下。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchisa运行Hello,World]]></title>
    <url>%2F2019%2F10%2F14%2Fos%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[之前的几篇一直都在介绍Fuchsia的一些概念，本文将在Fuchsia上运行我们的第一个应用，通过该示例可以快速了解到Fuchsia的components是如何编译、运行及测试的。Hello Fuchsia，Hello World。 文件说明代码所在位置为fuchsia根目录/examples/hello_world，先来看下目录结构： Fuchsia的示例代码同时提供了c++ 和 rust 语言的示例，所以有两个语言的子目录 /cpp 和 /rust。这两个目录之外，一个是README.md文件，其中描述了该示例如何编译运行等一些说明。另一个文件就比较重要了，是BUILD.gn。fuchsia 使用 GN 编译，GN是一款构建系统，用于编译大规模代码生成ninjia文件。BUILD.gn 内容如下： 12345678910111213141516group(&quot;hello_world&quot;) &#123; testonly = true deps = [ &quot;:tests&quot;, &quot;cpp&quot;, &quot;rust&quot;, ]&#125;group(&quot;tests&quot;) &#123; testonly = true data_deps = [ &quot;cpp:tests&quot;, &quot;rust:tests&quot;, ]&#125; 在这个文件中使用group定义了一个target，名字为“hello_world”，group可以包含其他的依赖，此处包含了cpp 和 rust，使用该target将同时构建cpp和rust版的hello world程序。每一个依赖的子路径下，都有自己的BUILD.gn文件用来定义要构建出的包，同时每一个依赖的子路径下也包含一个meta目录，该目录中定义的.cmx 文件为包的清单文件。cpp目录下的Build.gn文件内容如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940import(&quot;//build/package.gni&quot;)//定义目标cpp，该目标被上级的BUILD.gn所依赖group(&quot;cpp&quot;) &#123; deps = [ &quot;:hello_world_cpp&quot;, ]&#125;//定义可执行的目标/bin/hello_world_cppexecutable(&quot;bin&quot;) &#123; output_name = &quot;hello_world_cpp&quot; //包含的源文件 sources = [ &quot;hello_world.cc&quot;, ]&#125;//定义fuchisa包：hello_world_cpppackage(&quot;hello_world_cpp&quot;) &#123; //依赖上面定义的executable bin deps = [ &quot;:bin&quot;, ] binaries = [ &#123; name = &quot;hello_world_cpp&quot; &#125;, ] //包含清单文件 meta = [ &#123; path = rebase_path(&quot;meta/hello_world_cpp.cmx&quot;) dest = &quot;hello_world_cpp.cmx&quot; &#125;, ]&#125; cpp/meta 目录下的 hello_world_cpp.cmx 内容如下，它是一个json格式的文件，它用来描述在Fuchsia系统中应用如何作为组件进行运行。 12345678910&#123; &quot;program&quot;: &#123; &quot;binary&quot;: &quot;bin/hello_world_cpp&quot; &#125;, &quot;sandbox&quot;: &#123; &quot;services&quot;: [ &quot;fuchsia.logger.LogSink&quot; ] &#125;&#125; build首先需要将hello_world包含进build，命令如下： 1fx set ... --with //examples/hello_world 此命令将包hello_world包含进fuchsia的universe中。对于应用包包含的位置可参考文章Fuchsia的fx命令后半部分的介绍。universe空间的含义为universe 中的包是附加可选包，这些包可以按需下载运行。它们不会运行打包到Paving image中。然后可以构建，命令如下： 1fx build 运行由于hello world包放到了universe中，所以需要一个更新服务给fuchsia系统安装包，所以启动服务 12345» fx serve+ exec /home/[username]/code/fuchsia/out/default/host_x64/bootserver --board_name pc --boot /home/[username]/code/fuchsia/out/default/fuchsia.zbi --bootloader /home/[username]/code/fuchsia/out/default/fuchsia.esp.blk --fvm /home/[username]/code/fuchsia/out/default/obj/build/images/fvm.sparse.blk --zircona /home/[username]/code/fuchsia/out/default/fuchsia.zbi --zirconr /home/[username]/code/fuchsia/out/default/zedboot.zbi --authorized-keys /home/[username]/code/fuchsia/.ssh/authorized_keys2019-10-14 14:49:09 [bootserver] Board name set to [pc]2019-10-14 14:49:09 [bootserver] listening on [::]:333312019-10-14 14:49:09 [serve-updates] Discovery... 服务启动后，会停止在Discovery，等待发现设备，我们使用qemu模拟器，所以运行模拟器 1fx run -N -u scripts/start-dhcp-server.sh -g fuchsia启动完成后，会看到qemu模拟器中启动四个终端并显示$符号。这时，serve的终端显示有设备上线了，显示如下： 1232019-10-14 15:14:44 [serve-updates] Device up2019-10-14 15:14:44 [serve-updates] Registering devhost as update source2019-10-14 15:14:59 [serve-updates] Ready to push packages! 此时准备工作就准备好了，开始向fuchis推送hello_world并运行。hello_world 的cpp版源文件为hello_world.cc，在此就可以进行其他熟悉的cpp开发了。 123456#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Hello, Fuchsia!\n&quot;; return 0;&#125; 开始运行编译好的hello_world 12» fx shell run fuchsia-pkg://fuchsia.com/hello_world_cpp#meta/hello_world_cpp.cmxHello, Fuchsia! 运行正确，输出期望的结果。此时也可以在模拟器fuchsia的终端下，或者使用fx shell登录到fuchsia的终端下，使用run命令运行。run命令运行时，也可以使用组件的名称替代URI运行，前提是该名称对应唯一的组件，如下所示： 1234» fx shell run hello_world_cppfuchsia-pkg://fuchsia.com/hello_world_cpp_tests#meta/hello_world_cpp_unittests.cmxfuchsia-pkg://fuchsia.com/hello_world_cpp#meta/hello_world_cpp.cmxError: &quot;hello_world_cpp&quot; matched multiple components. 因为包含字符串hello_world_cpp的组件还有测试程序，所以没能唯一匹配一个组件从而得到运行。 若要查看一个字符串所对应的组件可以使用locate命令，它将列出所有名称中包含关键字的Fuchsia Package URI，示例如下： 123456» fx shell locate hellofuchsia-pkg://fuchsia.com/hello_world_cpp_tests#meta/hello_world_cpp_unittests.cmxfuchsia-pkg://fuchsia.com/hello_world_rust_tests#meta/hello_world_rust_bin_test.cmxfuchsia-pkg://fuchsia.com/hello_world_cpp#meta/hello_world_cpp.cmxfuchsia-pkg://fuchsia.com/hello_world_rust#meta/hello_world_rust.cmxError: &quot;hello&quot; matched more than one component. Try `locate --list` instead. 最后，在fuchsia终端下，可以查看下一个包安装到系统中的目录结构，包被放在如下目录中： 12345678910111213/pkgfs/packages/hello_world_cpp/0|--bin |--hello_world_cpp|--lib |--ld.so.1 |--libc++.so.2 |--libc++abi.so.1 |--libfdio.so |--libunwind.so.1|--meta |--contents |--hello_world_cpp.cmx |--pacakge 另外补充下，fuchsia的源码使用clion IDE 进行查看非常方便。可以在fuchsia根目录运行 1fx compdb 生成compile_commands.json文件。然后安装IDE Clion，启动后，选择fuchsia根目录导入项目，然后经过漫长的等待，就可以使用ide来查看代码了。 如上内容，如有谬误，请君留言，感激不进。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia的fx命令]]></title>
    <url>%2F2019%2F09%2F29%2Fos%2Ffx%2F</url>
    <content type="text"><![CDATA[之前在介绍fuchsia的编译（fuchsia的编译参考文章：Fuchsia的运行初体验）的时候提到配置fuchsia的编译产品，以及编译fuchsia系统都会使用到fx命令。fx对于Fuchsia的重要性，大概等于编译命令+adb 对于Android的重要性。而且fx有非常多的自命令，本文仅参考官方文档fx workflows,对部分fx的自命令进行简单介绍。 fx 是一个入口命令，通过它开发着可以使用大量的开发过程中将使用到的工具脚本。查看fx支持的子命令可以使用fx help。如果使用bash或者zsh作为shell的话，还可以通过执行脚本scripts/fx-env.h将fx的自动补全功能包含进当前shell中。下面为fx help列出的fx子命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148» fx help usage: fx [--dir BUILD_DIR] [-d DEVICE_NAME] [-i] [-x] COMMAND [...]Run Fuchsia development commands. Must be run with either a current workingdirectory that is contained in a Platform Source Tree or the FUCHSIA_DIRenvironment variable set to the root of a Platform Source Tree.commands:add-update-source register dev host as target's update sourceaemu start fuchsia in aemuargs `gn args` the FUCHSIA_BUILD_DIRblobstats compute some blobfs statistics from the buildbugreport Obtain and parse a bugreport from a connected target.build Run Ninja to build Fuchsiabuild-push build Fuchsia and push to devicecatapult_convertercgptcheck-deps checks dependency graph in areasclang-tidy runs clang-tidy on specified filesclean `gn clean` the ZIRCON_BUILDROOT and FUCHSIA_BUILD_DIRclean-build clean the build directory and then perform a full buildcompdb generate a compilation database for the current build configurationcp copy a file to/from a target devicecpuperf_printdart-remote-test runs a single remote test target through //scripts/run-dart-action.pydart-tunnel forward local ports to Dart VMs on the device.debug run the debug agent on target and connect to it with zxdbdelta compare all built Fuchsia packages with a prior package snapshotdockyard_hostdoctor run various checks to determine the health of a Fuchsia checkoutexec read the current build config, then execexec-host-tests farfidlcat run fidlcat on given target.fidldocfidlgenfidlgen_dartfidlgen_llcppfidlmergeflash flutter-attach attach to a running flutter module to enable hot reload and debuggingformat-code runs source formatters on modified filesfutilityfuzz run a fuzz test on target a devicegce Google Compute Engine commandsgen `gn gen` the Zircon and Fuchsia build directories.gen-cargoget-build-dir print the current fuchsia build directoryget-device print the current selected device nameget-device-addr print the Fuchsia IPv6 address of the current selected devicegidlgnninjacipdjiriinsntrace_printiquery generate a report with component exposed datakazoolint runs source linters on modified fileslist-boards list boards available for buildinglist-packages list packages are builtlist-products list products available for buildinglist-usb-disks list attached usb diskslog listen for kernel logs.make-efimake-fuchsia-vol build a fuchsia persistent diskmake-integration-patch Creates a CL in an integration repository suitable for testing other CLsmetrics manage collection of metrics in fx toolsmkzedboot make a zedboot USB keymulti Run an `fx` command across multiple build directories.netaddr get the address of a running fuchsia systemnetboot run bootserver for netbootingnetls list running fuchsia systems on the local networknet-run run Fuchsia on QEMU in background and runs SSH command after netstack runsninjatrace2json Collect Ninja trace information for analysis in chrome://tracingota do a system OTApave run bootserver for pavingpave-zedboot run bootserver for paving zedbootpending-commits view commits not yet published to global integrationpmpush-package push packages to a deviceqemu-cipd-ensure Generate CIPD files to download the current QEMU package.reboot reboot a target fuchsia systemremote_module_resolverrun start fuchsia in qemu with a FVM diskrun-bash-test runs tests using bash_test_framework.shrun-dart-action Run Dart actions (analysis, test, target-test)run-e2e-tests run e2e testsrun-host-tests build and run tests on hostrun-netboot start fuchsia in qemu via netbootrun-recovery start Fuchsia System Recovery in qemrun-test build a test package and run on target.run-test-component build a test package and run on target.rustdocrustfmtsave-package-stats take a snapshot of all built Fuchsia packagesscp invoke scp with the build ssh configscreenshot takes a screenshot and copies it to the hostserial attach to a serial consoleserve start `pave` and `serve-updates` in a single commandserve-updates start the update server and attach to a running fuchsia deviceset set up a build directoryset-build-dir set the default build directory used by other fx commandsset-clock set the clock on target using host clockset-device set the default device to interact withset-petal configure jiri to manage a specific petalset-relay setup-macos register Zircon tools at MacOS Application Firewallsetup-usb-ethernet Setup udev rules for USB CDC ethernetsftp invoke sftp with the build ssh configshell start a remote interactive shell in the target devicesniff ssh invoke ssh with the keys from $FUCHSIA_BUILD_DIR/ssh-keysstatus print relevant information about the developer setupsymbolize symbolize backtraces and program locations provided as input on stdinsyslog listen for logstrace2jsontraceutiltraceutil-generate-tallyunset-device unset the default device to interact withupdate do a full update of a target systemupdate-rustc-crate-mapupdate-rustc-third-party updates rustc_library and rustc_binary third_party dependenciesuse re-use a previous build directory set up by `fx set`vendor forward commands to vendor/*/scripts/devshellverify-build-packages verify the structure of the build package directory in a layerwait wait for a shell to become availablewhereisclzxdbGlobal fx options: fx [OPTION] ... --dir=BUILD_DIR Path to the build directory to use when running COMMAND. -d=DEVICE_NAME Target a specific device. DEVICE_NAME may be a Fuchsia device name. Note: "fx set-device" can be used to set a default DEVICE_NAME for a BUILD_DIR. -i Iterative mode. Repeat the command whenever a file is modified under your Fuchsia directory, not including out/. -x Print commands and their arguments as they are executed.optional shell extensions: fx-go fx-update-path fx-set-promptTo use these shell extensions, first source fx-env.sh into your shell: $ source scripts/fx-env.sh 生成build配置的命令Fuchsia的编译需要做如下几个选择： 你想编译什么产品？ 你想编译什么平台？ 你想要包含哪些额外的包？ 有了以上的选择，就可以使用fx set配置build了，例如： 1$ fx set workstation.x64 --with //bundles:tests 将此次build设置为运行于x64平台的workstation产品，且将测试程序包也一同进行了编译。这个命令将配置存储在args.gn文件中（该文件默认在out/default/目录下)，然后可以使用命令 1fx args 对该文件进行编辑，编辑关闭文件后，会重新生成配置文件。这里引入了三个新的概念叫 base、cache、universe。要理解这三个概念需要先理解下另一个概念 Paving images ，后文会对其详细介绍，此处可简单理解为是一种刷机方式的刷机包。build配置就是用来决定对哪些依赖进行编译，哪些编译结果文件会被包含到哪个产物中。base、cache、universe就是在这个概念上的三个空间（范围）。 base添加入base的包会被打包进Paviing Image中，他们会和OTA升级包一起升级。在base中的包在运行时不可以被去除-它们决定了一个配置的最小的镜像大小。 cache在cache中的包会被打井Paving Image中，但是它们不包含在OTA升级包中。它们也可以在运行时由于资源限制导致被去除，例如磁盘空间不足。cache中的包可以在任意可升级的时间进行独立升级。这些包是可选的，但是为了体验在满足条件的情况下打包进Paving image中，方便用户开箱即使用。 universeuniverse 中的包是附加可选包，这些包可以按需下载运行。它们不会运行打包到Paving image中。配置平台架构和产品的时候，会将预定义好的一系列包放到如上三种包空间内。平台架构配置会将一些关键的启动驱动放到base中，将一些通用的外围设备的驱动放到cache中，将一些与硬件平台交互用的开发调试用的工具包放到universe中。产品的配置会根据所配置的产品的功能选择一些包分别放入base、cache、universe中。例如，如果编译speaker产品，将增加很多音频多媒体的包到base中，如果编译workstation产品，将会增加一些图形界面、多媒体的包到base中。 关键的产品介绍使用命令 1fx list-products 查看支持的产品，此处介绍其中的三个。 bringup最小功能集的镜像，足够精简。通常用来netboot。它通常用来工作在一些低端设备上，只包含zircon内核和平台特有的驱动，因为缺少必要的网络组件，所以一般情况下也不能进行在线升级。 core允许安装附加功能（universe中的包）的最小的镜像包。是许多高端产品使用镜像的基础功能包，以进行OTA升级。 workstation通用开发环境的基础镜像，包含UI、Media和许多高级别的附加功能。适合爱好者把玩探索。 关键的bundles介绍和产品一样，还有更多的捆绑包，如下几个是最重要的 tools包含一系列的开发工具。这些工具包含命令行的组件启动工具、配置和测试网络的工具、http请求工具、程序调试工具、调整音量的工具得。在产品core配置上，bundles:tools 会默认配置到universe空间中。 tests测试程序集合。可以在设备上运行run-test-componet运行，或者使用fx run-test运行。 kitchen_sink将导致其他所有的目标一同编译。它将消耗host机子的20G存储空间，在设备上也将占用2G的存储空间。 执行build1fx build 通常情况下执行build，运行上面的命令就够了。fuchsia的build采用增量编译，仅对修改的部分进行重复编译。还有一些其他的编译命令，这边也简单介绍下： 123fx clean //清除所有生成的产品fx clean-build //先清除再编译fx gen //重复fx set执行时的gn gen过程。进行细粒度参数更改（例如直接编辑args.gn）的用户可以运行fx gen来重新配置其build。 刷写设备1fx flash 通常用于arm64架构的设备，用来将zedboot刷入设备，为praving做准备。 1fx mkzedboot 通常用于x64架构的设备，用来制作zedboot的USB引导盘，为praving做准备。 zedboot 是啥zedboot是zircon的一个特殊配置，它包含简单的网络栈、一个简单的设备广播和发现协议、一个可将fuchsia写入磁盘的套件等。在arm64的设备上进入zedboot，需开机上电时按住特定的按键，然后使设备进入fastboot flashing模式，这时候在主机上执行fx flash；在x64的设备上，首先需要使用fx mkzedboot制作usb引导盘，然后制作好后，将usb设备插入目标设备，目标设备修改BIOS的引导顺序为从USB启动。（期间若要查看可用的usb设备，可使用命令fx list-usb-disks） paving是啥paving与其他操作系统的flashing非常相似。具体的讲，Paving使用定好要的一组fuchsia协议和规范将组件传输到目标系统，该目标系统将被写入目标设备的各个分区中。flashing只是将原始数据写入磁盘，而paving增加对了对分区的操作。 netbooting是啥netboot是fuchisa的一种特殊引导方式，fuchsia可以通过fx flash或者fx mkzedboot制作的usb引导设备使设备进入zedboot状态，然后可以使用fx netboot命令将要启动的组件直接交给zedboot进行引导，这种方式并未修改目标设备上的系统，而仅仅是从ram进行了启动。 其他开发中用到的命令打印log1fx syslog 用来从各级程序获取log，包含内核、驱动及应用程序的log，因为该命令依赖与网络栈的使用，所以运行zedboot和bringup的设备无法使用该命令获取到日志。 1fx log 获取zircon内核log 主从设备间传递文件1234# 从编译主机复制文件到目标设备$ fx cp book.txt /tmp/book.txt# 从目标设备中复制文件到编译主机$ fx cp --to-host /tmp/poem.txt poem.txt 编译多个目标12345678910111213141516可以使用 --dir为要编译的目标指定存放目录，这样可以在多个编译目标间进行切换$ fx --dir out/workstation set workstation.x64$ fx build为编译的目标设置名字$ fx set-device &lt;workstation-node-name&gt;$ fx --dir out/core set core.arm64$ fx build$ fx set-device &lt;core-node-name&gt;# Start a server for the workstation:$ fx --dir=out/workstation serve# Set the default build-dir and target device to the arm64 core, and# connect to a shell on that device:$ fx use out/core$ fx shell]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia的数据存储变革]]></title>
    <url>%2F2019%2F09%2F25%2Fos%2Fledger%2F</url>
    <content type="text"><![CDATA[根据之前的介绍，Fuchsia引入了一个新的概念Story，Story由一系列的app组成用来完成独立的任务。在Fuchsia上，你可以快速的在不同的设备上切换以使用这些创建好的Story，而可以这样做的原因是，Fuchsia将这些Story的信息保存在了你的个人ledger中。 那么，Ledger是什么？Ledger翻译为中文是账本、分类帐的意思，一个组织或公司用来记录花销收入的账簿。在Fuchsia中，Ledger的含义是分布式存储系统，它位于Fuchsia四层结构的第三层Peridot中。Ledger可以跨设备保存你在应用/模块中的位置，并同步到你的Google账户。Ledger为每一个用户运行的应用程序提供相互分离的数据存储，然后由Fuchsia的Framework通过组件上下文（component context）向（不同设备的）客户端应用程序提供这些数据。这些数据对模块和用户来说都是私有的，不同的用户互相看不到对方的数据，不同的模块也看不到互相的数据。存储的每一项数据都会在不同的设备间透明的进行同步。而任何数据的使用则都是优先使用离线备份，然后再向云端备份。不同设备是有可能对数据进行并发修改的，而并发修改产生冲突后的冲突解决策略，对每个应用来说则是可配置的。数据按照key-value的形式进行存储，多个key-value组成的集合，叫做Page。Fuchisa提供了操作Page的API，可对page进行存储、原子读、快照操作，或者使用Observer来监测数据的变化。 什么情况下使用LedgerLedger为用户存储应用的使用数据，并在用户的不同设备间同步这些数据，当用户重置了设备，用户可以使用这些数据恢复被重置的设备。因为使用Ledger会消耗计算和存储资源，因此如果数据并不需要同步或者持久化，则不要使用Ledger。 Ledger长啥样 如图，Ledger由如下部分组成： Storge： 用来存取本地数据数据是使用key-value的形成组合而成的page，对page的操作是原子性的。每一次对page的提交可以进行多个key-value的增删改查。所有page的每一个commit会有0个、1个或2个(merged)parent commit, 所有这些commit会形成一个有向无环图（DAG）。 Storge组件包含 每一个page的提交记录 保存每个页面状态的不可变存储对象 同步元数据，包括每个对象的同步状态 和Storge进行交互的组件：Local client：通过FIDL向本地运行的应用程序提供数据运行中的应用程序模块通过调用Local client提供的FIDL API将数据存储到Ledger中。当数据产生冲突时，Storge会通知Local client 冲突产生，Local Client使用App所选择的冲突解决策略解决冲突。 Cloud sync：在设备间同步Ledger的状态当有新的commit产生时，Storge会通知Cloud sync，Cloud sync会将Storge中新产生的commit所关联的存储对象推送到云端。而且，Cloud sync也会监视其他设备同步到云端的commit，并将它们下载并插入到Storge中。 Ledger是一个分布式的存储系统，扮演着在不同设备间同步数据的角色。本文对Ledger的简要介绍，希望可以起到帮助理解的作用。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia的运行初体验]]></title>
    <url>%2F2019%2F09%2F22%2Fos%2Fbuild%2F</url>
    <content type="text"><![CDATA[之前几篇文章简单介绍了下Fuchsia中出现的与以往不同的概念。为了能够更直观的了解Fuchsia，这次让我们编译并运行Fuchsia。 下载代码国内镜像，ubuntu19.04环境下编译。为了保持原汁原味，我们还是使用正常的梯子方式来从google获取代码。Fuchsia使用jiri来管理代码，jiri类似repo，通过清单文件管理一系列的git代码仓库。jiri的运行依赖Go和Git，所以需要先准备编译环境： 1sudo apt-get install build-essential curl git python unzip 第一次创建Fuchsia目录，使用如下命令： 1curl -s &quot;https://fuchsia.googlesource.com/fuchsia/+/master/scripts/bootstrap?format=TEXT&quot; | base64 --decode | bash 该命令的前三分之二，主要是下载bootstrap脚本，下载后直接在bash运行，脚本内容如下： 12345678910111213141516171819202122232425262728293031#!/bin/bash# Copyright 2017 The Fuchsia Authors. All rights reserved.# Use of this source code is governed by a BSD-style license that can be# found in the LICENSE file.set -efunction usage &#123; cat &lt;&lt;ENDusage: bootstrapBootstrap the Platform Source Tree.END&#125;if [[ $# -gt 0 ]]; then usage exit 1fi# The fetched script will# - create &quot;fuchsia&quot; directory if it does not exist,# - download &quot;jiri&quot; command to &quot;fuchsia/.jiri_root/bin&quot;curl -s &quot;https://fuchsia.googlesource.com/jiri/+/master/scripts/bootstrap_jiri?format=TEXT&quot; | base64 --decode | bash -s fuchsiacd fuchsia.jiri_root/bin/jiri import -name=integration flower https://fuchsia.googlesource.com/integration.jiri_root/bin/jiri updateecho &quot;Done creating a Platform Source Tree at \&quot;$(pwd)\&quot;.&quot;echo &quot;Recommended: export PATH=\&quot;$(pwd)/.jiri_root/bin:\$PATH\&quot;&quot; 该脚本会在当前目录下创建Fuchsia目录，然后在./jiri_root/bin 目录下下载三个工具：jiri、cipd、fx。然后使用jiri update同步仓库中的代码到本地。所以如果中途因断网或其他原因导致update过程中断的话，可以重新执行jiri update命令继续完成。使用如上脚本初始化完成后会在终端输出： 12&quot;Done creating a Platform Source Tree at \&quot;$(pwd)\&quot;.&quot;&quot;Recommended: export PATH=\&quot;$(pwd)/.jiri_root/bin:\$PATH\&quot;&quot; 所以接下来遵从建议，将.jiri_root/bin/加入到环境变量中，方便以后使用上述三工具。 特别注意：在同步代码的过程中，有可能会报如下错误： 12Some packages are skipped by cipd due to lack of access, you might want to run &quot;cipd auth-login&quot; and try againERROR: context deadline exceeded 解决办法：1、打开如下链接 1https://accounts.google.com/o/oauth2/auth?access_type=offline&amp;approval_prompt=force&amp;client_id=446450136466-2hr92jrq8e6i4tnsa56b52vacp7t3936.apps.googleusercontent.com&amp;redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&amp;response_type=code&amp;scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email 2、会得到一个授权码，如图 3、在命令行输入 12$ cipd auth-loginAuthorization code: [第二步获得的授权码] 4、进入Fuchsia源码目录输入 jiri update（预先设置好环境变量），重新更新代码。 编译代码首先，选择要编译的目标。有几个查看相关的命令，列举如下： 12345678910111213141516171819202122232425262728293031323334353637查看支持的平台$fx list-boardarm64as370chromebook-x64cleo*hikey960kirin970msm8998msm8x53-sommt8167s_refqemu-arm64qemu-x64toulousevim2x64查看可以的procuct$fx list-productsbringupcorerouterspeakerterminalworkstation查看可用的包$fx list-packagesbuild-infodevice_settings_managerhttplog_listenerlog_listener_shellnetwork_time_service......太多了，列几个举个例子 此处使用set命令设置编译core.x64，然后使用build命令进行编译 12345678输入：fx set core.x64 --with //bundles:kitchen_sink输出：Generating compile_commands took 570msDone. Made 31219 targets from 2532 files in 152306ms输入：fx build开始编译，可能需要很长时间。 –with 参数用来指定在可用范围内的包的标签，可以制定多个使用逗号分隔，指定的包可以在过程中临时下载下来。 运行Fuchsia可以使用QEMU运行，也可以使用AEMU（android模拟器）运行。QEMU 运行如下： 123fx runfx run -gfx run -g -N -g 表示一个enable graphics，在QEMU下仅是一个有四个页签的shell-N 表示enable network，在Fuchisa下可以ping一下百度，确实可以使用网络。qemu使用网络需要使用如下命令 12sudo ip tuntap add dev qemu mode tap user xxxxxx &amp;&amp; \sudo ip link set qemu up 加载系统界面： 运行第一个页签为debug log（当前页签黄色高亮）： 其他三个页签： 页签之间可以使用【alt+tab】组合按键进行切换。使用上图中的dm相关命令可进行关机、重启等操作。 使用AEMU运行的命令为 1fx aemu 界面如下图： 至此Fuchsia OS就从源码到运行跑起来了，其中还有很多疑惑的地方需要继续探索，前路漫漫，吾将上下求索之。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android之SystemServer的启动]]></title>
    <url>%2F2019%2F09%2F18%2Fandroid%2FBootSystemServer%2F</url>
    <content type="text"><![CDATA[Android系统中恐怕是没有任何一个进程有SystemServer重要了。Android的大量核心Service都运行在SystemServer上，这些核心的Service笼统的讲几乎能代表整个Android的Framework层。Android区别于Linux的关键又在于Framework层，所以更进一步讲SystemServer几乎又可代表整个Android系统了。本文主要分析SystemServer的启动过程，分析的方法类似于从一个地方到另外一个地方的旅游，不只是单纯的到达目的地，也会欣赏沿路的风景。 SystemServer的启动路径图graph TB; start((设备上电)) --> boot["BootLoader，启动准备软硬件环境"] boot --> kernel_init subgraph kernel kernel_init["kernel初始化 1. zImage解压缩、 2. kernel的汇编启动阶段、 3. Kernel的C启动阶段(kernel/init/main.c start_kernel())"] --> kernel_process["创建kernel三进程： 1. idle(swapper) pid=0 2. init pid=1 由idle 通过 kernel_thread 创建 3. kthreadd pid=2 由idle通过kernel_thread创建负责内核线程的调度管理。"] end kernel_process --> init_main subgraph init init_main["/system/core/init/main.cpp 的mian方法"] init_main --> init_first_stage["/system/core/init/first_init_stage.cpp的FistStageMain 方法: 1. 设置环境变量创建 2. 创建文件系统：/dev,/proc,/sys,/mnt等。 3. execv 执行如下:/system/bin/init selinux_setup 重新进入main"] init_first_stage --> init_set_selinux["/system/core/init/selinux.cpp中的SetupLinux方法。 execv执行如下：/system/bin/init second_stage 重新进入main"] init_set_selinux --> init_second_stage["/system/core/init/init.cpp 的 SecondStage 方法。 1. 设置init进程的oom_socre_adj 值为-1000 2. 注册信号SIGCHLD子进程死亡的信号处理函数: InstallSignalFdHandler，此处与下面的属性服务的socket流使用多路复用epoll。 3. 创建属性服务property_service: StartPropertyService 4. 创建Socket并等待连接。"] init_second_stage --> init_initrc["init.rc 文件处理 解析/init.rc 文件，构造service_list /init.rc 中使用import命令根据系统属性ro.zygote的值加载对应的zygote init.rc文件"] init_initrc --> init_initrc_exe["init.rc 指令的执行 init 在解析完init.rc后依次执行触发器 early-init、init、late-init 在执行on late-init 时，会触发执行 zygote-start on zygote-start，会调用命令start zygote，zygote是个service，定义在/init.${ro.zygote}.rc中 init_service_start=>subroutine: init启动service on zygote-start 触发器描述如下： ----------------------------------------------------------------- on zygote-start && property:ro.crypto.state=unencrypted start netd start zygote start zygote_secondary ----------------------------------------------------------------- 启动的service描述如下： ----------------------------------------------------------------- service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket blastula_pool stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks ------------------------------------------------------------------- 1. 其中的 start zygote 对应 do_start(在/system/core/init/builtins.cpp中定义) 2. 该方法会在service_list 中找到对应的service 并调用service的Start方法。 3. 使用fork和execv（方法：ExpandArgsAndExecv）组合的方式执行命令： /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote 4. fork之后会根据指定的socket信息，为zygote进程创建socket。"] end init_initrc_exe --> app_process subgraph zygote app_process[" app_process 位于/frameworks/base/cmds/app_process/app_main.cpp 中 "] app_process --> app_runtime subgraph app_runtime_init app_runtime["创建AppRuntime对象 AppRuntime继承自AndroidRuntime，调用其构造方法。 "] app_runtime --> android_runtime["AndroidRuntime初始化 初始化Skia图形系统 "] end android_runtime --> arg_init["解析参数 1. 根据传入的参数zygot启动标记为true，设置zygote niceName 为 zygote/zygote64 2. 设置startSystemServer 启动标记为ture。 3. 在参数中添加--abi-list=${ro.product.cpu.abilist} 参数 "] arg_init --> android_runtime_start subgraph app_runtime_start android_runtime_start["调用AndroidRuntime.Start方法 1. 指定android rootdir 为 /system 2. 调用startVm 创建Java虚拟机 3. 回调，onVmCreated 在AndroidRuntime的子类AppRuntime中实现。 "] android_runtime_start --> register_android_function["向VM注册android native functions 1. 注册到VM的native方法定义在/frameworks/base/core/jni/AnroidRuntime.cpp 的全局变量gRegJNI中。 2. 调用ZygoteInit的main方法 "] end register_android_function --> zygote_init subgraph ZygoteInit zygote_init["ZygoteInit.main 1. 位于/frameworks/base/core/java/com.android.internel.os.ZygoteInit 2. 创建ZogyteServer并标记启动 3. 设置进程pid和gid为0 4. 解析参数 5. 调用ZygoteServer.createZygoteSocket创建本地socket服务 6. 调用preload方法预加载系统类和资源 7. fork SystemServer进程 "] zygote_init --> select_loop[" 8. 启动ZogyteServer的selectLoop线程处理子进程的命令 tips: zygote 是受精卵的意思在阅读代码的时候发现对比较早之前版本在zygote中出现了blastulablastula是囊胚的意思，是胚胎发育的下个阶段在囊胚期后，胚胎的全能细胞开始分化逐渐形成各种器官。zygote会创建一个blastula的池，并用固定数量的blastula进程填充了该池这些提前fork好的进程有利用加快应用的启动。 "] zygote_init --> system_server_fork["fork SystemServer进程 1. 调用forkSystemServer方法 2. 调用Zygote.forkSystemServer 并进一步调用 NativeForkSystemServer 3. 传入的参数为 String args[] = { --setuid=1000, --setgid=1000, --setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,101 0,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010, --capabilities=, --nice-name=system_server, --runtime-args, --target-sdk-version=VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, com.android.server.SystemServer, }; 4. 调用SystemServer的main方法。 "] system_server_fork --> system_server_native_fork["native fork system server 1. 位于/frameworks/base/core/jni/com_android_internal_os_zygote.cpp 2. fork之后在子进程（system_server进程）调用SpecializeCommon方法 3. 回掉Java层的ZygoteInit.callPostForkSystemServerHooks 该方法在ZygoteHooks中最终调用nativePostForkSystemServer ZygoteHooks的native方法在/art/runtime/dalvik_system_ZygoteHooks.cc中 4. 回调Java层的Zygote的postForkChild，该方法同样回调ZygoteHooks中的对应方法 "] system_server_native_fork --> handle_system_server_process subgraph handleSystemServerProcess handle_system_server_process["handleSystemServerProcess方法 1. 从环境变量SYSTEMSERVERCLASSPATH中获取到systemServerClassPath 值为：/system/framework/services.jar:/system/framework/ethernet-service.jar:/system/framework/wifi-service.jar 2. 创建SystemServer的ClassLoader并存起来。 "] handle_system_server_process --> native_zygote_init["nativeZygoteInit 1. 方法位于/frameworks/base/core/jni/AndroidRuntime.cpp中 2. 该方法调用其子类AppRuntime的onZygoteInit方法 3. onZygoteInit创建了ProcessState对象，并调用了该对象的startThreadPoll方法ProcessState的构造函数会打开binder设备，startThreadPoll会创建binder线程，为进程提供了使用binder通信的能力 "] native_zygote_init --> runtime_init["applicationInit构造出system_server main 方法的 MethodAndArgsCaller Runnable对象。 "] end end end runtime_init --> system_server_main subgraph SystemServer system_server_main["在SystemServer进程内通过MethodAndArgsCaller对象调用SystemServer入口方法main 1. 创建SystemServer对象，调用其run方法。 tips: 通过创建一个Runnable对象将对main方法的调用返回回来，然后在systemserver进程内进行调用，可以使systemserver进程内的调用栈清空，而main方法是栈顶。 "] system_server_main --> system_server_run["SystemServer run 方法 调整时间，如果系统时间比1970还要早，调整到1970年 1. 设置语言 2. 调整虚拟机堆内存大小和内存利用率 3. 调整binder最大线程数为31+1 3. 初始化Looper为mainLooper 4. 装载库libandroid_server.so 5. 初始化系统Context 6. 创建SystemServiceManager负责系统Service启动 7. 创建和启动Java服务 8. 调用Looper.loop()，进入处理消息的循环 "] end system_server_run --> ams_pms("启动ActivityManagerService启动PackageManagerService等") system_server_run --> system_other_service("startOtherService执行") ams_pms --pms启动完成--> system_ready("标记systemready") system_other_service --执行结束--> system_ready system_ready --> ui("启动systemui，launcher") ui --> e((系统启动完毕)) 以上，就是从上电到桌面启动的全过程。 SystemServer 启动的Eventlog根据开机过程中的event log 信息，可以看到systemserver启动的整个过程执行命令如下 1adb logcat -v thradtime -b events | grep boot 输出结果 12345678910111210-05 00:00:01.164 376 376 I boot_progress_start: 644009-18 11:16:52.257 376 376 I boot_progress_preload_start: 843609-18 11:16:55.166 376 376 I boot_progress_preload_end: 1134609-18 11:16:55.383 929 929 I boot_progress_system_run: 1156209-18 11:16:55.876 929 929 I boot_progress_pms_start: 1205609-18 11:16:56.081 929 929 I boot_progress_pms_system_scan_start: 1226109-18 11:16:58.082 929 929 I boot_progress_pms_data_scan_start: 1426209-18 11:17:08.892 929 929 I boot_progress_pms_scan_end: 2507209-18 11:17:08.949 929 929 I boot_progress_pms_ready: 2512909-18 11:17:10.228 929 929 I boot_progress_ams_ready: 2640709-18 11:17:13.203 929 952 I boot_progress_enable_screen: 2938309-18 11:17:15.030 292 292 I sf_frame_dur: [BootAnimation,14,334,6,1,1,0,0] 分析 启动阶段 阶段开始 阶段结束 耗时(ms) kernel boot_progress_start(16373) 6440 zygote启动预加载 boot_progress_preload_start(8436) boot_progress_preload_end(11346) 2910 system目录扫描 boot_progress_pms_system_scan_start(12261) boot_progress_pms_data_scan_start(14262) 2001 data目录扫描 boot_progress_pms_data_scan_start(14262) boot_progress_pms_scan_end(25072) 10810 home activity启动 boot_progress_ams_ready(26407) boot_progress_enable_screen(29383) 2976 home activity等待boot animation结束 boot_progress_enable_screen(29383) sf_frame_dur 1827]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia：万物皆实体]]></title>
    <url>%2F2019%2F09%2F16%2Fos%2Fentity%2F</url>
    <content type="text"><![CDATA[Fuchsia简述的更多文章：Googel的Fuchsia OS到底是什么Fuchsia的APP变革 之前在文章《Fuchsia的APP变革》中介绍过，Fuchisa的交互单位是story，而story是由一系列来自不同APP的module组合而成的。这些不同的module之间自然的就会涉及到通信问题。所以实体（entities）就应用而生了。Entity就如同胶水一般将各个module粘合在一次，从而构成story来供用户使用。同时这些从数字世界中抽象出的一个个实体，将作为数据单元被Google Assist读取使用，从而让Assistant获得理解用户使用上下文的能力。 Entity概述Fuchsia的官方文档对Entity的描述如下： 123An entity is an identifiable person, place, thing, event, or conceptwhich is represented within the Fuchsia platform as a structured dataobject which can be referenced, retrieved, presented, manipulated, or shared. 大体可以理解为，实体就是在Fuchsia平台上可操作、在不同进程间可分享的一种数据结构，这个数据对象可用来表示一个实际的物体信息，也可以用来表示一个抽象的概念相信。根据文档的描述，实体的表示使用JSON格式。JSON格式不仅可读性很高，而且在不同变成语言中的解析方式都相同，这为Fuchsia的多语言编程打下了接触。同时，用来作为跨设备使用的支撑的Ledger被设计为用来处理JSON对象，这将有利于Ledger在设备之间更好的分享和追踪Entity对象。举例来讲，一个典型的Entity使用场景是复制和粘贴，可以在Story一个module复制entity，然后粘贴到另一个entity中，例如复制联系人、待办事项、或者从一个播放器复制一个歌曲列表到另一个播放器等。然后，分享的实体中的信息可以被APP或者Google assistant读取，利用其中的关键信息做出对该实体的操作或者是根据这些信息可以更进一步的推荐其他信息，推荐的其他信息又是另外的一个个实体。甚至，根据官方文档的介绍，Fuchisa 不仅用在APP中，在浏览器中也可以根据网页的内容生成对应的实体，该实体同样可以在其他APP中被处理。 Entity特征 types: 指示实体的类别范围，使用schema的方式进行表示 content： 实体中包含的数据，使用二进制或者是指定类型的数据结构表示 provider： 实体的提供者 reference： 实体的token，可使用它来找到并使用该实体。Entity分为两类 瞬时实体：在运行时作为传输对象存在，例如 复制到剪切板上的一段文字 从文本内容中抽取出来的一个电话号码 没有被保存的截图 永久实体：可通过Provider获取到的实体，例如 邮件会话 在相册中的照片 联系人卡片 日历中的事件提醒]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fuchsia的APP变革]]></title>
    <url>%2F2019%2F09%2F06%2Fos%2Fstories%26modules%2F</url>
    <content type="text"><![CDATA[相比之前的操作系统，Fuchsia做了很多的变革和特有的功能。Stories和Modules就是其中之一。这两个功能将颠覆之前对智能手机APP的使用方式，带来不一样的使用体验。 在android或者ios系统上，一个应用要么是打开、要么是关闭。如果你想同时处理多件事，大多数应用通过打开新的选项卡来处理，例如浏览器，可以使用不同的tab来打开不同的网页。在Fuchsia系统中，应用是由一个个独立的Modules构成的，每个modules可作为独立的视图或者是功能对外提供。这些modules可以多次打开，例如可以打开两个计算器。在此之上，Fuchsia引入了Story的概念。Story由来自不同应用中的一个或者多个modules构成，用来完成一项任务或者一个完整的想法（无论这些modules最初是用来做什么的）。 下面是对Story和Module的官方介绍 Stroies123A story is a logical container for composing a set of modules.Stories and their associated state are stored in the user&apos;s Ledger. 一个Story是由一系列的modules组合而成的一个逻辑容器。这个逻辑容器的信息（story和和它关联的状态）将存储在Ledger(Fuchsia的存储系统，存储story及其状态可实现跨设备同步使用此story)内。 12The modular framework uses the fuchsia.modular.StoryShell interfaceto display the UI for stories. Story的生命周期123Stories can be created, deleted, started, and stopped.Created and deleted refer to the existence of the story in the ledger, whereas started and stopped refer to whether or not the storyand its associated modules are currently running. Story有四个状态：created、deleted、started、stopped，created和deleted表示在ledger中是否存在该story，而started和stopped用来表示此story及其中的module是否正在运行。 Modules12345A Module is a component which displays UI and runs as part of a Story.Multiple modules can be composed into a single story,and modules can add other modules to the story they are part of. Module&apos;s can either embed other modules within their own content,or they can delegate visual composition to the StoryShell. Module 是Story用来显示UI的一个组件，一个Story可以添加多个module，module也可以添加其它module到它所在的story中，也可以在module内部嵌套其他module。 Module的生命周期123A module&apos;s lifecycle is bound to the lifecycle of the story it is part of. In addition, a given module can have multiple running instances in a single story.When a module starts another module it is given a module controller which it can use to control the lifecycle of the started module. 一个模块的生命周期依赖于它所在的story，一个module可以在一个story内部创建多个实例。当一个module创建了另一个module时，会得到被创建module的controller，通过controller即可控制该module的生命周期。 Module之间的通信机制1Modules communicate with other modules via intents and entities, and with agents via FIDL and message queues. Module之间通过传递intent和entities进行通信。 Fuchsia中没有像其他系统中那样有最近使用app的概念（Recent Apps）,取而代之的增加了最近使用的story（Recent Stories）。想要组合多个module，可以通过拖拽将不同的story组合在一起，然后根据需要调整view的大小。同时也支持使用一个本地设备上不存在的module，就像“Android Instant App”的改进版。Story符合人们做事情时分步骤但是连续的思路。而以往的App则时一种分离的做事方式。Story是一种更加连贯的思维方式，不同于App的使用。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google的Fuchsia OS到底是什么]]></title>
    <url>%2F2019%2F08%2F30%2Fos%2Fwhat's%20fuchsia%20os%2F</url>
    <content type="text"><![CDATA[2016年，谷歌开始了新一代操作系统Fuchsia OS的开发。该系统在当时被普遍认为是用来在将来替代Android系统的。然而，时间飞快，直到今日，Fuchsia OS似乎也没有太多的出现在大众的视野中，甚至很多从业人员对其也并不了解。实际上，Google也层低调的公布过一些进展，例如2017年的五月曾经发布过很有Fuchsia OS特征的Fuchsia OS的主界面，2018年层宣布Fuchsia OS成功在PiexlBook上成功运行。2019年的6月底，Goolge低调的上线了Fuchsia 的开发者网站，后又适逢华为鸿蒙系统的发布，而华为鸿蒙系统也被理解为是android系统的替代者，Fuchsia OS又重新回到了大众的视野。随着人们对鸿蒙系统关注度的提高，我觉得最好能简要介绍下Fuchsia到底是什么。 Fuchsia 的 UI在次主要讨论Fuchsia OS 在17年放出的主界面UI。当你启动并进入系统后的第一感受，就是在风格上大量的使用了Material Design。Fuchsia使用了特有的图形渲染器Escher，专门用来处理阴影。这使的窗口、通知、按钮、弹出框分层更清晰更有层次感。使得壁纸不再只是窗口后面的一张图片，而是像从窗口中看出去的风景。Fuchsia 当前的UI可查看下方的视频（有感兴趣的可以给我留言留下邮箱获取此demo)。在该UI上，明显的分为了三部分。中间部分是一个新的布局，据官方说明，叫做Armadillo，这部分用来显示系统时间，当前用户，以及系统状态。同时，它也是一个快速设置的入口，点击用户头像可进入快速设置页，有一些对设备及用户的设置。下部分，是一个依托于Google Assisant的建议栏，该部分通过像助手发起人性化的请求（语音或者文字输入），助手给出相应的建议。 上部分是当前进行中的任务，不同于android的应用，这里的任务流程来自于不同的应用里面，然后可根据用户的需求自由组合成Story，它代表的是一系列正在进行中的活动。不同的story 可以继续组合嵌套，从而成为更大的story(用户故事)。 (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"loop":"yes","screenshot":"yes","video":{"url":"/2019/08/30/os/what%27s%20fuchsia%20os/UIVideo.mp4"},"danmaku":{"id":"someid","api":"https://api.prprpr.me/dplayer/","addition":["/some.json"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})() 下方的助手给出的建议可能会执行多步操作，这些操作将打开不同的应用组合成完整的story供用户使用。这将是对用户交互的一个有趣的革命。 Fuchsia看起来就是为Assistant服务的Fuchsia 就是为了容纳Google Assistant而服务的。在Fuchsia上，你所见、所做及所能做的对于Fuchsia来说都是可见的。——至少现在Google的文档是这样描述的。在Android手机上，Google 助手在你需要的时候，可以读取屏幕信息为它所用，而在Fuchsia上，Google助手则时刻更深入的读取你的信息。当你浏览网页查看美食推荐，然后查看日历挑选日期，然后对助手说：“邀请Samantha共进午餐”时，助手已经获取到了你所做过操作的内容。助手将读取所有的==实体==（在Fuchsia上的一个概念：表示可识别的人、地点、事物、事件或概念）。并且将会读取过去在屏幕上曾经出现过的实体。这些过去的实体将更有助于助手读取并操作现在上下文中的实体。Fuchsia 更像时一个个人助手，它收集你的操作，提取你操作中的一个个实体数据，然后利用这些收集的实体数据构成它执行的上下文，从而给出更人性化的建议。 Fuchsia 是一个跨设备OS当今时代，每个人都有很多的电子设备：手机、平板、电脑、可穿戴的手表等。Fuchsia 致力于在这些不同的设备间进行无缝衔接使体验做到一致。要做到这样效果的难题在于维护同一的上下文，因此Fuchsia引入了Ledger的概念。Leger是一个分布式的存储系统。一旦登陆Google账号，就会自动将设备中需要存储的上下文数据同步到云端。设想未来的场景：当你在手机浏览器里浏览一个页面，然后打开笔记本的浏览器时将正好进入之前未关闭的页面；笔记本上正在编辑的文档，可以在手机上打开；正在工作的设备因为电池没电而关机，找一台公共设备登陆账号即可继续工作。至此，由于台式机、笔记本的Fuchsia和手机的Fuchsia并没有区别，所以可能并不需要如此多的设备，只需将手机通过某种扩展链接大屏设备，即可享受使用大屏设备的体验来使用手机。 Fuchsia的架构优于AndroidAndroid的碎片化严重。在Treble架构（为了方便系统升级，将oem定制的东西和Framework分离）引入之前，OEM厂商升级Android的新特性需要将自己的修改patch到新版本的系统上，这是非常麻烦的。即使是有Treble之后，OEM厂商也没有积极的将Treble架构应用在自己的系统上。Fuchsia采用zircon内核来解决这一问题，zircon被设计为独立可升级的。为了达到这一目的，应用程序与内核隔离开来。在内核和应用层之间插入隔离层，使内核独立升级后不至于影响到应用的运行。 Fuchsia面向开发者方面Fuchsia的大多数UI都是用DART（一种被设计成让JavaScript和Java开发人员感到熟悉的语言）通过Frutter框架实现的。还支持Go语言。谷歌还通过引入了swift支持来引入苹果的开发者群体。不过，最重要的是，大多数这些语言都支持互操作。通过FIDL（Fuchisa接口定义语言）协议，DART UI代码可以直接与Go后端或任何其他语言代码互相调用。这使开发人员更具表现力，并为手头的工作使用最好的语言开发。 总结起来，Fuchsia从最初就考虑更友好的支持OEM厂商使用和更便捷的吸引各个领域的开发人员。在使用时，通过及时的自动同步用户的使用记录，以实现在各个设备之间的无缝衔接体验。同时将从这些使用的数据中抽取出实体，形成用户使用的上下文环境，提供给个人助手以给出符合当前用户所需的建议。这些建议能够自动分解、串联起系统中的应用实现一些列的任务，展现在UI上并提供给用户服务。Fuchsia的交互核心时基于事物，完全打破了应用之间的界限。用户对于Fuchsia的感知和认识将是一个行为一致的个人助理，它存在于用户的手表中、手机中、电视中、车辆中及运行着Fuchsia系统的任意设备中。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Harmony&Fuchsia的相遇]]></title>
    <url>%2F2019%2F08%2F16%2Fos%2Fharmony%26fuchsia%2F</url>
    <content type="text"><![CDATA[一 2019年8月9日华为正式发布鸿蒙系统，同时表示系统开源。鸿蒙系统的发布是在美国制裁华为的大背景下，华为手机业务极度依赖的android系统极有可能随时断供。在此节点下，自然而然的会让大众理解为是对android断供风险的抵御。但是，时代是进步的。华为重造一个android不过是重嚼别人嚼过的甘蔗，又有何味道呢。华为可是5G的引领者，5G绝非是速度更快的4G，它的领域是万物互联的新一片星辰大海。理所应当的（如果一切不是场战略骗局的话），鸿蒙系统当是这片大海中的一艘远洋巨舰。 这么大的一片海，只要不是个瞎子，都是看的见的。做为Android这个航行了十年大船的舵手Google，自然早有预见。2019年6月29日Google悄然上线Fuchsia开发者网站，同时Fuchsia从诞生之时就已开源。两相印证，鸿蒙和Fuchsia的同时出现并非偶然，也不是单纯的大国较量结果，它有更宏大的背景：人类新时代的到来。简略的说人类经历几次科技革命，从互联网到移动互联网再到即将或正在来临的万物互联网，获取信息的方式跟随连接方式变得的越来越多样。个体是分内外的，否则无所谓个体。所以有连接就有接口，有接口就有交互。OS的作用既是对这多种多样交互的统一。随着万物的逐渐互联，所需的交互方式越来越多，已有的OS已难以继续满足需求。不过像华为、像Google他们想到这个会更早，更深刻，他们在五年前、十年前早已想到并着手开发，所以有了FuchsiaOS，有了鸿蒙OS。他们都是人们交互需求下的正常产物。 二 鸿蒙系统为何物，在近期的各种宣传下，大家多少有些了解了。现搜集整理如下： 鸿蒙的发展历程 鸿蒙的架构 逐层的看，应用层表达的是支持多终端；程序框架特意强调了是多用户；基础服务的底层是分布式；内核层当前是多个内核并存。鸿蒙微内核和LiteOS均为华为自主研发，而同时集成Linux内核，不知是当前能力不足无法解决一些问题，还是为更好的兼容当前的android平台应用所做的妥协。至于未来的架构，未来的事情未来再说吧。 鸿蒙的四大技术特性 分布式架构首次用于终端OS，实现跨终端无缝协同体验。 官方主要解释为实现了模块化接耦，对应不同平台可以弹性部署，实现跨终端无缝的协同体验。从发布会给出的架构图来看，分布式底层依赖分布式软总线，中间对硬件能力进行了虚拟化，使得不同的设备可以像调用自己的设备一样调用系统中其他设备上的硬件，分布式的数据管理可以使不同设备共享同一份用户数据，只是目前不知道到底是如何具体实现的。分布式的任务调度，例如可使得家庭中的各设备可以协同完成同一任务，即提高响应又能够进行全模态的交互。 确定时延引擎和高性能IPC，通过对交互进行实时性通道的划分，更好的保证用户交互体验的流畅。同时底层高效的IPC为进程的协作保驾护航（鸿蒙的微内核架构，如果没有很高效率的IPC，又如何敌的过宏内核的linux呢）。值的注意的是，这块特意提到了与Fuchsia（FIDL）的对比，鸿蒙的IPC效率是Fuchsia的5倍。 基于微内核架构重塑终端设备可信安全, 现在看鸿蒙应该叫多内核环境。至于安全这件事，从来都是要便利买单的。 统一IDE支撑开发、多端部署。 三 Fuchsia 为何物，可能很多人就不太了解了。Fuchsia一直保持着低调和神秘，大家的关注度也不高，其实就连华为也是其重要的代码贡献者。在Fuchsia的开发者网站上，对Fuchsia的描述也只有两行：12345Pink + Purple == Fuchsia (a new Operating System)Welcome to Fuchsia! This document has everything you need to get started with Fuchsia.Note: The Fuchsia source includes Zircon, the core platform that underpins Fuchsia. The Fuchsia build process will build Zircon as a side-effect; to work on Zircon only, read and follow Zircon&apos;s Getting Started doc. Fuchsia 大事记实在没啥好说的 2016年Google开发者大会发布 2019年6月底上线开发者网站 Fuchsia 架构Fuchsia的架构被谷歌形容为层叠蛋糕，大概如下图： 从下往上，每一层的名字都是一种石头:第一层是Fuchsia的内核层，该层为Zircon（皓石），类似于linux之于android。负责处理硬件访问和软件之间的通信，与鸿蒙系统的内核一样，Zircon也是微内核的架构（相比宏内核的高效率，微内核由于需要频繁的进程间通信会损耗一部分性能，但是对于分模块开发和提升安全性确是非常重要的优势）第二层，名叫GarNet（石榴石），包括系统所需的各种底层功能，硬件驱动程序也在这一层，同时这一层也负责软件安装。第三层，名叫Peridot（橄榄石），这一层主要负责支持Fuchsia的模块化应用程序设计，负责各模块之间的数据同步等，同时这一层也集成了Google Assisant。第四层，名叫Topaz（黄玉石），是与应用开发者和使用用户关系最紧密的一层，该层可类比为Android中的系统应用层。 Fuchsia的特点关于Fuchsia的技术特点，零零碎碎，未找到官方统一的一个说明，有几点简单说明一下 多层蛋糕这种结构，想必是Google从android吸取经验而来，这样分层，可以允许厂商独立替换其中某层，比方，再Peridot这一层有负责各模块数据同步的模块，该模块依赖于Google账号服务，对于国内的设备厂商可以实现自己的数据共享能力，但是同时还可以得到其他层的版本更新支持。 最上层Topaz提供Flutter支持，更方便的接入大量的各种功能的应用 Peridot层面向模块设计的应用程序，通过程序内模块的自由组合成用户的story（可理解为用户完成一项任务的各个步骤的集合），从而面向场景化使用，达到系统提供功能的风格一致的复用。这和android系统intent的设计理念高度相似。 Peridot使用Google账号服务的模块间数据共享，各模块可能位于不同的终端设备上，又有一些鸿蒙系统分布式的味道。 四 在几乎相同的时间点，华为和Google，分别已鸿蒙系统和Fuchsia系统这两个有众多相似点的系统相遇。它们都面向未来的多种智能设备；微内核的结构都给了设备厂商开发部署各自模块的自由；都在多个设备之间可以无缝的共享数据自由切换；都没有再继续使用linux kernel作为系统的内核；并且都开源了。相遇的这个节点应该不是偶然，这东西方两大巨头的同时到位似乎预示着一个新的交互时代的来临。这次交互时代变革的规模比以往的范围要大的多，他是对万物的连接。现在是大一统前的黎明，当紧随两艘巨舰的航迹。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robot OS 框架杂谈（二）：语音交互各厂产品]]></title>
    <url>%2F2018%2F06%2F26%2Frobot-os%2Farch%2Fvui2%2F</url>
    <content type="text"><![CDATA[语音交互已经火了这么几年，涌现了许多的厂商。本文主要从什么是语音操作系统出发，到语音操作系统各公司的产品情况，到在语音交互下可以有哪些场景出发，做了总结。 查看原图，请点击查看脑图原文]]></content>
      <categories>
        <category>机器人OS</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android性能优化之帧率测试]]></title>
    <url>%2F2018%2F06%2F21%2Fandroid%2Ftest%2Foptimization%20frame%20rate%2F</url>
    <content type="text"><![CDATA[作为一名anroid开发，经常会听到产品或者测试说，他们感觉界面卡顿。然而这感觉二字该如何修改？须得以数字说话方可。 人为感受界面的流畅度，转换为衡量指标，一般都使用帧率（FPS： frame per second）衡量。人眼感受界面流畅须得60fps方可，这样处理每一帧的时间就必须短于1000ms/60=16ms左右。android的UI绘制原理，叫垂直同步机制，简单描述就是每隔一个时间间隔（16ms),android 会发起一次中断，cpu/gpu 响应该中断就去判断一次是否有处理缓冲好的数据需要显示，如果有则将数据刷新到屏幕上，如果没有则再等一个时间间隔，这个时间间隔叫做vsync时间。假设16ms内没准备好要显示的数据，则cpu就不去刷新UI，结果就是在接下来的16ms内界面未发生变化，人眼就会感觉到动画的不连续，这就叫做卡顿。所以结合这个原理，我们只要获取到图像帧的处理数据，就可以用数据说明当前显示的动画是否发生了卡顿，进而有针对性的去分析卡顿的原因，从而解决问题。android 系统服务为我们提供了大量的工具来从系统获取信息，使用如下命令查看可获取哪些服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677» adb shell service list Found 75 services:0 motionEventService: [android.hardware.robot.IMotionEventService]1 motionCtrlService: [android.hardware.robot.IMotionControlService]2 ledCtrlService: [android.hardware.robot.ILedControlService]3 keyEventService: [android.hardware.robot.IKeyEventService]4 media_router: [android.media.IMediaRouterService]5 assetatlas: [android.view.IAssetAtlas]6 dreams: [android.service.dreams.IDreamManager]7 commontime_management: []8 samplingprofiler: []9 diskstats: []10 appwidget: [com.android.internal.appwidget.IAppWidgetService]11 backup: [android.app.backup.IBackupManager]12 uimode: [android.app.IUiModeManager]13 serial: [android.hardware.ISerialManager]14 usb: [android.hardware.usb.IUsbManager]15 audio: [android.media.IAudioService]16 wallpaper: [android.app.IWallpaperManager]17 dropbox: [com.android.internal.os.IDropBoxManagerService]18 search: [android.app.ISearchManager]19 country_detector: [android.location.ICountryDetector]20 location: [android.location.ILocationManager]21 devicestoragemonitor: []22 notification: [android.app.INotificationManager]23 updatelock: [android.os.IUpdateLock]24 servicediscovery: [android.net.nsd.INsdManager]25 connectivity: [android.net.IConnectivityManager]26 wifi: [android.net.wifi.IWifiManager]27 wifip2p: [android.net.wifi.p2p.IWifiP2pManager]28 netpolicy: [android.net.INetworkPolicyManager]29 netstats: [android.net.INetworkStatsService]30 textservices: [com.android.internal.textservice.ITextServicesManager]31 network_management: [android.os.INetworkManagementService]32 clipboard: [android.content.IClipboard]33 statusbar: [com.android.internal.statusbar.IStatusBarService]34 device_policy: [android.app.admin.IDevicePolicyManager]35 lock_settings: [com.android.internal.widget.ILockSettings]36 mount: [IMountService]37 accessibility: [android.view.accessibility.IAccessibilityManager]38 input_method: [com.android.internal.view.IInputMethodManager]39 bluetooth_manager: [android.bluetooth.IBluetoothManager]40 input: [android.hardware.input.IInputManager]41 window: [android.view.IWindowManager]42 alarm: [android.app.IAlarmManager]43 consumer_ir: [android.hardware.IConsumerIrService]44 vibrator: [android.os.IVibratorService]45 battery: []46 hardware: [android.os.IHardwareService]47 content: [android.content.IContentService]48 account: [android.accounts.IAccountManager]49 user: [android.os.IUserManager]50 entropy: []51 permission: [android.os.IPermissionController]52 cpuinfo: []53 dbinfo: []54 gfxinfo: []55 meminfo: []56 procstats: [com.android.internal.app.IProcessStats]57 activity: [android.app.IActivityManager]58 package: [android.content.pm.IPackageManager]59 scheduling_policy: [android.os.ISchedulingPolicyService]60 telephony.registry: [com.android.internal.telephony.ITelephonyRegistry]61 display: [android.hardware.display.IDisplayManager]62 appops: [com.android.internal.app.IAppOpsService]63 usagestats: [com.android.internal.app.IUsageStats]64 batterystats: [com.android.internal.app.IBatteryStats]65 power: [android.os.IPowerManager]66 sensorservice: [android.gui.SensorServer]67 media.audio_policy: [android.media.IAudioPolicyService]68 media.camera: [android.hardware.ICameraService]69 batterypropreg: [android.os.IBatteryPropertiesRegistrar]70 media.player: [android.media.IMediaPlayerService]71 media.audio_flinger: [android.media.IAudioFlinger]72 SurfaceFlinger: [android.ui.ISurfaceComposer]73 drm.drmManager: [drm.IDrmManagerService]74 android.security.keystore: [android.security.keystore] 获取帧相关信息主要会用到其中的两个service：SurfaceFlinger 和 gfxinfo。 第一步在设置–&gt;开发者选项–&gt;GPUU呈现分析中选择通过adb分析第二步 看下当前的界面显示layer情况12345678» » adb shell dumpsys SurfaceFlinger --list zhaojie@zhaojie-desktopDimLayerDimLayercom.ijourney.bindrobot/com.ijourney.bindrobot.MainBindActivityFocusedStackFrameSurfaceViewDimLayerDimLayer 其中每一行可以理解为是一个图层，找到我们想要查看的图层比如：com.roobo.bindrobot 第三步 获取帧信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219» adb shell dumpsys gfxinfo com.ijourney.bindrobot zhaojie@zhaojie-desktopApplications Graphics Acceleration Info:Uptime: 320375 Realtime: 320375** Graphics info for pid 610 [com.ijourney.bindrobot] **Recent DisplayList operations ConcatMatrix DrawBitmap RestoreToCount DrawDisplayList Save ClipRect DrawText RestoreToCount RestoreToCount DrawDisplayList DrawDisplayList DrawRoundRect DrawRoundRect Save ClipRect DrawDisplayList Save ConcatMatrix DrawBitmap RestoreToCount DrawDisplayList Save ClipRect DrawText RestoreToCount RestoreToCount DrawDisplayList DrawDisplayList DrawDisplayListDrawRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawBitmapmultiDraw DrawBitmapmultiDraw DrawBitmapDrawBitmapmultiDraw DrawTextCaches:Current memory usage / total memory usage (bytes): TextureCache 3084240 / 25165824 LayerCache 0 / 16777216 RenderBufferCache 0 / 2097152 GradientCache 0 / 524288 PathCache 240 / 10485760 TextDropShadowCache 0 / 2097152 PatchCache 2880 / 131072 FontRenderer 0 A8 524288 / 524288 FontRenderer 0 RGBA 0 / 0 FontRenderer 0 total 524288 / 524288Other: FboCache 0 / 16Total memory usage: 3611648 bytes, 3.44 MBProfile data in ms: com.ijourney.bindrobot/com.ijourney.bindrobot.MainBindActivity/android.view.ViewRootImpl@41937b60 Dirty Regions: Disabled Draw Process Execute 1.39 3.84 0.93 2.46 2.92 0.90 2.77 4.02 1.09 1.79 4.36 1.24 1.78 4.47 1.30 1.51 3.76 1.57 1.82 4.39 1.39 1.62 4.48 1.41 1.46 4.18 1.78 2.55 5.81 1.08 1.78 4.21 1.91 1.77 3.62 5.87 1.84 4.04 1.78 2.03 3.21 1.17 1.89 3.53 1.16 1.55 3.90 1.47 2.24 3.32 1.05 2.14 3.63 1.12 1.58 3.52 0.99 1.52 2.66 1.30 1.44 2.68 1.15 1.42 2.67 1.19 1.39 2.65 2.55 1.77 3.72 1.31 1.22 2.75 0.93 1.63 2.95 1.24 1.30 3.15 1.41 1.49 2.94 1.03 0.69 2.16 0.84 1.98 2.90 0.97 1.56 2.96 0.99 1.37 3.03 1.19 1.27 3.29 1.11 1.16 2.93 1.08 0.86 2.62 0.90 0.85 2.55 0.86 3.14 3.03 0.86 0.93 2.85 1.28 681.97 17.91 1.26 0.84 3.04 2.06 1.27 2.31 1.42 0.71 1.96 0.85 535.65 15.30 1.26 0.97 4.25 1.56 501.46 10.01 1.21 0.39 2.50 1.52 0.77 3.04 1.72 0.79 3.54 1.25 1.16 2.12 1.35 0.41 1.54 0.76 0.57 2.93 1.35 1.72 4.07 3.81 1.43 2.43 0.93 0.50 1.54 0.82 1.49 2.49 1.06 0.64 1.75 1.04 1.30 3.32 1.53 1.43 3.62 1.68 0.45 1.92 0.99 1.75 3.44 1.80 0.46 1.79 1.05 2.00 3.03 2.35 0.45 1.71 0.96 0.51 2.74 1.16 0.62 3.07 1.27 1.31 2.35 1.14 0.42 1.56 0.78 0.66 3.09 1.34 1.36 2.35 1.06 1.40 2.28 1.00 0.45 1.80 0.94 1.26 3.32 2.75 0.42 1.83 1.06 1.42 0.25 1.26 0.57 0.52 3.39 0.78 0.31 1.34 13.63 3.78 2.18 2.08 8.65 3.25 2.27 5.36 1.58 1.50 5.01 1.37 1.23 6.11 1.25 1.48 3.14 1.07 1.14 3.26 1.55 1.24 3.86 1.44 1.29 3.88 1.43 1.53 4.06 1.55 1.09 3.20 1.33 1.14 2.65 1.34 1.17 2.55 1.44 1.11 2.55 1.87 1.28 3.19 1.22 0.45 3.12 2.65 1.85 3.01 1.18 0.78 3.29 1.51 0.80 4.20 1.63 0.90 3.63 0.93 0.88 3.55 1.36 0.49 3.83 3.38 0.47 3.90 2.18 0.88 2.70 1.34 0.79 3.46 1.10 0.83 3.45 1.20 0.99 3.30 1.33 0.70 2.99 1.09 0.66 2.57 1.36 0.74 3.01 1.18 0.71 3.32 1.38 0.85 3.87 1.39 0.98 3.33 1.41 0.88 5.22 1.98 0.81 3.48 2.16 0.72 2.85 3.44 0.44 2.62 1.15 2.31 2.57 0.86 1.14 2.83 0.85 0.77 2.57 0.86 0.79 2.99 0.94 1.07 3.97 1.08 1.21 5.06 0.96 3.09 2.97 1.08 1.07 2.91 0.95 1.16 3.48 1.10 1.14 3.26 1.08 1.36 2.95 1.07 1.41 3.08 1.31 2.23 3.82 1.08 1.28 2.89 0.82 1.36 2.38 1.74View hierarchy: com.ijourney.bindrobot/com.ijourney.bindrobot.MainBindActivity/android.view.ViewRootImpl@41937b60 50 views, 3.78 kB of display lists, 348 frames renderedTotal ViewRootImpl: 1Total Views: 50Total DisplayList: 3.78 kB 上面的数据中包含128帧最新的耗时数据 第四步，利用excel生成堆积柱状图如下： 这样就一目了然的看出图像显示的耗时情况，也能分析出是否会出现掉帧。]]></content>
      <categories>
        <category>android</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robot OS 框架杂谈]]></title>
    <url>%2F2018%2F06%2F21%2Frobot-os%2Farch%2Fvui1%2F</url>
    <content type="text"><![CDATA[大概是2015年开始，人工智能突起，出现了非常多家的机器人公司，其中有一类发力于家庭服务机器人。为了满足各家机器人的使用需要，各家争相开发自己的机器人OS，或者叫机器人框架。时至今日，有的机器人OS已经死亡，有的奄奄一息，有的还在继续成长，有的已经成熟。有幸接触了几家的OS，现罗列如下，以作纪念。 总章何为机器人OS目前或者说之前，大家通常的做法都是在andrid系统之上，添加诸如asr\tts\nlp等相关功能，添加自己的业务逻辑已实现自己的需求，这样的一套东西，合起来通常被叫做机器人OS。另外现在家庭娱乐类型的机器人基本都得联网使用，其核心处理逻辑，诸如语义理解、图像识别多需在线完成，所以机器人OS也该包含相应的云端服务。综上，机器人OS可以描述为，承载了交互规范，集成了机器人基本能力，对不同用户场景进行调度的一套框架；分为两大部分：终端展示层和云端核心大脑层。本文重点描述各家终端机器人的框架 TuringOS 1.5 TuringOS1.5 是北京光年无限开发（图灵机器人）开发的基于android深度定制的机器人OS，其核心组成部分如上图。 图灵机器人OS开放生态这部分主要包含图灵的云端大脑（提供语义服务及场景决策相关），支持自定义意图的平台、终端的OS。终端的OS与android系统深度耦合，主要核心服务运行在SystemServer进程中。主要核心服务按照大的模块可分为两部分：基础支撑和交互逻辑。基础支撑主要定义了机器人的输入输出，输入包括asr(听)、机器视觉（看）、传感器（触），输出主要包括tts(说)、表情（情绪）、动作（身）、LED等。图灵将这样的一种多种输入与多种输出同时与用户交互定义为多模特输出。交互逻辑主要定义了语音交互的对话流程，既语音交互界面，类比触摸输入与屏幕展示，基础对话服务可理解为VUI（Voice user interface)的基础；交互逻辑的另一主要部分是场景切换逻辑，主要规定了场景的优先级及场景切换策略。场景管理切换主要依托于android的packagemanager 和 activiymanager进行，好处是利用了android已经有的机制，坏处是与android系统绑定太紧,对于想打造一款真正的类似windows/android这样的机器人操作系统来说，这样做是好的，但是对于大多数希望快速盈利的公司，这种深度耦合，增加了移植成本，所以turing的这种深耦合做法遭到了大家的鄙夷。终端OS部分，另一重要的部分是对云端协议的解析，这是控制机器人的中枢指令，相当重要。另外终端OS也包含一些自由的资源文件、以及为保护这些所添加的加密芯片等。 图灵机器人SDKturingOS 1.5设计之初就在为平台化做准备，所以为了支撑这一目标，提供了完备的SDK及SDK的使用文档，为了配合开发者为平台开发应用，还在OS内部集成了对开发好的应用进行合法性检查的模块。不同于别家的SDK，turingOS1.5的SDK 与android sdk融合在了一起，这样使的整个图灵OS看起来更像是一个完整的OS，而不是跑在android系统之上的一个APP，可惜了，在当时，这样的设计太过超前，在没有持续投入的情况下，伟大的目标往往是悲剧的开端。 图灵APK图灵apk 主要有三方来源，一是自己开发的核心功能组件，二是自己开发的核心业务场景apk，三是授权开发者开发的场景apk。 在此，turingOS1.5死的颇为可惜，哀悼与怀念三分钟。 TuringOS Lite turingOS Lite 与turingOS1.5思想上一脉相承，是turingOS1.5的子孙后代。上图为turingOSLite 在android整个框架中的位置，也大致分为三个部分 TuringOSLite 本体turingOSLite 其实早期被称作机器人开发框架，设计原则是小而轻便，灵活易替换易扩展。对于他来说重要的是概念，在这个框架上定义了三个核心的概念：场景（scenario）和功能（function),以及控制场景调用功能的事件拦截器。场景是机器人的业务单元，代表用户的应用场景。功能是机器人的固有能力，表达的是机器人的固有属性。除此之外对于turingOSLite一切具像的场景和功能都不重要，因为核心就是定义出这些概念，具体实现不同的开发者按照自己的思路去实现就好了。感觉这是图灵又走了另外一个极端，太实则太重，太虚则无力。当时的意图可能觉得图灵的核心是语义这些表象的东西定义好规范，让别人去照做也不影响核心业务。导致最后竞争力较弱，颇显惋惜。 TuringOS Lite API实质上，TuringOSLite 可算作是个早产儿，发育还不足月。作为一个SDK，必须与开发出的应用绑定在一起，作为API只是对核心功能的暴露，虽然在逻辑分层上存在api这一层，但是它确是与核心服务物理上在一块的，此处还有较大改进空间。 TuringOS Lite 场景此处的场景就不是以独立apk的形式存在了，物理上就是一个实现了Scenario接口的类，顶多算个个语义上的存在。当然可以按照TuringOSLite 插件的形式去开发这些类。 Roobo ROS.AI 为什么roobo的ROS（此ROS 非彼ROS）还活着，窃以为它介于TuringOS1.5 和 TuringOSLite 之间。ROS 也是基于android定制的，但是没有把核心服务死死的绑定到android的framework里，也向外提供api,但是使用此api开发的应用又都是实实在在的安卓apk。从框图上看，也可将其分为三部分。 ROS 核心服务群核心服务主要包含两部分，管理核心服务的框架和具体的核心服务实现，核心服务框架为core.apk，具体的服务实现为各种service apk，这些service均挂载在core上由core统一对外提供服务。在core当中另外一个重要的工作是场景管理和焦点管理，焦点管理用来解决硬件资源使用冲突的问题，焦点这个思想应该是来源于android的音频焦点管理。 ROS SDKROS 的SDK 主要包含两部分内容，能力API和负责场景APK和core之间的跨进程通信。实现还是相对巧妙的，SDK中有一默认的DefaultService，当Core去管理场景APK时，通过启动这个service从而带起整个场景APK的进程，然后创建通信渠道，发送指令。而这一切都在SDK中做好了，对于场景APK来说都是无感的，这样进一步降低了android app开发者在ROS上开发应用的难度。 ROS AppROS APP 与 android app 大体上无异，不同之处就在上面刚提到的app中的sdk部分创建的进程间通信渠道，另一不同之处在于清单文件中加了几个标识，以表明这是个ROS的场景，场景的名称叫什么，这些信息会被core收集，从而用来对其进行管理。 总之，不错。 腾讯小薇 腾讯小薇是私以为就是个智能音箱方案，强用来做机器人略显不合适，具体结构见上图，有个特点就是，他的场景在未创建前都是通用的模板类，创建具体的skills对象时，结合skills 类和具体的 appkit组合而成处理具体业务的skills对象。还有两点长处：一是，跨平台：其核心控制层可按不同平台编译为不同的so库（c++开发）;二是，资源优势：毕竟腾讯家的音视频资源还是很有优势的。]]></content>
      <categories>
        <category>机器人OS</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu grub 引导丢失修复]]></title>
    <url>%2F2018%2F03%2F13%2Fskill%2Fgrub%20repair%2F</url>
    <content type="text"><![CDATA[第一章 工作就得这么弄自己家的电脑，需要能写代码，也要能供不写代码的时候用，比起ubuntu来说，win10还是要好用非常多的，何况买的dell品牌台式机，win1o 是正版的，office是正版的，还有dell的一堆服务，废了多可惜啊，都是钱买的。所以一狠心，一咬牙装了个win10+ubuntu的双系统。 两年了，除了装系统的时候费了点事，一直以来大家相安无事，各过各的。ubuntu一路从16.04升级到了17.10没出过任何叉子，windows10？还好吧，一直以来也本本分分的。 直到昨天晚上，都要睡觉了，翻着墙看了个乐视网的微电影。这有毛病吗？关机的时候，点错了，关机按钮点到了重启上，这有毛病吗？然后就重启了，然后就没出现grub的引导，直接进入了win10。心里暗骂一句，微软流氓，肯定是悄悄升级了，还改了efi文件。多大点事啊，上网找个攻略修一下也就好了，遂找了一篇，照着鼓捣。这次倒好，直接提示，没有可引导的设备。 第二章 那无眠的夜说来网上的文章也有些坑人，绝大多数都是legacy+mbr引导，对于uefi+gpt方式的引导，真是少，或者是怪我瞎？从11点弄到凌晨3、4点，尝试了无数遍easybcd，easyefi都没整成，放弃了，睡觉吧，反正现在都没有可引导的设备了。 第三章 需要一个livecd 启动盘还好，找着一个U盘，还好，里面还有个ubuntu系统。感谢Startup Disk createor ！！！ 第四章 执行命令在坚持不起作用时，最好的方法是睡觉。觉醒后，从uefi u盘启动，执行如下命令： 1sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get update 有提示，按回车 1sudo apt-get install -y boot-repair &amp;&amp; boot-repair 等一会，执行界面上的recommended repair 等着吧，一会就好了。当然也不能干等着，人家提示你forword的时候你就forword，提示打开终端执行命令，你就把他提示的命令复制到终端里执行一遭。若是失败了？那你就按他说的再做一遍也就成了。 第五章 大功告成撒花，撒花，看到grub 了，就是里边的内容有点多，那就进入ubuntu，必须说一下，还是ubuntu用起来顺手啊，关键是方便，进/boot分区下，把那些不会再用到的内核删了，然后执行 1sudo update-grub 至此算是搞定了，记录一下，以兹纪念！]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android O 电源管理之从设备唤醒谈起]]></title>
    <url>%2F2018%2F03%2F11%2Fandroid%2Fpower%20wakeup%2F</url>
    <content type="text"><![CDATA[为何从此谈起andoird PowerManagerService 中有一个成员变量mWakefulness，其定义如下： 123// Indicates whether the device is awake or asleep or somewhere in between.// This is distinct from the screen power state, which is managed separately.private int mWakefulness; 注释写的很明白，用来指示当前设备是醒是睡还是处于半醒半睡间的某中状态，本文即从此处讲起。 无论设备电源状态如何变化，走了多少曲折的流程，最终会层层调用到对该变量的修改，用以指示设备电源变化后的状态，设备唤醒也不例外。常见的分析电源管理的文章多分析电源管理的框架结构及调用流程，鲜有对唤醒后，睡眠前其他模块所做工作的描述。本篇即主要阐述设备从睡眠状态唤醒，设置mWakefulness为WAKEFULNESS_AWAKE后，整个系统都做了些什么。 摸着代码过河起点则从setWakefulnessLocked开始，至于是从何处调用过来的，以后再说，其源码如下： 123456789private void setWakefulnessLocked(int wakefulness, int reason) &#123; if (mWakefulness != wakefulness) &#123; mWakefulness = wakefulness; mWakefulnessChanging = true; mDirty |= DIRTY_WAKEFULNESS; //定义于frameworks/base/services/core/java/com/android/server/power/Notifier.java中 mNotifier.onWakefulnessChangeStarted(wakefulness, reason); &#125;&#125; 可见mWakefulness修改之后一方面标记了wakefulness修改过（mWakefulnessChanging 和 mDirty 的标记将在updatePowerStateLocked 函数中做为wakefulness修改过的证据）；一方面则调用了mNotifier的方法 onWakefulnessChangeStarted，在这个方法的后面就是android系统的一些核心服务对电源状态变化的响应了。 哪些service会做出响应那些直接响应了interactive变化的manager先摘录Notifier的注释如下以说明它是何物： 123456789101112131415161718/** * Sends broadcasts about important power state changes. * &lt;p&gt; * This methods of this class may be called by the power manager service while * its lock is being held. Internally it takes care of sending broadcasts to * notify other components of the system or applications asynchronously. * &lt;/p&gt;&lt;p&gt; * The notifier is designed to collapse unnecessary broadcasts when it is not * possible for the system to have observed an intermediate state. * &lt;/p&gt;&lt;p&gt; * For example, if the device wakes up, goes to sleep, wakes up again and goes to * sleep again before the wake up notification is sent, then the system will * be told about only one wake up and sleep. However, we always notify the * fact that at least one transition occurred. It is especially important to * tell the system when we go to sleep so that it can lock the keyguard if needed. * &lt;/p&gt; */final class Notifier 再摘录onWakefulnessChangeStarted的注释如下以说明它将作何用处： 1234567/** * Notifies that the device is changing wakefulness. * This function may be called even if the previous change hasn't finished in * which case it will assume that the state did not fully converge before the * next transition began and will recover accordingly. */public void onWakefulnessChangeStarted(final int wakefulness, int reason) 此方法一进来先判断了下变化后的wakefulness是否为可交互的状态，判断的标准则是wakefuleness是否为WAKEFULNESS_AWAKE 或是 WAKEFULNESS_DREAMING，也就是说设备在唤醒状态及屏保状态，系统认为设备处在一种可交互的状态下。本篇主要分析的是AWAKE后的事，所以将略过变为其他状态时的处理。 ActivityManager的响应12345678// Tell the activity manager about changes in wakefulness, not just interactivity.// It needs more granularity than other components.mHandler.post(new Runnable() &#123; @Override public void run() &#123; mActivityManagerInternal.onWakefulnessChanged(wakefulness); &#125;&#125;); 在唤醒后，ActivityManager将调用到方法updateSleepIfNeededLocked，此方法根据当前是否是睡眠及接下来是否应该睡眠作为判断条件（是否应该继续睡眠由传入的wakefulness，及是否是语音交互，当前是否显示键盘锁等条件综合判定），因此处讨论的是唤醒后大家都做了什么，所以唤醒后假定也没有键盘锁，也没有像屏保等的阻止栈顶activity进入可交互状态的sleepToken，也就是说可以顺利往下执行唤醒操作的情况下，ActivityManager 做了如下操作 修改当前不再是睡眠状态 重新跟踪resumed activity的时长。 设置当前栈顶activity所在进程状态为PROCESS_STATE_TOP 标记activities的sleep状态为false，该操作将触发调用onStart，之后会调用在休眠前正处于pausing状态的activity走完pause流程 如果是VR模式，则通知VRManagersleep状态为false 调用updateOomAdjLocked 接下来的执行，只有在交互状态确实改变的情况下（保存的是否为交互状态与本次wakefulness改变判定的状态是否一致）才会继续进行。执行主要涉及的是WindowManagerPolicy。 WindowManagerPolicy的响应继续之前的流程，假定现在交互的状态确实发生了变化（根据本次修改wakefulness的值判断得到的interactive与保存的mInteractive的值不同）。 假设此次的交互状态变化时，上次的变化还未结束，（再次提醒，我们讨论的是唤醒后的系统响应，即之前的交互状态为false），则会先完成上一次的交互状态改变，调用了WindowManagerPolicy的finishGoingToSleep方法，具体做了如下操作： 标记“正在进入sleep”这个状态为false。 开始接收手势传感器的事件以使能手势唤醒功能。 disable 方向传感器 重新计算锁屏界面超时时间 调用键盘锁服务的onFinishedGoingToSleep方法，并标注键盘锁交互状态为INTERACTIVE_STATE_SLEEP 将在sleep状态时可使用camera手势（双击电源键唤醒相机）的标记置为false。 之后，修改PowerManagerService内部的mInteractive为true，然后调用WindowManagerPolicy的startWakeingUp方法，具体做了的操作如下： 标记 awake 状态为 true。 不再接收手势传感器事件以diable调手势唤醒功能 enable方向传感器 调用键盘锁服务的onStartedWakingUp方法，并标记键盘锁交互状态为INTERACTIVE_STATE_AWAKE InputManager 的响应看到的只是将native层InputManagerService中的mInteractive置为了true。因为在sleep的时候置为了false，而mInteractive应该会影响到是否对输入进行响应。 InputMethodManager 的响应 设置了可交互状态为true。 更新systemui 决定是否要显示输入法 设置输入法为interactive为true。 BatteryStats 的响应 设置可交互状态标记为true 启动mInteractiveTimer 响应ACTION_SCREEN_ON的系统组件以上各相关manager处理完之后，Notifier 还会发送出Intent.ACTION_SCREEN_ON 广播，一些系统服务收到后会做一些操作 AlarmManagerService 处理那些在休眠阶段到时间但是nonWakeup的闹钟 更新例如最大延迟时间等变量的值AudioService 使能RotationHelper，这样屏幕旋转时可调节双speaker方案的左右声音输入，sleep的时候会disable掉RotationHelper以减少由于屏幕方向变化导致的唤醒 向底层audio device设置screenState参数为on，用来修改声音输出帧率FMRadioService退出FM的低电模式GestureManagerServicestop gesture service when screen on and unregister pocket sensorGnssLoctionProvider退出gps的低电模式 还有一些其他的service也在响应ACTION_SCREEN_ON，此处就不一一列出了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android包管理之App安装前的校验]]></title>
    <url>%2F2018%2F02%2F06%2Fandroid%2Fpackage%20verify%2F</url>
    <content type="text"><![CDATA[初识Package Verification之前在做机器人操作系统的时候有过这样的需求，希望在安装应用的时候判断该应用是否符合机器人系统的操作规范，说白了就是需要扫描一下这个apk，是否符合某些规则。当然，这个需求可以在andoird 安装应用的过程实现。但是查看源码发现了Package Verification，这是一个没有多少文档介绍也没有相应demo的特性。 最近在做车机系统的时候，大家讨论热修复，聊到在海外渠道以及一些海外应用商店平台上，禁止带有热修复功能的应用上架，甚至带有热修复功能的app安装都不会成功。聊到此处想起了Package Verification，料想使用此特性实现的。早在android J 中就在PackageManagerService源码中加入了此特性。大体思路是，在安装应用前会发送一个需要对此包进行验证的广播，该广播可叫做Verify Request，如果系统中有实现了该广播的Receiver，则该应用被叫做Verifier，则Verifier取得广播中携带的附属信息，包括包的路径等，则通过或是扫描该包或是对比其他信用，总之对要安装的这个应用做出校验，然后调用PowerManager的接口告诉PowerManagerService 本次校验是否通过，通过则继续执行安装过程，否则提示用户安装被拒绝。也可以讲，android通过这样的方式，将android包安装校验这一任务外包给了第三方应用（通常为应用商店等）进行校验。比如校验不通过会弹出如下的界面(就算没见过这个，也见过类似的吧)： 使用Package VerificationVerify 流程如下： 其中verifier 检查要安装的应用这个子过程即可实现为一个独立应用，在其中做具体的校验逻辑。 ## Verify 过程中使用到的PackageManager API ### [请求对即将安装的包进行验证](#请求) PackageManagerService 会在应用安装前发送ACTION_PACKAGE_NEEDS_VERIFICATION 广播请求对要安装的包进行验证，它会携带PowerManager.EXTRA_VERIFICATION_ID 待Verifier验证结束后会使用该ID通知PackageManagerService验证结果。 另外几个在API中被hide的附属值为： - EXTRA_VERIFICATION_URI - EXTRA_VERIFICATION_INSTALLER_PACKAGE - EXTRA_VERIFICATION_INSTALL_FLAGS - EXTRA_VERIFICATION_INSTALLER_UID - EXTRA_VERIFICATION_PACKAGE_NAME - EXTRA_VERIFICATION_VERSION_CODE 另外，应用程序也可在自己的manifest中使用标签来指定Verifier 例如： 123&lt;package-verifier android:name="org.mycompany.verifier" android:publicKey="Zm9vYmFy..." /&gt; 这类Verifier被叫做Sufficient Verifiers，配置中的publickey 为 应用安装完成后在/data/system/package.xml 中保存的对应应用的编码。 Verifier 的实现Verifier 需要具有权限PACKAGE_VERIFICATION_AGENT，然后实现接受ACTION_PACKAGE_NEEDS_VERIFICATION广播的BroadcastReceiver。待校验结束后调用PackageManager.verifyPendingInstall 返回校验结果，结果常量为： PowerManager.VERIFICATION_ALLOW PowerManager.VERIFICATION_REJECT结果返回后会被PackageManagerService处理响应 Package Verification 机制实现分析。Package Verification 机制的实现在PackageManagerService中，与应用的安装过程紧紧的结合在一起，但此处不在介绍安装过程。当安装进行到函数startCopy这一步时，在handleStartCopy方法中有如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192if (ret == PackageManager.INSTALL_SUCCEEDED) &#123; // TODO: http://b/22976637 // Apps installed for "all" users use the device owner to verify the app UserHandle verifierUser = getUser(); if (verifierUser == UserHandle.ALL) &#123; verifierUser = UserHandle.SYSTEM; &#125; /* * Determine if we have any installed package verifiers. If we * do, then we'll defer to them to verify the packages. */ // mRequiredVerifierPackage 和 mOptionalVerifierPackage在 // PackageManagerService初始化时初始化 final int requiredUid = mRequiredVerifierPackage == null ? -1 : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, verifierUser.getIdentifier()); final int optionalUid = mOptionalVerifierPackage == null ? -1 : getPackageUid(mOptionalVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, verifierUser.getIdentifier()); final int installerUid = verificationInfo == null ? -1 : verificationInfo.installerUid; if (!origin.existing &amp;&amp; (requiredUid != -1 || optionalUid != -1) &amp;&amp; isVerificationEnabled( verifierUser.getIdentifier(), installFlags, installerUid)) &#123; // 开始构造请求Verify的广播的Intent final Intent verification = new Intent( Intent.ACTION_PACKAGE_NEEDS_VERIFICATION); verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)), PACKAGE_MIME_TYPE); verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // Query all live verifiers based on current user state // 把当前所有能做校验的Receiver都找出来。 final List&lt;ResolveInfo&gt; receivers = queryIntentReceiversInternal(verification, PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier()); if (DEBUG_VERIFY) &#123; Slog.d(TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers"); &#125; // 生成此次的verificationId，用来唯一标识此次校验 final int verificationId = mPendingVerificationToken++; // 添加需要携带给Verifier 的数据 verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId); verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE, installerPackageName); verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS, installFlags); verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME, pkgLite.packageName); verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE, pkgLite.versionCode); if (verificationInfo != null) &#123; if (verificationInfo.originatingUri != null) &#123; verification.putExtra(Intent.EXTRA_ORIGINATING_URI, verificationInfo.originatingUri); &#125; if (verificationInfo.referrer != null) &#123; verification.putExtra(Intent.EXTRA_REFERRER, verificationInfo.referrer); &#125; if (verificationInfo.originatingUid &gt;= 0) &#123; verification.putExtra(Intent.EXTRA_ORIGINATING_UID, verificationInfo.originatingUid); &#125; if (verificationInfo.installerUid &gt;= 0) &#123; verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID, verificationInfo.installerUid); &#125; &#125; // 创建PackageVerificationState 对像用来跟踪校验状态。 final PackageVerificationState verificationState = new PackageVerificationState( requiredUid, args); // 把verificationState保存起来，方便以后查找使用。 mPendingVerification.append(verificationId, verificationState); // 获取到sufficientVerifiers，上文提到过，其中pkgLite经过解析manifest而来 final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite, receivers, verificationState); // 这里应该是android6.0 后添加的，避免在校验的过程中系统进入休眠。 DeviceIdleController.LocalService idleController = getDeviceIdleController(); final long idleDuration = getVerificationTimeout(); /* * If any sufficient verifiers were listed in the package * manifest, attempt to ask them. */ if (sufficientVerifiers != null) &#123; final int N = sufficientVerifiers.size(); if (N == 0) &#123; Slog.i(TAG, "Additional verifiers required, but none installed."); ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; &#125; else &#123; for (int i = 0; i &lt; N; i++) &#123; final ComponentName verifierComponent = sufficientVerifiers.get(i); // 与doze模式相关，避免休眠 idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier"); final Intent sufficientIntent = new Intent(verification); sufficientIntent.setComponent(verifierComponent); // 发送验证请求 mContext.sendBroadcastAsUser(sufficientIntent, verifierUser); &#125; &#125; &#125; if (mOptionalVerifierPackage != null) &#123; final Intent optionalIntent = new Intent(verification); optionalIntent.setAction("com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"); final List&lt;ResolveInfo&gt; optional_receivers = queryIntentReceiversInternal(optionalIntent, PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier()); final ComponentName optionalVerifierComponent = matchComponentForVerifier( mOptionalVerifierPackage, optional_receivers); optionalIntent.setComponent(optionalVerifierComponent); verificationState.addOptionalVerifier(optionalUid); if (mRequiredVerifierPackage != null) &#123; mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT); &#125; else &#123; mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION); msg.arg1 = verificationId; mHandler.sendMessageDelayed(msg, getVerificationTimeout()); &#125; &#125;, null, 0, null, null); mArgs = null; &#125; &#125; final ComponentName requiredVerifierComponent = matchComponentForVerifier( mRequiredVerifierPackage, receivers); if (ret == PackageManager.INSTALL_SUCCEEDED &amp;&amp; mRequiredVerifierPackage != null) &#123; Trace.asyncTraceBegin( TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId); /* * Send the intent to the required verification agent, * but only start the verification timeout after the * target BroadcastReceivers have run. */ verification.setComponent(requiredVerifierComponent); idleController.addPowerSaveTempWhitelistApp(Process.myUid(), mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier"); // 之前基础发送给各种verifier 进行校验，最后发送给required的verifier进行校验 mContext.sendOrderedBroadcastAsUser(verification, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() &#123; // 此处巧妙，此Receiver做为orderedBroadcast的最后一站，将接收到intent。 @Override public void onReceive(Context context, Intent intent) &#123; final Message msg = mHandler .obtainMessage(CHECK_PENDING_VERIFICATION); msg.arg1 = verificationId; // 延时发送校验结束的消息，即超时时间到后发送校验结束，由于未携带 // 校验结果，将被判定为REJECT. mHandler.sendMessageDelayed(msg, getVerificationTimeout()); &#125; &#125;, null, 0, null, null); /* * We don't want the copy to proceed until verification * succeeds, so null out this field. */ mArgs = null; &#125; &#125; else &#123; /* * No package verification is enabled, so immediately start * the remote call to initiate copy using temporary file. */ ret = args.copyApk(mContainerService, true); &#125;&#125;mRet = ret; 以上为发送校验请求，当校验结束后会需要调用verifyPendingInstall 方法通知PackageManagerService 校验结束了，该方法会发送消息PACKAE_VERIFIED给PackageManagerService的PackageHandler.handleMessage 处理，处理流程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case PACKAGE_VERIFIED: &#123; final int verificationId = msg.arg1; final PackageVerificationState state = // 通过verificationId 取得 校验状态对象，该对象用来跟踪校验过程的状态变化。 mPendingVerification.get(verificationId); if (state == null) &#123; Slog.w(TAG, "Invalid verification token " + verificationId + " received"); break; &#125; final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj; // 更新校验状态，会根据calleruid来判断是那个verifier校验的结果。 state.setVerifierResponse(response.callerUid, response.code); if (state.isVerificationComplete()) &#123; mPendingVerification.remove(verificationId); final InstallArgs args = state.getInstallArgs(); final Uri originUri = Uri.fromFile(args.origin.resolvedFile); int ret; if (state.isInstallAllowed()) &#123; ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR; // 校验通过会通知下verifier们校验最终通过了，大家都安心，其实没啥用。 broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser()); try &#123; // 继续安装流程 ret = args.copyApk(mContainerService, true); &#125; catch (RemoteException e) &#123; Slog.e(TAG, "Could not contact the ContainerService"); &#125; &#125; else &#123; // 校验失败，返回安装失败的结果。 ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; &#125; Trace.asyncTraceEnd( TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId); processPendingInstall(args, ret); mHandler.sendEmptyMessage(MCS_UNBIND); &#125; break;&#125; 整个校验的流程其实挺简单的，实际上就是在应用安装的过程中横插了一杠，发送了请求校验的广播出去，然后停止安装，等着有能力校验的应用校验完成后，根据校验的结果继续完成安装过程。至于校验者应用，官方文档介绍，GooglePlay实现了这一校验功能，据说是会扫描采集安装包的信息到Google的后台按照一些规则计算衡量后判定是否符合安装的要求，这大概就是一些应用海外版不能具有某种“黑科技技术”实现的原因吧，因为人家的机子上都有GooglePlay对这些应用进行检查。实际上现在国内许多手机厂商都会实现自己的Verifier，例如我使用的华为P9在安装一些应用的时候，华为的应用商店也会进行校验，然后弹出类似文章开头处的界面。 参考其他人介绍Package Verifiers的文章Android Internals: Package Verifiers Package安装过程The following process executes in Package Manager Service. Waiting Add a package to the queue for the installation process Determine the appropriate location of the package installation Determine installation Install / Update new Copy the apk file to a given directory Determine the UID of the app Request the installd daemon process Create the application directory and set permissions Extraction of dex code to the cache directory To reflect and packages.list / system / data / packages.xml the latest status Broadcast to the system along with the name of the effect of the installation is complete package Intent.ACTION_PACKAGE_ADDED: If the new ( Intent.ACTION_PACKAGE_REPLACED): the case of an update 流程如下图： PackageManager 详细介绍： In Depth: Android Package Manager and Package Installer Android パッケージインストール処理のしくみを追うst=>start: Start e=>end: end install=>operation: PackageManagerService 调用到handleStartCopy方法 verifierOk=>condition: 获取系统中存在的Verifier,判断系统中是否存在Verifier。 completeInstall=>operation: PackageManagerService完成安装 requestVerify=>operation: 发出广播ACTION_PACKAGE_NEEDS_VERIFICATION，设置最大验证超时时长 timeout=>condition: 是否超时 verify=>subroutine: Verifier 接收到ACTION_PACKAGE_NEEDS_VERIFICATION广播并检查要安装的应用 verifyResult=>condition: app是否允许安装 verifyAllow=>operation: 调用PackageManager.verifyPendingInstall 参数为本次验证的任务ID，结果为VERIFICATION_ALLOW verifyReject=>operation: 调用PackageManager.verifyPendingInstall 参数为本次验证的任务ID，结果为VERIFICATION_REJECT handleVerifyResult=>condition: 判断返回的verify结果 stopInstall=>operation: 终止安装，提醒安装被拒绝 st->install->verifierOk verifierOk(no)->completeInstall verifierOk(yes)->requestVerify->verify->verifyResult verifyResult(no)->verifyReject->handleVerifyResult verifyResult(yes)->verifyAllow->handleVerifyResult handleVerifyResult(yes)->completeInstall handleVerifyResult(no)->stopInstall stopInstall->e completeInstall->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android O 电源管理之从automotive谈起]]></title>
    <url>%2F2018%2F02%2F04%2Fandroid%2Fpower%20automotive%2F</url>
    <content type="text"><![CDATA[android o 在源码工程/package/service/目录下新增了一个目录Car, 做为android automotive的重要组成部分，这部分可理解为在android世界的基础上，调用android的api构造出的Vehicle框架，该框架将android这一系统获得从手机迁移到目前最大的智能设备————车上的能力。从automotive 开始分析android O 的电源管理，一方面可以站在android api用户的角度，从调用逐层的深入下去直达kernel，另一方面也可以帮助理清android automotive的框架结构。对于android automotive的框架结构的更详细的介绍可以参考另外的说明，本文当然重点还是在于从头到位的串讲下android O的电源管理。 android O automotive 框架层中的电源管理Car Power Management 框架源码分析在关于Android O Vehicle的相关文章中有详细描述，此处不在赘述，上一张框架图如下： androidO automotive 中定义的AP Power 状态Android Vehicle 的电源管理概括起来两件事：同步android与车载MCU的电源状态和通过PowerManager的API控制android的电源状态。 AP 的官方文档解释：Application Processor, aka SOC. The processor chip running Android. 可以简单理解为Android系统。 车上的MCU通过gpio或数据总线等方式与AP进行沟通并对AP的电源进行管理，通过get和set属性AP_POWER_STATE的值实现. AP_POWER_STATE get的值（VMCU –&gt; AP）android O 的automotive在VehicleProperty中定义了VehicleApPowerState，其中定义了五种状态, hal在监测到车身有如下五种状态间的变化时，向AP上报变化后的状态，如下： 状态 值 说明 OFF 0 vehicle hal 不会向AP上报此状态 DEEP_SLEEP 1 vehicle hal 不会向AP上报此状态 ON_DISP_OFF 2 AP 运行但是灭屏 ON_FULL 3 AP 运行且亮屏，此时用户可交互 SHUTDOWN_PREPARE 4 电源管理请求AP关机，AP视情况进入SLEEP状态或者关机，也可以通过发送SHUTDOWN_POSTPONE请求延时关机 SHUTDOWN_PREPARE 状态携带参数 VehicleApPowerStateShutdownParam，该参数有三个取值如下： 参数 值 说明 SHUTDOWN_IMMEDIATELY 1 AP 必须立即关机，延迟关机不被允许 CAN_SLEEP 2 AP 可以使用深度睡眠来代替关机 SHUTDOWN_ONLY 3 允许延迟关机 这五种状态间的切换关系如下： AP_POWER_STATE set的值 (AP –&gt; VMCU)AP开机或其他业务需求触发或响应VMCU对AP的电源管理需求的过程中，需要向VMCU同步AP的电源变化，在VehiclePropertyType 中有如下定义: 状态 值 说明 BOOT_COMPLETE 0x1 AP 已经完成启动 DEEP_SLEEP_ENTRY 0x2 AP 正在进入deep sleep 状态 DEEP_SLEEP_EXIT 0x3 AP 正在退出deep sleep 状态 SHUTDOWN_POSTPONE 0x4 AP 请求延时关机，单次最大支持5000ms SHUTDOWN_START 0x5 AP 正在关机，可携带参数指定关机多久后开机 DISPLAY_OFF 0x6 用户请求关闭显示 DISPLAY_ON 0x7 用户请求打开显示 以上为automotive 部分的电源管理，automotive 部分说明了对android电源管理的请求从VMCU来或者从调用Car接口来。但是automotive 对电源管理请求最终的处理，还得到android系统中，再进一步到kernel中去。 Android 电源管理automotive 通过调用 PowerManager的API实现对Android的电源管理，android 系统的电源管理牵涉的模块非常的多，但是其主要框架是以PowerManagerService核心的，PowerManagerService 做为系统Service与其他系统Service 一起在SystemServer中被初始化。 android 的电源管理整体框架 由图可知，电源管理框架可分为如下基层： 应用层：例如Vehicle的电源管理、设置等其他应用等。 Framework层：主要实现android电源管理的策略，负责调度和通知其他模块对电源管理做出响应。主要分为JavaFramework 和以com_android_server_power_PowerManagerService.cpp为核心的nativeFramework。 HAL层：主要包含传统的hardware_legacy中的power.c和android O 新增的Vendor Interface 对应的Hardware/Interface/Power 中的power.hal 部分。 Kernel层：主要包含linux的电源管理策略，以及对suspend lock的控制和reboot系统调用。PowerManagerService 的基本结构 automotive 中调用到的PowerManager相关部分主要在SystemInterfaceImpl中 API 说明 shutdown Turn off the device goToSleep Forces the device to go to sleep PARTIAL_WAKE_LOCK Ensures that the CPU is running; the screen and keyboard backlight will be allowed to go off FULL_WAKE_LOCK Ensures that the screen and keyboard backlight are on shutdown 会依次调用到 goToSleep调用goToSleep的时候第三个参数为GO_TO_SLEEP_FLAG_NO_DOZE(Go to sleep flag: Skip dozing state and directly go to full sleep)这里提到的Doze 模式,是android 6.0 后新增的特性 如上图：Doze模式提供一个复发的maintenance window给app去使用网络和处理挂起的操作Doze 模式下的限制: 网络访问功能被关闭 系统会忽略wake locks，即app无法持续占有电源 标准闹钟 AlarmManager（包括setExact()和setWindow()）都会被延时到下一个maintenance window才激活3.1. 如果app仍需要在Doze时使闹钟生效，可以使用setAndAllowWhileIdle()或setExactAndAllowWhileIdle()3.2. 使用函数setAlarmClock()设置的闹钟在Doze时仍会生效，系统会在闹钟生效前推出Doze。 系统不会进行Wi-Fi扫描 系统不允许异步Adapters运行 系统不允许JobScheduler运行 Doze 主要由DeviceIdleController实现，在DeviceIdleController中通过设备逐渐的满足条件，使得系统一步步的进入到doze状态下，流程如下图(android O貌似与此图有些微不同)： 分析源码可知，goToSleep 的实现最终也是依赖WakeLock锁来实现的，实现的流程先省略。且往下看。 WakeLock这里主要用到了两种锁如下 锁 cpu display keyboard 电源键影响 PARTIAL_WAKE_LOCK = 0x00000001 On off off 不受 FULL_WAKE_LOCK = 0x0000001a On Bright On 受 android 中其他锁的定义如下表： 锁类型 cpu display keyboard 电源键影响 备注 PARTIAL_WAKE_LOCK = 0x00000001 on off off 不受 SCREEN_DIM_WAKE_LOCK = 0x00000006 on dim off 受 SCREEN_BRIGHT_WAKE_LOCK = 0x0000000a on bright off 受 FULL_WAKE_LOCK = 0x0000001a on bright off 受 PROXIMITY_SCREEN_OFF_WAKE_LOCK = 0x00000020 距离传感器导致的灭屏后on，否则可正常off 距离传感器检测到有物体off,否则on off 受 需要设备支持距离传感器，不能和ACQUIRE_CAUSES_WAKEUP一起用 DOZE_WAKE_LOCK = 0x00000040 off off off 受 系统支持doze DRAW_WAKE_LOCK = 0x00000080 on off off 不受 windowManager允许应用在dozing状态绘制屏幕 配合锁使用的两个flag flag 说明 备注 ACQUIRE_CAUSES_WAKEUP = 0x10000000 正常情况下，获取wakelock是不会唤醒设备的，加上该标志之后，acquire wakelock也会唤醒设备 不能和PARTIAL_WAKE_LOCK 一起用 ON_AFTER_RELEASE = 0x20000000 和用户体验有关，当wakelock释放后如果没有该标志，屏幕会立即黑屏，如果有该标志，屏幕会亮一小会然后在黑屏。 不能和PARTIAL_WAKE_LOCK 一起用 对于锁的使用无非就是两种操作，acquire和release。对于这两个过程，见如下流程图： WakefulnessPowerManagerService 中的 mWakefulness 用来指示当前设备所处的状态，它有四种取值 Wakefulness 值 说明 WAKEFULNESS_ASLEEP 0 表示系统当前处于休眠状态，只能通过调用wakeup()唤醒 WAKEFULNESS_AWAKE 1 表示系统当前处于正常运行状态 WAKEFULNESS_DREAMING 2 表示系统当前处于屏保状态 WAKEFULNESS_DOZING 3 表示系统当前处于“Doze”状态，在该状态只有低功耗的屏保可以运行，其他应用进程将被挂起 在PowerManagerService 中无论是开关机，还是影响电源管理的用户行为（UserActivity）的管理，还是对wakelock锁的使用，（PowerManagerService中有两个很重要的底层SuspendBlockerLock:CPU锁————PowerManagerService.WakeLocks和Display锁————PowerManagerService.Display，系统通过向设备节点文件/sys/power/wake_lock 和 /sys/power/wake_unlock写入这两个锁的名字来控制cpu和display），最终都会调用到一个很重要的方法updatePowerStateLocked，该方法是整个PowerManagerService的核心。其大体调用逻辑如下： Android HAL 及更底层的电源管理Android的电源管理提出wakelock的是一套全新的机制，借用C++里智能指针思想来设计电源的使用和分配。wake_lock保持使用计数，只不过这种“智能指针”的所使用的资源不再是内存，而是电量。应用程序会通过特定的WakeLock去访问硬件，然后硬件会根据引用计数是否为0来决定是不是需要关闭这一硬件的供电。 这种机制在SuspendBlockerImpl 中实现，通过对mReferenceCount的判断是否调用nativeAcquireSuspendBlocker和nativeReleaseSuspendBlocker, 底层调用通过向设备节点文件/sys/power/wake_lock 和 /sys/power/wake_unlock 里写入锁的名字实现对对应设备是否休眠的操作。 PowerManagerService 对应的 hardware interface位置： hardware/interface/power/1.0/ 其中IPower.hal 提供如下四个接口： setInteractive(bool interactive) 设置系统是否交互状态，通常亮灭屏调用 powerhint(Powerhint hint, int32_t data) 调整cpu频率等参数时用来传递hint setFeature(Feature feature, bool activate) 用来使能实际的feature getPlatformLowPowerStats()generates(vec), statuss retval); 参考资源linux 电源管理相关blog: 电源管理子系统 st=>start: Start A=>operation: PowerManagerService.BinderService.shutdown B=>operation: PowerManagerService.shutdownOrRebootInternal C=>operation: ShutdownThread.shutdown D=>operation: shutdownInner E=>operation: beginShutdownSequence F=>operation: 在ShutdownThread的run方法中 AMS PMS 等Service的shutdown方法做清理工作 G=>operation: PowerManagerService.lowLevelShutdown 修改属性sys.powerctl值为shutdown H=>operation: property_service 监测到属性变化后最终调用到init.cpp中的property_changed] I=>operation: 调用reboot.cpp的HandlePowerctlMessage->DoReboot中进行一些清理工作->RebotSystem 最终调用系统调用reboot e=>end: End st->A->B->C->D->E->F->G->H->I->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O Vehicle之Car Service]]></title>
    <url>%2F2018%2F02%2F03%2Fandroid%2Fcarservice%2F</url>
    <content type="text"><![CDATA[Car Service 是 android O automotive 的核心实现。第一承担部分具体业务逻辑，第二向上为Car API 提供支撑，第三向下调用android api 或者调用 Vehicle Hal 获取车辆数据，控制车辆行为。 CarService层的构建CarServiceCar Service层的入口实现为CarService 类。CarService 继承自Service，主要初始化在onCreate中 12345678910111213141516171819202122232425public void onCreate() &#123; Log.i(CarLog.TAG_SERVICE, "Service onCreate"); mCanBusErrorNotifier = new CanBusErrorNotifier(this /* context */); mVehicle = getVehicle(null /* Any Vehicle HAL interface name */); if (mVehicle == null) &#123; throw new IllegalStateException("Vehicle HAL service is not available."); &#125; try &#123; mVehicleInterfaceName = mVehicle.interfaceDescriptor(); &#125; catch (RemoteException e) &#123; throw new IllegalStateException("Unable to get Vehicle HAL interface descriptor", e); &#125; Log.i(CarLog.TAG_SERVICE, "Connected to " + mVehicleInterfaceName); mICarImpl = new ICarImpl(this, mVehicle, SystemInterface.getDefault(this), mCanBusErrorNotifier); mICarImpl.init(); SystemProperties.set("boot.car_service_created", "1"); linkToDeath(mVehicle, mVehicleDeathRecipient); super.onCreate();&#125; 其中主要初始化两个对象 mVehicle 与 mICarImpl。mVehicle 是 VehicleHal 在客户端（针对HAL层来说的客户端）的代理对象，它的类型为IVehicle,其实质是一个IVehicle.Proxy 对象。之后会通过此成员变量与VehicleHal进行跨进程的通信；mICarImpl 是 ICarImpl 类的实例，ICarImpl才是CarService中众多manager的真正创建着和管理者。 ICarImplICarImpl 继承自ICar.Stub，是CarService的具体实现，也作为Car API对应的真实的Service端提供服务。在CarService 类的 OnCrate方法中，先是创建了mICarImpl对象，之后调用了该对象的init方法。接下来依次分析这两个过程。ICarImpl的构造函数方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public ICarImpl(Context serviceContext, IVehicle vehicle, SystemInterface systemInterface, CanBusErrorNotifier errorNotifier) &#123; mContext = serviceContext; // 创建VehicleHal对象，该对象管理着各Service的HalService mHal = new VehicleHal(vehicle); mSystemActivityMonitoringService = new SystemActivityMonitoringService(serviceContext); // 电源管理服务，后续将以此为例介绍 mCarPowerManagementService = new CarPowerManagementService( mHal.getPowerHal(), systemInterface); mCarSensorService = new CarSensorService(serviceContext, mHal.getSensorHal()); mCarPackageManagerService = new CarPackageManagerService(serviceContext, mCarSensorService, mSystemActivityMonitoringService); mCarInputService = new CarInputService(serviceContext, mHal.getInputHal()); mCarProjectionService = new CarProjectionService(serviceContext, mCarInputService); mGarageModeService = new GarageModeService(mContext, mCarPowerManagementService); mCarInfoService = new CarInfoService(serviceContext, mHal.getInfoHal()); mAppFocusService = new AppFocusService(serviceContext, mSystemActivityMonitoringService); mCarAudioService = new CarAudioService(serviceContext, mHal.getAudioHal(), mCarInputService, errorNotifier); mCarCabinService = new CarCabinService(serviceContext, mHal.getCabinHal()); mCarHvacService = new CarHvacService(serviceContext, mHal.getHvacHal()); mCarRadioService = new CarRadioService(serviceContext, mHal.getRadioHal()); mCarNightService = new CarNightService(serviceContext, mCarSensorService); mInstrumentClusterService = new InstrumentClusterService(serviceContext, mAppFocusService, mCarInputService); mSystemStateControllerService = new SystemStateControllerService(serviceContext, mCarPowerManagementService, mCarAudioService, this); mCarVendorExtensionService = new CarVendorExtensionService(serviceContext, mHal.getVendorExtensionHal()); mPerUserCarServiceHelper = new PerUserCarServiceHelper(serviceContext); mCarBluetoothService = new CarBluetoothService(serviceContext, mCarCabinService, mCarSensorService, mPerUserCarServiceHelper); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; mVmsSubscriberService = new VmsSubscriberService(serviceContext, mHal.getVmsHal()); mVmsPublisherService = new VmsPublisherService(serviceContext, mHal.getVmsHal()); &#125; if (FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; mCarDiagnosticService = new CarDiagnosticService(serviceContext, mHal.getDiagnosticHal()); &#125; // Be careful with order. Service depending on other service should be inited later. // 为方便管理和遍历所有service，将所有service的引用构建为一个数组。 List&lt;CarServiceBase&gt; allServices = new ArrayList&lt;&gt;(Arrays.asList( mSystemActivityMonitoringService, mCarPowerManagementService, mCarSensorService, mCarPackageManagerService, mCarInputService, mGarageModeService, mCarInfoService, mAppFocusService, mCarAudioService, mCarCabinService, mCarHvacService, mCarRadioService, mCarNightService, mInstrumentClusterService, mCarProjectionService, mSystemStateControllerService, mCarVendorExtensionService, mCarBluetoothService, mPerUserCarServiceHelper )); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; allServices.add(mVmsSubscriberService); allServices.add(mVmsPublisherService); &#125; if (FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; allServices.add(mCarDiagnosticService); &#125; mAllServices = allServices.toArray(new CarServiceBase[0]);&#125; 构造方法主要内容就是构造了一堆的Service，并没有其他的东西。接下来看init： 12345678public void init() &#123; // 调用VehicleHal 的init方法。 mHal.init(); // 循环调用各service的init方法。 for (CarServiceBase service : mAllServices) &#123; service.init(); &#125;&#125; VehicleHal在ICarImpl中一个比较重要的角色就是VehicleHal了，官方注释如下 Abstraction for vehicle HAL. This class handles interface with native HAL and do basic parsing of received data (type check). Then each event is sent to corresponding {@link HalServiceBase} implementation. It is responsibility of {@link HalServiceBase} to convert data to corresponding CarService for CarManager API. 意思就是说 这个类是native HAL 的接口，会解析收到的数据，并把收到的每个事件都分发给对应的HalServiceBase的具体实现类，比方PowerHalService 就会接收并处理关于AP_power_STATE的相关事件。 VehicleHal 在ICarImpl中创建并被调用init方法。其构造方法如下： 123456789101112131415161718192021222324252627282930313233343536373839public VehicleHal(IVehicle vehicle) &#123; // 首先创建一个工作线程VEHICLE-HAL mHandlerThread = new HandlerThread("VEHICLE-HAL"); mHandlerThread.start(); // passing this should be safe as long as it is just kept and not used in constructor // 以下的这些service均继承自HalServiceBase mPowerHal = new PowerHalService(this); mSensorHal = new SensorHalService(this); mInfoHal = new InfoHalService(this); mAudioHal = new AudioHalService(this); mCabinHal = new CabinHalService(this); mRadioHal = new RadioHalService(this); mHvacHal = new HvacHalService(this); mInputHal = new InputHalService(this); mVendorExtensionHal = new VendorExtensionHalService(this); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; mVmsHal = new VmsHalService(this); &#125; if(FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; mDiagnosticHal = new DiagnosticHalService(this); &#125; mAllServices.addAll(Arrays.asList(mPowerHal, mSensorHal, mInfoHal, mAudioHal, mCabinHal, mRadioHal, mHvacHal, mInputHal, mVendorExtensionHal)); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; mAllServices.add(mVmsHal); &#125; if(FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; mAllServices.add(mDiagnosticHal); &#125; // 创建HalClient，与VehicleHal的通信就仰赖于此。 mHalClient = new HalClient(vehicle, mHandlerThread.getLooper(), this /*IVehicleCallback*/);&#125; VehicleHal 创建完成后，就紧接着调用了init方法，代码如下： 123456789101112131415161718192021222324252627282930313233343536public void init() &#123; // 首先获取所有支持的属性 Set&lt;VehiclePropConfig&gt; properties; try &#123; properties = new HashSet&lt;&gt;(mHalClient.getAllPropConfigs()); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Unable to retrieve vehicle property configuration", e); &#125; synchronized (this) &#123; // Create map of all properties for (VehiclePropConfig p : properties) &#123; mAllProperties.put(p.prop, p); &#125; &#125; // 然后循环遍历所有的HALService，将HALService关心的属性与Service对应起来，保存在map中 for (HalServiceBase service: mAllServices) &#123; // 获取到各HALService 所关注的property. Collection&lt;VehiclePropConfig&gt; taken = service.takeSupportedProperties(properties); if (taken == null) &#123; continue; &#125; if (DBG) &#123; Log.i(CarLog.TAG_HAL, "HalService " + service + " take properties " + taken.size()); &#125; synchronized (this) &#123; for (VehiclePropConfig p: taken) &#123; mPropertyHandlers.append(p.prop, service); &#125; &#125; properties.removeAll(taken); // 最后依次调用个HALService 的init 方法 service.init(); &#125;&#125; CarServiceBase 和 HALServiceBase在ICarImpl中管理了众多的车辆服务，这些服务均实现了CarServiceBase接口，对应的在VehicleHAL中管理着众多的HalService 这些HALService 通过VehicleHAL中的HALClient 与 HAL层通信，处理相应的属性变化，这些HALService 均继承自HALServiceBase。例如：CarPowerManagementService 对应于 PowerHalService。在上文中ICarImpl init 的时候会调用各CarService 的init 方法，VehicleHAL init 的时候也会调用各HALService 的 init 方法，以下以电源管理举例。CarPowerManagementService 的 init 方法： 123456789101112131415161718192021222324252627282930public void init() &#123; // 创建一个处理Power 业务逻辑的工作线程 synchronized (this) &#123; mHandlerThread = new HandlerThread(CarLog.TAG_POWER); mHandlerThread.start(); mHandler = new PowerHandler(mHandlerThread.getLooper()); &#125; // CarPowerManagementService 同时实现了PowerHalService.PowerEventListener接口，该i // 接口用来从PowerHalService获取AP_POWER_STATE属性变化的事件。 // mHal 即为PowerHalService mHal.setListener(this); // 以下为电源管理的业务逻辑，此处不分析 if (mHal.isPowerStateSupported()) &#123; mHal.sendBootComplete(); PowerState currentState = mHal.getCurrentPowerState(); if (currentState != null) &#123; onApPowerStateChange(currentState); &#125; else &#123; Log.w(CarLog.TAG_POWER, "Unable to get get current power state during " + "initialization"); &#125; &#125; else &#123; Log.w(CarLog.TAG_POWER, "Vehicle hal does not support power state yet."); onApPowerStateChange(new PowerState(PowerHalService.STATE_ON_FULL, 0)); mSystemInterface.switchToFullWakeLock(); &#125; mSystemInterface.startDisplayStateMonitoring(this);&#125; PowerHalService 的 init 方法如下： 123456789101112131415161718192021public synchronized void init() &#123; // mProperties 在VehicleHal 初始化时调用了各HalService的takeSupportedProperties方法 // 初始化完成，对于PowerHalService来说此处的属性为AP_POWER_STATE 和 // DISPLAY_BRIGHTNESS. for (VehiclePropConfig config : mProperties.values()) &#123; if (VehicleHal.isPropertySubscribable(config)) &#123; // 此处的mHal 为 VehicleHal，subscribeProperty 会调用到HalClient 的subscribe 方法 mHal.subscribeProperty(this, config.prop); &#125; &#125; VehiclePropConfig brightnessProperty = mProperties.get(DISPLAY_BRIGHTNESS); if (brightnessProperty != null) &#123; mMaxDisplayBrightness = brightnessProperty.areaConfigs.size() &gt; 0 ? brightnessProperty.areaConfigs.get(0).maxInt32Value : 0; if (mMaxDisplayBrightness &lt;= 0) &#123; Log.w(CarLog.TAG_POWER, "Max display brightness from vehicle HAL is invalid:" + mMaxDisplayBrightness); mMaxDisplayBrightness = 1; &#125; &#125;&#125; 由以上代码可知，在HalService 初始化的时候会订阅关心的属性变化，并且在CarPowerManagementService初始化时向PowerHalService注册了属性变化的回调，这样当VehicleHal相应的属性发生变化的时候就会回调到CarPowerManagementService的回调方法onApPowerStateChange 和 onDisplayBrightnessChange 方法了。 接下来详细讲解在CarService 这一层获取VehicleHal属性变化（get）和向VehicleHal 设置属性（set)的一系列流程。 CarService 对 VehicleHAL property的读写沿袭上文以Car Power Management 为例 CarService层读取VehicleHAL property订阅Vehicle property在 VehicleHal类的构造方法中创建了HALClient对象，HALClient对象的构造方法如下： 12345678// IVehicle 为 IVehicle.proxy 对象是 Vehicle Binder的客户端// looper 为线程名为“VEHICLE-HAL” 的线程的looper，该线程在VehicleHAL对象初始化时创建// callback 对象即为ICalImpl的实例。HalClient(IVehicle vehicle, Looper looper, IVehicleCallback callback) &#123; mVehicle = vehicle; Handler handler = new CallbackHandler(looper, callback); mInternalCallback = new VehicleCallback(handler);&#125; 在PowerHalService 的 init方法中，有如下调用 1mHal.subscribeProperty(this, config.prop); 此处的mHal 为VehicleHal 对象，VehicleHAL的subscribeProperty实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void subscribeProperty(HalServiceBase service, int property) throws IllegalArgumentException &#123; subscribeProperty(service, property, 0f, SubscribeFlags.DEFAULT);&#125;/** * Subscribe given property. Only Hal service owning the property can subscribe it. * * @param service HalService that owns this property * @param property property id (VehicleProperty) * @param samplingRateHz sampling rate in Hz for continuous properties * @param flags flags from &#123;@link android.hardware.automotive.vehicle.V2_0.SubscribeFlags&#125; * @throws IllegalArgumentException thrown if property is not supported by VHAL */ // service 为PowerHalService // property 为AP_POWER_STATE 和 DISPLAY_BRIGHTNESSpublic void subscribeProperty(HalServiceBase service, int property, float samplingRateHz, int flags) throws IllegalArgumentException &#123; if (DBG) &#123; Log.i(CarLog.TAG_HAL, "subscribeProperty, service:" + service + ", property: 0x" + toHexString(property)); &#125; VehiclePropConfig config; synchronized (this) &#123; config = mAllProperties.get(property); &#125; if (config == null) &#123; // 表示此property没被支持 throw new IllegalArgumentException("subscribe error: config is null for property 0x" + toHexString(property)); // 根据property的配置判断属性是否被订阅 &#125; else if (isPropertySubscribable(config)) &#123; SubscribeOptions opts = new SubscribeOptions(); opts.propId = property; opts.sampleRate = samplingRateHz; opts.flags = flags; synchronized (this) &#123; // 检验订阅该属性的service是否是该属性的所有者。 assertServiceOwnerLocked(service, property); mSubscribedProperties.put(property, opts); &#125; try &#123; // 调用 HalClient 的subscribe 最终去订阅该属性。 mHalClient.subscribe(opts); &#125; catch (RemoteException e) &#123; Log.e(CarLog.TAG_HAL, "Failed to subscribe to property: 0x" + property, e); &#125; &#125; else &#123; Log.e(CarLog.TAG_HAL, "Cannot subscribe to property: " + property); &#125;&#125; 接下来继续看HalClient 的 subscribe方法如下： 123456public void subscribe(SubscribeOptions... options) throws RemoteException &#123; // mVehicle 为 Vehicle Interface 的客户端，此处的mInternalCallback 为之前创 // 建HalClient 时，使用传入的VehicleHal 对象构建的VehicleCallback 对象。当订阅的属性 // 变化时会回调IVehicleCallback的方法。 mVehicle.subscribe(mInternalCallback, new ArrayList&lt;&gt;(Arrays.asList(options)));&#125; IVehicleCallback 共有三个方法： 123oneway onPropertyEvent(vec&lt;VehiclePropValue&gt; propValues);oneway onPropertySet(VehiclePropValue propValue);oneway onPropertySetError(StatusCode errorCode, int32_t propId, int32_t areaId); 响应Vehicle属性变化上文向Vehicle Interface订阅了属性，当Vehicle Interface上报数据后，会调用到IVehicleCallback的onPropertyEvent方法，该方法被VehicleHal实现。如下： 123456789101112131415161718192021222324252627282930// propValues 为当前变化了的属性值public void onPropertyEvent(ArrayList&lt;VehiclePropValue&gt; propValues) &#123; synchronized (this) &#123; for (VehiclePropValue v : propValues) &#123; // 找到在VehicleHal 初始化时绑定好的属性与处理该属性的handler。 // 对于属性AP_POWER_STATE和DISPLAY_BRIGHTNESS来说，此处的service为PowerHalService HalServiceBase service = mPropertyHandlers.get(v.prop); if(service == null) &#123; Log.e(CarLog.TAG_HAL, "HalService not found for prop: 0x" + toHexString(v.prop)); continue; &#125; service.getDispatchList().add(v); mServicesToDispatch.add(service); VehiclePropertyEventInfo info = mEventLog.get(v.prop); if (info == null) &#123; info = new VehiclePropertyEventInfo(v); mEventLog.put(v.prop, info); &#125; else &#123; info.addNewEvent(v); &#125; &#125; &#125; for (HalServiceBase s : mServicesToDispatch) &#123; // 调用HALService 的 handleHalEvents来处理Vehicle Interface的属性变化事件。 s.handleHalEvents(s.getDispatchList()); s.getDispatchList().clear(); &#125; mServicesToDispatch.clear();&#125; 对于Power Management来说，调用的是PowerHalService的handleHalEvents方法，其实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public void handleHalEvents(List&lt;VehiclePropValue&gt; values) &#123; PowerEventListener listener; synchronized (this) &#123; // 如果当前没有处理该消息的回调则将上报的事件先放入队列 if (mListener == null) &#123; if (mQueuedEvents == null) &#123; mQueuedEvents = new LinkedList&lt;&gt;(); &#125; mQueuedEvents.addAll(values); return; &#125; // mListener 为CarPowerManagementService初始化时向PowerHalService设置的listener // CarPowerManagementService 实现了该PowerEventListener // PowerEventListener 有两个方法：onApPowerStateChange 和 onDisplayBrightnessChange listener = mListener; &#125; // 分发处理该此属性变化事件 dispatchEvents(values, listener);&#125;private void dispatchEvents(List&lt;VehiclePropValue&gt; values, PowerEventListener listener) &#123; for (VehiclePropValue v : values) &#123; switch (v.prop) &#123; case AP_POWER_STATE: int state = v.value.int32Values.get(VehicleApPowerStateIndex.STATE); int param = v.value.int32Values.get(VehicleApPowerStateIndex.ADDITIONAL); // 如果为AP_POWER_STATE 则调用onApPowerStateChange listener.onApPowerStateChange(new PowerState(state, param)); break; case DISPLAY_BRIGHTNESS: int maxBrightness; synchronized (this) &#123; maxBrightness = mMaxDisplayBrightness; &#125; // 如果为DISPLAY_BRIGHTNESS 则调用onDisplayBrightnessChange listener.onDisplayBrightnessChange( (v.value.int32Values.get(0) * 100) / maxBrightness); break; &#125; &#125;&#125; 如此则回调到CarPowerManagementService中，最终完成对AP_POWER_STATE 和 DISPLAY_BRIGHTNESS属性变化的处理。 CarService 向 Vehicle Hal Interface Set 属性值。相对简单一些，已Power Management 在初始化时向Vehicle 同步启动完成状态为例 至此，CarService 以Power Management 举例的分析就结束了，各业务的Service具体实现可能不同，但是整体结构大体上是一致的。 st=>start: Start e=>end: End sendBootComplete=>operation: 调用PowerHalService的sendBootComplete VehicleHalSet=>operation: 调用VehicleHal的set方法, 使用属性IdAP_POWER_STATE,创建出VehiclePropValueStter对象 VehicleHalTo=>operation: 调用VehicleProValuesetter对象的to方法, 参数为属性的值BOOT_COMPLETE submit=>operation: to 方法中调用了submit方法, submit方法最终使用HalClient的setValue 方法将VehiclePropValue 对象设置到VehicleHal Interface层 st->sendBootComplete->VehicleHalSet->VehicleHalTo->submit->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O Vehicle之架构介绍]]></title>
    <url>%2F2018%2F02%2F03%2Fandroid%2Fvehclearch%2F</url>
    <content type="text"><![CDATA[Android Automotive 是 Android Orea 中的一个特色功能，从AOSP的代码上看，android automotive 已经包含了从app层到framework层到hal层的各层级结构。本文简单介绍 Android Orea Vehicle 的架构形式 层次结构Google automotive 给出的架构如下图。从图中看，android vehicle 可划分为三层： Car APICar API 中包含与Car 相关的各种 manager API，通过这些manager 对app提供 car service 所能提供的服务，主要实现在/packages/services/Car/car-lib/目录下 Car ServiceCar Service 是android vehicle 的主要实现，在这一层会处理部分车辆业务逻辑，并向下调用Vehicle Hal 暴露的接口。主要实现在/packages/services/Car/service/目录下 Vehicle HalVehicle Hal 主要用来定义车辆属性，并向上提供读写属性的接口，以及对属性变化注册监听的接口。厂家需实现各自自定义的Vehicle Hal.主要实现在/hardware/interfaces/automotive. 层次实现Android O 对 Vehicle 的支持除HAL层，基本都在/packages/service/Car 目录下，android 的car 架构可以理解为在android framework之上，利用android framework的android api 实现的更高级的业务框架。下面以Power managment 为例来说明这种层次结构的更详细的细节，以更好的理解Vehicle 业务框架。android automotive power managment的类图如下： CarAPICar类是Vehicle 的 API层的具体实现。Car 通过aidl最终与CarService进行进程间通信。用户可使用如下代码使用Car的API: 12345678910// 1.首先调用静态方法createCar创建Car对象Car car = Car.createCar(getContext(), mConnectionListener);// 2.连接Car service.car.connect();waitForConnection(DEFAULT_WAIT_TIMEOUT_MS);// 3.通过名字获取对应的manager对象。CarSensorManager carSensorManager =(CarSensorManager) car.getCarManager(Car.SENSOR_SERVICE);// 4.调用具体manager对象的方法carSensorManager.isSensorSupported(CarSensorManager.SENSOR_TYPE_CAR_SPEED); Car 类中有两个重要的成员变量 12private ICar mService;private final HashMap&lt;String, CarManagerBase&gt; mServiceMap = new HashMap&lt;&gt;(); mService 是CarService的客户端，ICar.aidl定义如下：1234interface ICar &#123;IBinder getCarService(in String serviceName) = 0;int getCarConnectionType() = 1;&#125; 当调用getCarManager时会调用到mService的getCarService方法，再使用service name 与返回的对应Service的IBinder对象，一同创建出client端的manager对象。 mServiceMap 用来保存getCarManager创建出的manager对象，当再次需要获取该manager时即从此map中返回。接下来CarService Android O Vehicle之Car Service]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-EventLog-Tags 说明]]></title>
    <url>%2F2018%2F01%2F08%2Fandroid%2Feventlog%2F</url>
    <content type="text"><![CDATA[简介Event Log, 官方的解释为 System diagnostic event record. System diagnostic events are used to record certain system-level events (such as garbage collection, activity manager state, system watchdogs, and other low level activity), which may be automatically collected and analyzed during system development.This is not the main “logcat” debugging log (Log)! These diagnostic events are for system integrators, not application authors.Events use integer tag codes corresponding to /system/etc/event-log-tags. They carry a payload of one or more int, long, or String values. The event-log-tags file defines the payload contents for each type code. 大概意思是说，是系统诊断事件的记录。这些事件都是系统级别事件，例如垃圾回收，ActivityManager的状态，系统看门够以及一些其他的事件。这些事件在系统开发的过程中会被自动的采集和分析。这些事件不是main debug调试log，它是给系统开发集成商看的，不是给应用开发者看的。 但是，话虽这么说，event log 同样对于应用开发者有很大的帮助，例如可以看activity manager相关的tag去了解自己应用activity，service，broadcast等的相关情况，也可以通过分析dvm_lock_sample tag来判断程序中的锁持有或等待情况。 EventLog 打印12345678910111213141516171819$ adb logcat -v threadtime -b events01-01 08:00:00.340 289 289 I auditd : type=2000 audit(0.0:1): initialized01-01 08:46:59.550 289 289 I auditd : type=1403 audit(0.0:2): policy loaded auid=4294967295 ses=429496729501-01 08:46:59.560 289 289 I auditd : type=1404 audit(0.0:3): enforcing=1 old_enforcing=0 auid=4294967295 ses=429496729510-05 00:00:00.920 362 362 I boot_progress_start: 700302-08 23:06:39.045 362 362 I boot_progress_preload_start: 917302-08 23:06:42.121 362 362 I boot_progress_preload_end: 1224802-08 23:06:42.342 925 925 I boot_progress_system_run: 1246902-08 23:06:42.815 925 925 I boot_progress_pms_start: 1294302-08 23:06:43.043 925 925 I boot_progress_pms_system_scan_start: 1317102-08 23:06:45.124 925 925 I boot_progress_pms_data_scan_start: 1525102-08 23:06:45.929 350 1003 I dc_mm : time=1486566405000;i=1;e=play;v=video/avc,720,1280,002-08 23:06:56.918 350 1004 I dc_mm : time=1486566416000;i=1;e=play;v=video/avc,720,1280,002-08 23:07:01.606 925 925 I boot_progress_pms_scan_end: 3173402-08 23:07:01.665 925 925 I boot_progress_pms_ready: 3179202-08 23:07:01.842 925 941 I battery_status: [2,2,1,2,Li-ion]02-08 23:07:01.842 925 941 I battery_level: [30,3903,371]01-07 20:01:21.759 925 1518 I force_gc: Binder01-07 20:01:22.215 925 1422 I am_proc_start: [0,5225,10089,com.songshu.gallery:sspush,service,com.songshu.gallery/.SSPushService] 如上是一段开机阶段的event log，分析可知:event log 文件格式为：timestamp PID TID log-level log-tag tag-values可将其分为两部分：第一部分，timestamp PID TID 这部分就是时间，进程ID 和线程ID相对简单，没什么好说的。第二部分，log-tag tag-values 这部分是event log的主要部分，需要重点说下。 Event Log Tag 的说明：Android 源码目录/system/core/logcat/event.logtags 文件中有对event log tags的说明，源码注释如下： 123# The entries in this file map a sparse set of log tag numbers to tag names.# This is installed on the device, in /system/etc, and parsed by logcat.# 在设备的/system/etc 目录下 可以找到所有event log tags的定义文件event-log-tags，每一个tag都有对应的tag number 和 tag name，例如： 20003 dvm_lock_sample (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6) 123# Tag numbers are decimal integers, from 0 to 2^31. (Let's leave the# negative values alone for now.)# tag number 是 0 到 2^31 的十进制整数 123456# Tag names are one or more ASCII letters and numbers or underscores, i.e.# "[A-Z][a-z][0-9]_". Do not include spaces or punctuation (the former# impacts log readability, the latter makes regex searches more annoying).## Tag numbers and names are separated by whitespace. Blank lines and lines# starting with '#' are ignored. 12345# Optionally, after the tag names can be put a description for the value(s)# of the tag. Description are in the format# (&lt;name&gt;|data type[|data unit])# Multiple values are separated by commas.# tag values 的每一个value 格式为：(|data type[|data unit]) 1234567# The data type is a number from the following values:# 1: int# 2: long# 3: string# 4: list# 5: float# data 的类型如上 12345678# The data unit is a number taken from the following list:# 1: Number of objects# 2: Number of bytes# 3: Number of milliseconds# 4: Number of allocations# 5: Id# 6: Percent# Default value for data of type int/long is 2 (bytes). data 的单位如上列表。 分析event log，举例如下，例如上文中log有这么一行： 102-08 23:07:01.842 925 941 I battery_level: [30,3903,371] 分析如下：时间： 02-08 23:07:01.842进程ID： 925线程ID： 941log level: Ilog tag: battery_levellog values: [30,3903,371]查找设备上的event-log-tags文件，找到battery_level的说明如下: 2722 battery_level (level|1|6),(voltage|1|1),(temperature|1|1) 分析values含义(level|1|6): 30 电量是30%(voltage|1|1): 3903 电压是3903(temperature|1|1): 371 温度是371 常用Event Log Tags的说明ActivityManager Num TagName 格式 功能 30001 am_finish_activity User,Token,TaskID,ComponentName,Reason 30002 am_task_to_front User,Task 30003 am_new_intent User,Token,TaskID,ComponentName,Action,MIMEType,URI,Flags 30004 am_create_task User ,Task ID 30005 am_create_activity User ,Token ,TaskID ,ComponentName,Action,MIMEType,URI,Flags 30006 am_restart_activity User ,Token ,TaskID,ComponentName 30007 am_resume_activity User ,Token ,TaskID,ComponentName 30008 am_anr User ,pid ,Package Name,Flags ,reason ANR 30009 am_activity_launch_time User ,Token ,ComponentName,time 30010 am_proc_bound User ,PID ,ProcessName 30011 am_proc_died User ,PID ,ProcessName 30012 am_failed_to_pause User ,Token ,Wanting to pause,Currently pausing 30013 am_pause_activit y User ,Token ,ComponentName 30014 am_proc_start User ,PID ,UID ,ProcessName,Type,Component 30015 am_proc_bad User ,UID ,ProcessName 30016 am_proc_good User ,UID ,ProcessName 30017 am_low_memory NumProcesses Lru 30018 am_destroy_activity User ,Token ,TaskID,ComponentName,Reason 30019 am_relaunch_resume_activity User ,Token ,TaskID,ComponentName 30020 am_relaunch_activity User ,Token ,TaskID,ComponentName 30021 am_on_paused_called User ,ComponentName 30022 am_on_resume_called User ,ComponentName 30023 am_kill User ,PID ,ProcessName,OomAdj ,Reason 杀进程 30024 am_broadcast_discard_filter User ,Broadcast ,Action,ReceiverNumber,BroadcastFilter 30025 am_broadcast_discard_app User ,Broadcast ,Action,ReceiverNumber,App 30030 am_create_service User ,ServiceRecord ,Name,UID ,PID 30031 am_destroy_service User ,ServiceRecord ,PID 30032 am_process_crashed_too_much User ,Name,PID 30033 am_drop_process PID 30034 am_service_crashed_too_much User ,Crash Count,ComponentName,PID 30035 am_schedule_service_restart User ,ComponentName,Time 30036 am_provider_lost_process User ,Package Name,UID ,Name 30037 am_process_start_timeout User ,PID ,UID ,ProcessName timeout 30039 am_crash User ,PID ,ProcessName,Flags ,Exception,Message,File,Line Crash 30040 am_wtf User ,PID ,ProcessName,Flags ,Tag,Message Wtf 30041 am_switch_user id 30042 am_activity_fully_drawn_time User ,Token ,ComponentName,time 30043 am_focused_activity User ,ComponentName 30044 am_home_stack_moved User ,To Front ,Top Stack Id ,Focused Stack Id ,Reason 30045 am_pre_boot User ,Package 30046 am_meminfo Cached,Free,Zram,Kernel,Native 内存 30047 am_pss Pid, UID, ProcessName, Pss, Uss 进程 ### 下面列举tag可能使用的部分场景： am_low_memory：位于AMS.killAllBackgroundProcesses或者AMS.appDiedLocked，记录当前Lru进程队列长度。am_pss：位于AMS.recordPssSampleLocked(am_meminfo：位于AMS.dumpApplicationMemoryUsageam_proc_start:位于AMS.startProcessLocked，启动进程am_proc_bound:位于AMS.attachApplicationLockedam_kill: 位于ProcessRecord.kill，杀掉进程am_anr: 位于AMS.appNotRespondingam_crash:位于AMS.handleApplicationCrashInneram_wtf:位于AMS.handleApplicationWtfam_activity_launch_time：位于ActivityRecord.reportLaunchTimeLocked()，后面两个参数分别是thisTime和 totalTime.am_activity_fully_drawn_time:位于ActivityRecord.reportFullyDrawnLocked, 后面两个参数分别是thisTime和 totalTimeam_broadcast_discard_filter:位于BroadcastQueue.logBroadcastReceiverDiscardLockedam_broadcast_discard_app:位于BroadcastQueue.logBroadcastReceiverDiscardLocked Activity生命周期相关的方法:am_on_resume_called: 位于AT.performResumeActivityam_on_paused_called: 位于AT.performPauseActivity, performDestroyActivityam_resume_activity: 位于AS.resumeTopActivityInnerLockedam_pause_activity: 位于AS.startPausingLockedam_finish_activity: 位于AS.finishActivityLocked, removeHistoryRecordsForAppLockedam_destroy_activity: 位于AS.destroyActivityLockedam_focused_activity: 位于AMS.setFocusedActivityLocked, clearFocusedActivityam_restart_activity: 位于ASS.realStartActivityLockedam_create_activity: 位于ASS.startActivityUncheckedLockedam_new_intent: 位于ASS.startActivityUncheckedLockedam_task_to_front: 位于AS.moveTaskToFrontLocked Power Num TagName 格式 功能 2722 battery_level level, voltage, temperature 2723 battery_status status,health,present,plugged,technology 2730 battery_discharge duration, minLevel,maxLevel 2724 power_sleep_requested wakeLocksCleared 唤醒锁数量 2725 power_screen_broadcast_send wakelockCount 2726 power_screen_broadcast_done on, broadcastDuration, wakelockCount 2727 power_screen_broadcast_stop which,wakelockCount 系统还没进入ready状态 2728 power_screen_state offOrOn, becauseOfUser, totalTouchDownTime, touchCycles 2729 power_partial_wake_state releasedorAcquired, tag ### 部分含义： battery_level: [19,3660,352] //剩余电量19%, 电池电压3.66v, 电池温度35.2℃power_screen_state: [0,3,0,0] // 灭屏状态(0), 屏幕超时(3). 当然还有其他设备管理策略(1),其他理由都为用户行为(2)power_screen_state: [1,0,0,0] // 亮屏状态(1) 下面列举tag可能使用的部分场景：power_sleep_requested: 位于PMS.goToSleepNoUpdateLockedpower_screen_state:位于Notifer.handleEarlyInteractiveChange, handleLateInteractiveChange 附录最后附上从设备的/system/etc 下获取到event-log-tags文件.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-安装和使用Cisco AnyConnect Client]]></title>
    <url>%2F2018%2F01%2F07%2Ftool%2Fanyconnect%2F</url>
    <content type="text"><![CDATA[以前使用的vpn到期了，而且最近查的挺严，原先的好多vpn都用不了了，在同事的推荐下使用矩阵研究所 自己搭建的shadowsocks翻墙上网，他提供了windows、ios、android各平台的客户端，唯独未提供linux的客户端。不过他还好支持anyconnect，所以在linux还是可以配置anyconnect client 进行使用的。配置过程记录如下，供以后参考。 安装Cisco AnyConnect Client 安装依赖包 12$ sudo apt-get update$ sudo apt-get install lib32z1 lib32ncurses5 从UCI OIT Cisco Anyconnect/Linux instruction page下载Cisco AnyConnect Client根据linux 是32位还是64位选择适合自己的版本，查看系统版本号可使用如下命令： 12$ uname -aLinux xxxx-XPS-8910 4.13.0-21-generic #24-Ubuntu SMP Mon Dec 18 17:29:16 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 将下载好的压缩包解压到你想保存的路径下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889$ tar -xzvf anyconnect-predeploy-linux-64-4.3.05017-k9.tar.gzanyconnect-4.3.05017/anyconnect-4.3.05017/vpn/anyconnect-4.3.05017/vpn/vpn_install.shanyconnect-4.3.05017/vpn/vpnagentdanyconnect-4.3.05017/vpn/vpnagentd_initanyconnect-4.3.05017/vpn/vpn_uninstall.shanyconnect-4.3.05017/vpn/anyconnect_uninstall.shanyconnect-4.3.05017/vpn/libacciscossl.soanyconnect-4.3.05017/vpn/libacciscocrypto.soanyconnect-4.3.05017/vpn/libaccurl.so.4.3.0anyconnect-4.3.05017/vpn/vpnuianyconnect-4.3.05017/vpn/cisco-anyconnect.desktopanyconnect-4.3.05017/vpn/cisco-anyconnect.menuanyconnect-4.3.05017/vpn/cisco-anyconnect.directoryanyconnect-4.3.05017/vpn/libvpnagentutilities.soanyconnect-4.3.05017/vpn/libvpncommon.soanyconnect-4.3.05017/vpn/libvpncommoncrypt.soanyconnect-4.3.05017/vpn/libvpnapi.soanyconnect-4.3.05017/vpn/libvpnipsec.soanyconnect-4.3.05017/vpn/vpnanyconnect-4.3.05017/vpn/acinstallhelperanyconnect-4.3.05017/vpn/pixmaps/anyconnect-4.3.05017/vpn/pixmaps/company-logo.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-about.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-configure.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-connect.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-disconnect.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-info.pnganyconnect-4.3.05017/vpn/pixmaps/systray_connected.pnganyconnect-4.3.05017/vpn/pixmaps/systray_disconnecting.pnganyconnect-4.3.05017/vpn/pixmaps/systray_notconnected.pnganyconnect-4.3.05017/vpn/pixmaps/systray_quarantined.pnganyconnect-4.3.05017/vpn/pixmaps/systray_reconnecting.pnganyconnect-4.3.05017/vpn/pixmaps/vpnui48.pnganyconnect-4.3.05017/vpn/pixmaps/downloader-arrow.pnganyconnect-4.3.05017/vpn/manifesttoolanyconnect-4.3.05017/vpn/ACManifestVPN.xmlanyconnect-4.3.05017/vpn/vpndownloaderanyconnect-4.3.05017/vpn/vpndownloader-clianyconnect-4.3.05017/vpn/update.txtanyconnect-4.3.05017/vpn/OpenSource.htmlanyconnect-4.3.05017/vpn/AnyConnectProfile.xsdanyconnect-4.3.05017/vpn/AnyConnectLocalPolicy.xsdanyconnect-4.3.05017/vpn/libacfeedback.soanyconnect-4.3.05017/vpn/license.txtanyconnect-4.3.05017/vpn/VeriSignClass3PublicPrimaryCertificationAuthority-G5.pemanyconnect-4.3.05017/dart/anyconnect-4.3.05017/dart/dart_install.shanyconnect-4.3.05017/dart/AMPEnabler.xmlanyconnect-4.3.05017/dart/AnyConnectConfig.xmlanyconnect-4.3.05017/dart/BaseConfig.xmlanyconnect-4.3.05017/dart/ConfigXMLSchema.xsdanyconnect-4.3.05017/dart/DARTGUI.gladeanyconnect-4.3.05017/dart/ISEPosture.xmlanyconnect-4.3.05017/dart/NetworkVisibility.xmlanyconnect-4.3.05017/dart/Posture.xmlanyconnect-4.3.05017/dart/RequestXMLSchema.xsdanyconnect-4.3.05017/dart/Umbrella.xmlanyconnect-4.3.05017/dart/cisco-anyconnect-dart.desktopanyconnect-4.3.05017/dart/cisco-anyconnect-dart.directoryanyconnect-4.3.05017/dart/cisco-anyconnect-dart.menuanyconnect-4.3.05017/dart/ciscoLogo.pnganyconnect-4.3.05017/dart/dartCustom.pnganyconnect-4.3.05017/dart/dartTypical.pnganyconnect-4.3.05017/dart/dart_uninstall.shanyconnect-4.3.05017/dart/dartclianyconnect-4.3.05017/dart/dartcli.symbolsanyconnect-4.3.05017/dart/dartuianyconnect-4.3.05017/dart/dartui.symbolsanyconnect-4.3.05017/dart/license.txtanyconnect-4.3.05017/dart/manifesttoolanyconnect-4.3.05017/dart/ACManifestDART.xmlanyconnect-4.3.05017/posture/anyconnect-4.3.05017/posture/ciscodanyconnect-4.3.05017/posture/cscananyconnect-4.3.05017/posture/ciscod_initanyconnect-4.3.05017/posture/cstubanyconnect-4.3.05017/posture/posture_install.shanyconnect-4.3.05017/posture/posture_uninstall.shanyconnect-4.3.05017/posture/libcsd.soanyconnect-4.3.05017/posture/libhostscan.soanyconnect-4.3.05017/posture/libinspector.soanyconnect-4.3.05017/posture/license.txtanyconnect-4.3.05017/posture/tables.datanyconnect-4.3.05017/posture/ACManifestPOS.xmlanyconnect-4.3.05017/posture/libaccurl.so.4.3.0anyconnect-4.3.05017/posture/libacciscocrypto.soanyconnect-4.3.05017/posture/libacciscossl.so 进入解压目录下确认文件是否完整： 12345678910111213141516171819202122232425262728293031323334$ cd anyconnect-4.3.05017/vpn/$ ls -lhtotal 12M-rwxr-xr-x 1 XXXX XXXX 14K 12月 10 2016 acinstallhelper-rw-r--r-- 1 XXXX XXXX 262 12月 10 2016 ACManifestVPN.xml-rw-r--r-- 1 XXXX XXXX 6.6K 12月 10 2016 AnyConnectLocalPolicy.xsd-rw-r--r-- 1 XXXX XXXX 83K 12月 10 2016 AnyConnectProfile.xsd-rwxr-xr-x 1 XXXX XXXX 502 12月 10 2016 anyconnect_uninstall.sh-rw-r--r-- 1 XXXX XXXX 279 12月 10 2016 cisco-anyconnect.desktop-rw-r--r-- 1 XXXX XXXX 164 12月 10 2016 cisco-anyconnect.directory-rw-r--r-- 1 XXXX XXXX 603 12月 10 2016 cisco-anyconnect.menu-rwxr-xr-x 1 XXXX XXXX 2.6M 12月 10 2016 libacciscocrypto.so-rwxr-xr-x 1 XXXX XXXX 436K 12月 10 2016 libacciscossl.so-rwxr-xr-x 1 XXXX XXXX 232K 12月 10 2016 libaccurl.so.4.3.0-rwxr-xr-x 1 XXXX XXXX 168K 12月 10 2016 libacfeedback.so-rwxr-xr-x 1 XXXX XXXX 888K 12月 10 2016 libvpnagentutilities.so-rwxr-xr-x 1 XXXX XXXX 1.6M 12月 10 2016 libvpnapi.so-rwxr-xr-x 1 XXXX XXXX 530K 12月 10 2016 libvpncommoncrypt.so-rwxr-xr-x 1 XXXX XXXX 1.7M 12月 10 2016 libvpncommon.so-rwxr-xr-x 1 XXXX XXXX 1.1M 12月 10 2016 libvpnipsec.so-rw-r--r-- 1 XXXX XXXX 13K 12月 10 2016 license.txt-rwxr-xr-x 1 XXXX XXXX 480K 12月 10 2016 manifesttool-rw-r--r-- 1 XXXX XXXX 68K 12月 10 2016 OpenSource.htmldrwxr-xr-x 2 XXXX XXXX 4.0K 12月 10 2016 pixmaps-rw-r--r-- 1 XXXX XXXX 10 12月 10 2016 update.txt-rw-r--r-- 1 XXXX XXXX 1.8K 12月 10 2016 VeriSignClass3PublicPrimaryCertificationAuthority-G5.pem-rwxr-xr-x 1 XXXX XXXX 65K 12月 10 2016 vpn-rwxr-xr-x 1 XXXX XXXX 724K 12月 10 2016 vpnagentd-rw-r--r-- 1 XXXX XXXX 2.1K 12月 10 2016 vpnagentd_init-rwxr-xr-x 1 XXXX XXXX 424K 12月 10 2016 vpndownloader-rwxr-xr-x 1 XXXX XXXX 396K 12月 10 2016 vpndownloader-cli-rwxr-xr-x 1 XXXX XXXX 24K 12月 10 2016 vpn_install.sh-rwxr-xr-x 1 XXXX XXXX 176K 12月 10 2016 vpnui-rwxr-xr-x 1 XXXX XXXX 8.4K 12月 10 2016 vpn_uninstall.sh 安装1$ sudo ./vpn_install.sh 遇到提示直接y就可以了5. 重新载入 systemd，扫描新的或有变动的单元 1sudo systemctl daemon-reload 这是vpnagented进程应该已经启动了，可使用如下方式进行检查： 12$ ps auxw | grep vpnagentd | grep -v greproot 7677 0.1 0.0 259808 12720 ? Sl 11:24 0:00 /opt/cisco/anyconnect/bin/vpnagentd 同时安装过程中设置了开机启动，时候安装开机启动检查方式如下： 123456789$ find /etc/rc?.d -type l -name "*vpnagentd*"/etc/rc2.d/K25vpnagentd/etc/rc2.d/S85vpnagentd/etc/rc3.d/K25vpnagentd/etc/rc3.d/S85vpnagentd/etc/rc4.d/K25vpnagentd/etc/rc4.d/S85vpnagentd/etc/rc5.d/K25vpnagentd/etc/rc5.d/S85vpnagentd 使用Cisco AnyConnect UI Client 翻墙 为方便以后使用添加命令别名12$ alias vpn='/opt/cisco/anyconnect/bin/vpn'$ alias vpnui='/opt/cisco/anyconnect/bin/vpnui' 或者 12345$ cat &gt;&gt; ~/.bash_aliasesalias vpn='/opt/cisco/anyconnect/bin/vpn'alias vpnui='/opt/cisco/anyconnect/bin/vpnui'^D$ _ 使用vpnui 配置anyconnect1$ vpnui 在弹出的界面中输入要连接的服务器，点击右侧的设置图标，弹出如下界面 点击 按钮【Connect Anyway】 之后按照提示依次输入从矩阵研究所获得的AnyConnect 账号和密码即可连接成功。 使用Csico AnyConnect Command Client 翻墙 To start the client from a command-line prompt in a terminal window, using the alias you made above: 1$ vpn At the VPN&gt; prompt, type connect vpn.uci.edu and press Enter. (If you get an error message about an untrusted server or certificate, you can fix that following the instructions from Robert in the section NOTE 1 - Connect-error, below.) Otherwise, you should now see: 1234567VPN&gt; connect vpn.uci.edu &gt;&gt; Please enter your UCInetID and password. 0) Default-WebVPN 1) Merage 2) MerageFull 3) UCI 4) UCIFull If you do not see this, but get a connect error instead, please see NOTE 1 - Connect Error below.3. Ignore the message about entering your UCInetID and password, for now.4. Choose one of the choices by number and press return – usually UCI or UCIFull. (See the differences in the Tunnels below.) For instance, for UCI, press 3 and hit Enter.5. Enter your UCInetID and password in the Username and Password boxes and press return.6. At the accept? [y/n]: prompt, type y and press Enter. You may get several notices the first time about the downloader performing update checks. At the end you should see a &gt;&gt; state: Connected message and a new VPN&gt; prompt. You are now connected.7. Either leave the VPN&gt; prompt open or if you want your terminal back just type quit at the VPN&gt; prompt (the connection will remain active).]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 版本控制工具之rabbitvcs]]></title>
    <url>%2F2017%2F11%2F04%2Ftool%2Frabbitvcs%2F</url>
    <content type="text"><![CDATA[新公司的文档管理居然使用ｓｖｎ，不知道适合原因．很久不用有一些忘却了.之前在win下用的是TortoiseSVN，在ubuntu下，与之及其相似的是rabbitvcs．官网地址 下面是来自官方打介绍 特性介绍NautilusSeamlessly integrates into Nautilus workflow GeditProvides menus for accessing version control tools ThunarSeamlessly integrates into Thunar workflow Command Line InterfaceAn easy to use tool to launch our dialogs SubversionSupports most Subversion functionality GitSupports most Git functionality Fully InternationalizedPartial-to-full support for 26 languages! Ubuntu安装方法1234567891011### 添加源$ sudo add-apt-repository ppa:rabbitvcs/ppa### 导入key$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 34EF4A35### 更新源$ sudo apt-get update### 安装依赖$ sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld### 安装ＲabbitVCS$ sudo apt-get install rabbitvcs-cli rabbitvcs-core rabbitvcs-gedit rabbitvcs-nautilus3### 如安装失败使用 rabbitvcs-nautilus3 替换为 rabbitvcs-nautilus 使用方法]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（九）：物联网设备的标识技术]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F9%2F</url>
    <content type="text"><![CDATA[导语物联网主要由三个方面关键技术：_连接、标识_以及_数据的操作_。 在前面的文章中，我们已经谈了很多关于物联网中物体如何连接网络的技术，而实际上物体的标识才是物联网实现的第一步，就是我们要唯一地标识和区分每一个物体。以RFID为代表的物体标识技术曾经几乎就是物联网的代名词，而今RFID的演进技术NFC又在各个领域发挥着重要作用。通过这篇文章，我们来聊一聊物联网设备的标识技术，RFID与NFC究竟有什么关系？ RFID非接触式射频识别(RFID)本质上也是一种无线通信技术，也是通过无线电磁波来传送数据。不过和一般的通信技术不一样的是它的用途，不是打电话，或者发短信，RFID主要用来识别和跟踪物体上绑定的标签，从而实现对物体的管理。 RFID技术广泛应用于仓储物流中，用于对货物进行跟踪 RFID系统使用标签（Tag）来识别物体。除了标签，RFID系统还有一个双向无线收发机，被称为读写器（Interrogator/Reader），向标签发送信号，并读取标签的反馈。 RFID系统由读写器与标签组成RFID分为被动式RFID与主动式RFID。被动RFID一般是指不带电池的无源RFID，其完全依赖于接收电磁波来驱动电路工作，标签的可识别距离不会变化。主动RFID系统一般指有源的RFID标签，其可识别距离会随着电量的减少而降低。 采用RFID技术的ETC系统让通行更加方便 主动RFID一般识别距离都比较长，比如高速公路自动收费站以及自动停车场的ETC系统，一般都采用工作于2.4GHz的主动RFID。不过ETC标签中有一个电池，要是电池没电，就需要更换电池才可以工作。 RFID标签RFID标签由集成电路（IC: Integrated Circuit）和天线两个部分组成：IC用来存储和处理数据，对RF信号进行调制和解调，另外还需要从读写器发出的信号中收集能量驱动自身工作。天线的作用就是发射和接收无线信号。 EPC码格式，EPC码可能逐渐会取代传统的UPC码，即商品条码 RFID标签中存着什么？RFID标签中存储的数据格式一般是EPC（Electronic Product Code）码。EPC码可以识别世界上所有的物体。EPC码的结构由EPCglobal Tag Data Standard标准定义，这个标准是一个公开标准，可以从EPCglobal Inc网站上面免费下载。 NFC技术说完RFID，再来说说近场通信（NFC: Near Field Communication）。NFC是目前手机非常常见的一个通信接口。可以让智能设备通过相互靠近的方式来交换数据。NFC设备也可以与一个无源的NFC标签之间进行通信，这个通信方式就和RFID是一样的。 NFC的通信方式NFC技术是由RFID技术演变而来，除了通信协议，NFC标准还规定了数据交换格式。在NFC单一芯片上结合了感应式读卡器、感应式卡片和点对点的功能，能在短距离内与兼容设备进行识别和数据交换。 NFC与RFID的区别（1）工作频段NFC可以理解为RFID技术的一个子集，使用的是13.56MHz频段，而RFID还包括其他频段。RFID的工作频段有很多，低频段有125KHz，高频段有13.56MHz，超高频段有433.92MHz、915MHz，还有微波频段的2.45GHz等。（2）通信距离NFC被称为近场通信，通信距离确实非常近，不超过0.1m。RFID种类很多，可识别距离也不一样。像RFID门禁卡，识别距离和NFC差不多。但对于ETC这种应用场景，就要求识别距离比较长。长距离RFID的识别距离可达几十米甚至上百米。（3）应用场景RFID无论主动还是被动，主要工作还是用于对物体的识别，物流、运输、仓储都广泛使用了RFID技术来跟踪货物。NFC芯片的集成度更高，包括了读卡器与标签于一体。另外NFC的双向通信能力得到了加强。也就是说，NFC不仅可以当做标签来做识别，还可以作为一种双向通信方式用于数据交换。目前NFC最常用于支付领域。 NFC技术被广泛应用于支付场景 总的来说，虽然NFC是在RFID技术基础上发展而来的，但是面向不同的应用场景，并不存在替代作用。况且现在RFID的应用场景还是非常多的，NFC暂时还比不了。即使在支付领域和近距离物体识别领域，二维码在很多场景下也能起到NFC的作用，目前对智能手机来说，NFC还不是一个必需的通信接口。如果希望了解更多关于物联网的信息，请继续关注“微说互联网”的“纵论物联网”系列。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（二）：LPWAN技术]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F2%2F</url>
    <content type="text"><![CDATA[不同的物联网技术适用于不同的应用场景。对于需要远距离大范围覆盖的场景来说，我们熟悉的蓝牙、WiFi、Zigbee这些技术都不适合，我们需要低功耗广域网（LPWAN：Low Power Wide Area Network）技术。 LPWAN技术的特点是： 覆盖远，支持大范围组网；连接终端节点多，可以同时连接成千上万的节点；功耗低，只有功耗低，才能保证续航能力，减少更换电池的麻烦；传输速率低，因为主要是传输一些传感数据和控制指令，不需要传输音视频等多媒体数据，所以也就不需要太高的速率，而且低功率也限制了传输速率。当然还有就是成本要低，这样才有应用推广的可能性。本文主要介绍一些目前比较有代表性的LPWAN技术，特别是使用免授权频段的无线技术。无线物联原本是GPRS的天下当移动蜂窝网络发展处于2G、3G和4G时代，对于需要广域覆盖的物联网应用来说，比如物流行业的车辆定位与跟踪，或者无人值守系统的故障监控，一般都采用传统的GPRS技术。但GPRS数据传输单元（DTU: Data Transfer unit）的功耗和续航能力都不够理想，而且受限于GPRS网络的覆盖，对于没有GPRS信号就没法使用GPRS来传输数据了。 GPRS的物联网应用架构图 为了应对日益强烈的物联网需求，国际电联ITU-T也在LTE以及后续的5G移动通信标准中推进适合物联网应用的广域网标准，如eMTC、NB-IoT等，目前这些新的M2M技术标准尚未达到可大规模商用的成熟度。在移动蜂窝网络面向物联网的新标准推出前，也有很多公司和组织开发了比GPRS更低功耗且容易部署的替代方案，一些方案目前正在被广泛应用中，比如LoRa，SigFox等。SigFox2009年，法国公司SigFox展示了自己的超窄带（UNB: Ultra Narrow Band）技术，被业界视为是LPWAN领域最早的开拓者。UNB技术每秒只能处理10到1000比特的数据，传输功耗水平非常低，却能支持成千上万的连接。SigFox无线链路使用免授权的ISM射频频段。频率根据国家法规有所不同，在欧洲广泛使用868MHz，在美国是915MHz。SIGFOX网络中单元的密度，在农村地区大约30-50km，在城市中常有更多的障碍物和噪声距离可能减少到3-10km之间。SigFox的UNB技术使用标准的二进制相移键控（BPSK: Binary Phase Shift Keying）的无线传输方法，采用非常窄的频谱改变无线载波相位对数据进行编码。 SigFox公司不仅是标准的制定者，同时也是网络运营者和云平台提供商，目标是与合作伙伴建造一个覆盖全球的IoT网络，独立于现有电信运营商的移动蜂窝网络。目前SigFox在欧洲已经部署了不少网络，在中国还没有部署。LoRaLoRa是美国Semtech公司推广的一种超远距离无线传输方案。2013年8月，Semtech公司发布了一种基于1GHz以下的超长距低功耗数据传输技术的芯片, LoRa是长距离（Long Range）的缩写。 其接受灵敏度达到了惊人的-148dbm，与业界其他先进水平的sub-GHz芯片相比，最高的接收灵敏度改善了20db以上，这确保了网络连接可靠性。LoRa使用线性调频扩频调制技术，工作在非授权频段，数据传输速率在0.3kbps~37.5kbps。LoRa还采用了自适应速率(ADR: Adaptive Data Rate)方案来控制速率和终端设备的发射功率，从而最大化终端设备的续航能力。LoRa与Sigfox最大的不同之处在于LoRa是技术提供商，不是网络运营商。谁都可以购买和运行LoRa设备，LoRa联盟也鼓励电信运营商部署LoRa网络。目前国内已经有一些LoRa的方案商。WeightlessWeightless是由一个非盈利全球标准组织Weightless SIG（Weightless Special Interest Group）提出的技术。与LoRa、SigFox类似，Weightless也是一种专为物联网设计的无线技术。Weightless既可以工作在Sub-GHz免授权频段，也可以工作在授权频段。通信距离可以达到10公里。Weightless有三个不同的开放标准：Weightless-N、Weightless-P和Weightless-W。如果考虑成本，可选择单向通信的Weightless-N。如果考虑高性能，可选择双向通信Weightless-P。如果当地TV空白频段可用，可选择Weightless-W。RPMARPMA技术的全称是随机相位多址接入（Random Phase Multiple Access）。由美国Ingenu公司开发，Ingenu在2008年成立，公司在2015年9月前的名称是ONRAMP。RPMA技术工作在2.4GHz免授权频段，支持全双工通信，这点是比SigFox和LoRa强的地方。SigFox采用的是单向传输，LoRa采用的是半双工的通讯方式。Ingenu为开发人员提供了收发器模组，这些模组可以连接到RPMA网络，这个网络是由Ingenu公司及其合作伙伴在全球范围内建立的网络，这与SigFox比较类似。RPMA网络将来自终端节点的信息转发至使用者的IT系统。RPMA也可适用于想要搭建私有网络的客户人群。结语随着各大电信运营商在原来LTE网络基础上大范围部署NB-IoT以及eMTC网络，未来物联网的无线技术竞争将更加激烈。 在各种技术在基本技术指标上没有明显差异的情况下，成本、整体解决方案、开发者生态以及整个产业链将会决定最终技术的命运。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（五）：除了Linux，还有什么物联网操作系统]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F5%2F</url>
    <content type="text"><![CDATA[在前面介绍物联网终端设备的文章中，我们已经简单地介绍了物联网操作系统。物联网操作系统的种类非常多，不过其中有很大一部分是基于Linux系统改造的，还有一些系统是商业公司或开源组织开发的，当然微软公司也开发了一系列面向嵌入式应用的操作系统。 出于成本或者定制化的需求，开发者往往更青睐开源的物联网操作系统。开源系统可以大致分为两大类：一类是基于Linux系统改造的物联网OS，如uCLinux、谷歌的Brillo、华为的Lite OS等；一类是非Linux类物联网OS，由开源社区或商业公司按照某种开源许可独立设计实现，如uCOS、FreeRTOS、mbed等。篇幅有限，本文重点介绍一下非Linux类的物联网OS，这类系统通常是比较轻量级的实时操作系统，更适合应用于存储性能有限的MCU。 FreeRTOSFreeRTOS（www.freertos.org）是一个迷你的实时操作系统内核，但麻雀虽小，五脏俱全，包括了任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等操作系统的基本功能。FreeRTOS创始人是Richard Barry，最初他设计这个系统的初衷，就是出于自身为工作项目中寻找RTOS的过程很痛苦。商业系统很贵，开源系统也缺乏好的文档支持。相对μC/OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，源码公开、可移植、可裁减，可移植到各种单片机上运行，在嵌入式系统尤其是实时操作系统方面应用者众多，比如著名的智能手表Pebble就是用了FreeRTOS。 μC/OS-IIμC/OS-II 是一种基于优先级的抢占式多任务实时操作系统，包含了实时内核、任务管理、时间管理、任务间通信同步（信号量，邮箱，消息 队列）和内存管理等功能。μC/OS-II绝大部分的代码是用ANSII的C语言编写的，包含一小部分汇编代码，使之可供不同架构的微处理器使用。μC/OS-II经过了非常严格的测试，甚至都已经运用到美国航空管理局的飞行器上。μC/OS-II由Micrium公司以源代码的形式发布，但并不意味着它是免费软件。可以将其用于教学和私下研究（peaceful research）；但是如果将其用于商业用途，那么必须通过Micrium获得商用许可。 mbedmbed SDK 体系及目录结构mBed（mbed.org）是ARM公司官方提供的一套用于快速开发ARM架构单片机应用原型的工具集，包括免费的软件库（SDK），硬件设计参考（HDK）和基于Web的在线编译环境（mBed Compiler）三部分。由于mBed的代码和大部分硬件设计都是以开源（permissive Apache 2.0 licence）的方式提供的，再加上它面向的ARM系列单片机具有较高的性价比和广泛的应用基础，所以mBed在世界范围内已经吸引了大量的电子产品开发者，其产业生态链已经初级规模。 MiCOMICO系统架构2014年7月，MiCO号称是中国首款物联网操作系统，由上海庆科（MXCHIP）发布。根据官方解释，MiCO的意思是Micro-controller based Internet Connectivity Operating system，是基于微控制器（MCU）的互联网接入操作系统，这个解释其实和物联网操作系统的意思一回事。MiCO本身包括：接口，框架，核心功能和非核心功能四部分。开发者可以在各种微控制器平台上，基于MiCO来设计接入互联网的创新智能产品。庆科与阿里有合作关系，阿里云的物联网套件的C-SDK，也有MiCO系统的版本。关于MiCO的更多信息，可以去MiCO开发者论坛（mico.io）了解。 MynewtMynewt（mynewt.apache.org）是Apache软件基金会（ASF: Apache Software Foundation）发起的一个开源项目，专注于物联网应用的实时操作系统。Mynewt的最大特色是包括了低功耗蓝牙（BLE4.2）无线传输协议栈NimBLE。Mynewt支持丰富的实时操作系统特征，可以在不同的硬件平台上运行，包括ARM Cortex M0-M4微控制器，以及基于MIPS和RISC-V架构的处理器。 ContikiContiki （www.contiki-os.org）是一个适用于有内存的嵌入式系统的开源的、高可移植的、支持网络的多任务操作系统。包括一个多任务核心、TCP/IP 堆栈、程序集以及低能耗的无线通讯堆栈。Contiki起源于瑞典的大学，基础内核以及大部分的核心功能是Swedish Institute of Computer Science的Adam Dunkels开发的。Contiki 采用 C 语言开发的非常小型的嵌入式操作系统，运行只需要几K的内存。Contiki都很受学术机构以及高校的科研人员青睐，常用于无线传感器网络（WSN：Wireless Sensor Network）的研究项目中。 NuttXNuttx（www.nuttx.org） 是一个实时嵌入式操作系统，它很小巧，在微控制器环境中使用，可用于8位到32位系统。NuttX的特色在于完全符合POSIX API标准，完全实时，并完全开放。目前常用于无人机的飞控系统中。 RIOT OSRIOT（riot-os.org）的目标是在物联网领域起到Linux在互联网领域那样的影响力。RIOT是一个开源、免费的操作系统。支持8位到32位的微控制器，可以运行在大多数低功耗物联网设备上。在GitHub（github.com/RIOT-OS）上可以找到RIOT的源码。 TinyOSTiny OS是UC Berkeley（加州大学伯克利分校）开发的开放源代码操作系统，专为嵌入式无线传感网络设计。与Contiki类似，Tiny OS同样来自于高校，由于其文档非常完善，其受欢迎程度甚至超过Contiki，不过国内使用者不多。操作系统基于组件（component-based）的架构使得快速更新成为可能，同时又减小了受传感网络存储器限制的代码尺寸。Tiny OS只需要几KB的内存空间和几十KB的编码空间。 ZephyrZephyr尽管是由 Linux 基金会托管的开源项目, 但 Zephyr 是一款完全独立的操作系统, 并未采用 Linux 代码。Zephyr微内核能运行在只有10KB RAM的32位微控制器上，相比之下基于Linux的微控制器项目uClinux需要200KB RAM。 结语除了上面列出来的操作系统，其实还有更多没有列出来的。就连谷歌也没闲着，正在秘密开发一个完全独立于Android的新系统，叫做Fuchsia（灯笼海棠），据说这个系统有可能采用iOS策略，走封闭路线。难道谷歌被安卓碎片化问题伤心了？物联网操作系统要比PC OS以及移动OS体量小，开发起来门槛也没那么高，很多很小的系统都可以作为商用，所以对于物联网产品设计者来说还是有很多选择的。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（一）：无线技术分类]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F1%2F</url>
    <content type="text"><![CDATA[物联网的关键技术包括三个方面：物体的识别、物体的连接以及对数据的操作。随着联网物体的数量越来越多，无线技术在物联网中发挥的作用也越来越大。 物联网无线技术分类 常见的物联网无线技术可以按照覆盖范围分为两大类： 一类是长距离（几百米到几公里）覆盖的无线广域网（WWAN）技术。代表技术有：NBIOT、eMTC、GPRS、802.11ah、LoRa、SigFox、Weightless等。 另一类是短距离（100米以内）覆盖的无线局域网（WLAN）或者无线个域网（WPAN）技术。代表技术有：WiFi、Bluetooth、Zigbee、RFID、NFC、Z-Wave等。 短距无线技术的应用场景由于智能手机的普及，平时生活中接触比较多的无线技术就是WiFi、Bluetooth（蓝牙）及NFC，这些都是智能手机普遍提供的无线连接能力。 与NFC类似的RFID的主要功能不是用来连接和通信，而是用于物体的识别（Object Identification）, NFC目前主要用于移动支付，比如银联IC卡闪付、Apple Pay等。 NFC广泛用于支付场景 WiFi、蓝牙、Zigbee以及Z-Wave等短距离无线技术，常用于智能家居这样的应用场景。目前国内智能家居市场WiFi、蓝牙以及Zigbee技术应用得比较多。Z-Wave与Zigbee类似，是由丹麦Zensys公司主导的技术标准，在国内比较少用。 对于WiFi连接的物联网设备，一般都支持TCP/IP协议，带有IP地址，这样可以直接通过IP协议接入互联网的服务器上。用户也可以用手机APP，通过物联网服务器来远程查看或控制物联网设备。 对于蓝牙或者Zigbee连接的物联网设备，没有IP地址，一般需要借助一个网关设备，才能接入网络。智能家居网关都带有网络连接，通过WiFi或有线接入到路由器，另外网关一般都集成了多种通信协议，还起到协议转换的作用。 大范围覆盖：LPWA技术对于室外需要大范围覆盖的场景，以上这些无线技术就不适合应用了。因为物联网节点分布非常广而且非常分散，如果要让每个节点都接入附近的路由器，就需要布设大量的路由节点，这样成本高，而且部署复杂。所以对于这种应用场景，非常适合远距离无线技术。 与我们平时手机上网用的3G、4G不同，物联网所需要的远距离无线技术，对传输速率的要求不高，同时要求具有极低的功耗，属于低速率低功耗的无线通信技术。对于这类技术，目前一般统称为LPWA（Low Power Wide Area），NB-IoT和LoRa都是其中的代表。 关于NB-IoT以及LoRa的技术详解，请继续关注我们的头条频道：“微说互联网”及“纵论物联网无线技术”。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（八）：面向可穿戴设备的无线物联网技术]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F8%2F</url>
    <content type="text"><![CDATA[导语智能手环、智能手表为代表的可穿戴设备，在短短几年时间内，就已经在全世界普及开来。可穿戴设备是物联网领域很重要的一种设备类型，特点是功耗低、体积小、电量有限 。本文主要介绍可应用于可穿戴设备的无线技术有哪些？ 蓝牙最流行 蓝牙无疑是可穿戴设备最流行的技术，蓝牙耳机就是一种非常常见的可穿戴设备。不过蓝牙耳机所使用的蓝牙技术还属于比较早的版本，一般是蓝牙2.1+EDR版。可穿戴设备中最流行的蓝牙技术都是BLE（Bluetooth low energy ）技术，也就是蓝牙低功耗。目前BLE一般都是蓝牙4.0或4.1版本。可穿戴设备一般体积都比较小，无法容纳电量很大的电池，所以要求无线功耗必须很低，这样才能有较长的续航时间，而不需要经常性地充电。 ANT+：运动家的最爱 各种基于ANT+技术的运动传感器 除了蓝牙BLE经常用于手环、智能手表以外，针对运动类的可穿戴产品，ANT+协议也应用得很广泛。可以说，在运动领域，ANT+技术是蓝牙最大的竞争对手。ANT是一个无线传感器网络技术，由Dynastream Innovations下面的ANT Wireless部门设计和推广。ANT工作于2.4GHz ISM频段，有一套完整的通信协议栈。ANT技术与BLE类似，不过只面向传感器应用。ANT+是由ANT+联盟设计和推广的基于ANT协议的兼容性标准，可以认为是ANT的子集。ANT+与ANT的关系，就像WiFi与802.11一样。ANT+的缺点显而易见，就是大多数手机都不支持，只有少数手机，比如Sony的几款手机，支持ANT+技术。不过国际上大多数运动设备，如心率带、踏频器等，都是基于ANT+的。 GPS GPS是一种定位技术，不是用来通信的，但实际上GPS就是一个无线通信系统，只不过GPS接收器是与卫星进行通信，接收卫星的数据然后确定自己的位置。GPS在手环上不常见，一般在高端的运动手表上经常可以看到。尤其对于户外运动爱好者，GPS运动手表是必需品。 其他技术（1）WiFi像Apple Watch这样的智能手表还有上网功能，也就是说，可穿戴设备不必借助手机就可以联网。对于这类可穿戴设备，不再是智能手机的附属品，本身就是一个独立的互联网终端。 （2）GPRS/LTE/eMTC通过WiFi联网只能在有无线AP的地方才行，对于户外就无能为力了。针对老人或者儿童的安全手表，需要有户外联网的能力。GPRS是目前最常采用的技术。对于可穿戴设备来说，LTE是比较少见的，毕竟功耗还是有点高。除非是一些对数据流量有特别需求的产品，比如Apple Watch有LTE版。但要注意的是：LTE与续航不可兼得。面向物联网应用的eMTC，可以支持语音功能，也具有一定的数据传输能力，且功耗比GPRS要低得多，相信在未来将是可穿戴设备联网的首选技术。 结语相信随着技术的进步，可穿戴设备的联网能力越来越强，携带的电池容量很变大，通信的功耗也会降低。到了一定的程度，智能手机可能会以可穿戴设备形式出现在我们的日常生活中。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（三）：3GPP物联网技术]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F3%2F</url>
    <content type="text"><![CDATA[导语随着物联网应用的发展，对于大范围组网的需求越来越多，LPWAN技术备受关注。前面的LPWAN技术文章介绍过，LPWAN技术可根据工作频段分为两类：一类是工作于未授权频段的无线技术，以LoRa、SigFox为代表；一类是工作于授权频段下的无线技术，以3GPP支持的2/3/4G蜂窝通信技术为代表。 本文重点介绍一下国际电联下的标准化组织3GPP为物联网应用推进的技术标准，其中最具知名度的技术就是NB-IoT了。 3GPP是什么？ 为了解决各国2G蜂窝通信系统互不兼容的问题，各国通信标准化组织在1998年12月成立了3GPP，最初成立的目标是实现由2G网络到3G网络的平滑过渡，保证未来技术的后向兼容性，支持系统间的漫游。现在3GPP已经发展成为最具权威的国际移动通信标准制订机构，4G以及未来5G的通信标准都是由3GPP来制订。3GPP每一个标准规范都叫做一个Release，简称R-xx，xx是标准的数字编号，比如最早1999年的R99，之后的版本号是R4，R5，等等。 GPRS是在GSM网络基础上发展起来的数据通信技术，用来解决2G网络中数据传输的业务需求。现在广泛应用于物联网项目中。不过由于GPRS的功耗较高、系统容量有限等缺点，所以业界一直寻求GPRS的低功耗低成本的替代方案，也就是LPWAN技术。前文介绍过的LoRa、SigFox都属于这类技术。不过LoRa，SigFox都是公司提出的私有标准，3GPP作为国际性的标准化组织当然也没闲着，针对物联网的技术需求，3GPP也提出了一系列物联网技术标准，总的来说可以分为三类：基于LTE网络演进的LTE-M技术基于GSM/EDGE网络演进的EC-GSM以NB-IoT为代表的Clean Slate技术。LTE-M（eMTC）LTE-M，即LTE-Machine-to-Machine，是基于LTE演进的物联网技术。LTE-M在3GPP标准R12中叫低功耗MTC（Low-Cost MTC），其中MTC是Machine Type Communications的缩写。在R13中LTE-M被称为enhanced MTC，也就是目前媒体在宣传的eMTC。旨在基于现有的LTE载波满足物联网设备需求。为了适应物联网应用场景，3GPP在早期的LTE标准中，曾定义了最低速率的UE设备为Cat-1，这种设备不支持MIMO，使用单天线传输速率低，功耗也低，上行速率为5Mbps，下行速率为10Mbps。为了进一步降低功耗并满足低速率需求，3GPP到了R12中又定义了更低成本、更低功耗的Cat-0，其上下行速率为1Mbps。一般的LTE设备的信道带宽可以达到20MHz，对于低速率的IoT设备来说，完全不需要这么宽的工作带宽。在R13标准中制定了Cat-M1设备标准，最大工作带宽只有1.4MHz，所能支持的最大速率是1Mbps。下图可以看出LTE cat-M1与LTE cat-1、LTE cat-0的传输速率比较。 EC-GSM3GPP下面有好几个技术规范组（TSG），比如TSG RAN是负责制订LTE标准的。另外还有一个专门负责GSM/EDGE标准的TSG GERAN。GERAN是GSM/EDGE Radio Access Network是缩写，意思是GSM/EDGE无线接入网络。基于GSM演进的物联网标准自然也由TSG GERAN来负责。 2014年3月，3GPP GERAN 提出，要将窄带（200 kHz）物联网技术迁移到GSM上，寻求比传统GPRS高20dB的更广的覆盖范围，并提出了5大目标：提升室内覆盖性能、支持大规模设备连接、减小设备复杂性、减小功耗和时延。这些目标也可以认为是LPWAN技术的共同追求。2015年，TSG GERAN #67会议报告表示，制订的EC-GSM技术已满足5大目标。EC-GSM，即扩展覆盖GSM技术（Extended Coverage-GSM）。虽然标准化已经完成，但没有什么落地的应用。NB-IoT3GPP在R12/R13在LTE标准中加入了MTC相关技术标准，但其本质是在既有LTE技术与架构上进行优化，并不是针对物联网全新设计。不同于MTC，蜂窝物联网(Cellular Internet of Thing, CIoT)项目建议针对物联网特性全新设计，不一定要兼容既有的LTE技术框架。2015年8月，3GPP的TSG RAN开始立项研究窄带无线接入全新的空口技术，称为Clean Slate CIoT。Clean Slate的字面意思就是清白历史，意味着抛掉LTE技术的历史包袱，重新开始设计。 在正式标准开始制订以前，企业早已动手开始设计新的空中接口，并形成了两个主要的技术提案：NB-CIoT方案是由华为、沃达丰和高通联合提出，NB-LTE方案是由爱立信、诺基亚等厂家提出。最终，在2015年9月的RAN #69会议上经过激烈撕逼后协商统一，两大阵营相互妥协，最终版本的NB-IoT标准可认为是NB-CIoT和NB-LTE的融合。未来展望今年不断有消息称，国内三大运营商有计划关掉2G网络或者重耕900M频段，将其用于NBIoT网络，估计国内物联网未来eMTC和NBIoT会成为主流技术。但LoRa有先发优势，已经有成熟的商用项目。短期内估计NBIoT的芯片成本还降不下来，预计未来2~3年，多种LPWAN物联网技术会长期共存]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（七）：面向智能家居的物联网解决方案]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F7%2F</url>
    <content type="text"><![CDATA[导语智能家居是非常广泛的一类物联网应用。目前国内最常用的面向智能家居的无线协议有WiFi、Zigbee、433MHz无线技术，另外还有基于电力线载波的有线解决方案。今天我们聊一下常用于智能家居的技术有哪些？ 433MHz及红外 红外与433MHz常用于对家电或照明系统的遥控上。电视、空调通常配备的遥控器都是红外的。如果要通过网络实现远程控制的话，需要有一个能够联网的红外转发设备，把网络指令转换为遥控电器的红外信号。 BroadLink万能遥控器由手机通过WiFi控制，集成了红外及433MHz遥控能力433MHz与2.4GHz一样，也是一个免授权的频段，常用于遥控。与红外相比，433MHz的传输距离更远，不受视距限制，不需要对准被控物体，适合比较大的环境。目前有一些遥控电灯、遥控开关面板，都是基于433MHz的。 Zigbee ZigBee应用广泛Zigbee与WiFi都常用于智能家居的解决方案中。Zigbee协议基于IEEE 802.15标准，主要针对低功耗的射频节点组网而设计。Zigbee使用OQPSK调制技术，传输速率为250kbps，传输距离在10m到100m。Zigbee节点可以扮演中继的作用，组建Mesh网络，因此Zigbee设备可以经过多跳将数据传输到很远范围以外的节点。国内有很多公司都开发了基于Zigbee协议的智能家居解决方案。但相比WiFi来说，Zigbee方案中必须需要网关设备。网关起到协议转换的作用，否则Zigbee设备无法与手机进行互操作，也无法直接接入互联网。 WiFiWiFi可以说是目前最常见的智能家居解决方案。所有的设备都可以接入无线路由器，手机也可以对设备直接进行控制，不需要网关的协议转换，比Zigbee方案更容易被接受。 基于WiFi的设备还可以直接接入网络，很容易实现远程控制。不过WiFi的耗电量相比Zigbee略高一些，所以可能不太适合对功耗要求比较苛刻的应用场景。 Z-WaveZ-Wave是由丹麦公司Zensys主导的专门面向智能家居应用的无线组网协议。Z-Wave使用GFSK调制技术，工作于ISM免授权频段。传输速率最高可以达到100kbps，没有Zigbee高。单跳的传输距离要比Zigbee远。与Zigbee类似，Z-Wave也有一个产业联盟，不过没有Zigbee联盟那么强大。Z-Wave联盟中包括了不少智能家居的相关产品，如HVAC、照明、安防等。目前Z-Wave在国内没有得到广泛应用，远远不如Zigbee更受市场青睐。 其他解决方案（1）OpenHABOpenHAB全称为open Home Automation Bus，即开放式家庭自动化总线，该项目旨在为家庭自动化构建提供一个通用的集成平台。OpenHAB是一个基于Java的开源项目，其设计是厂商中立的，与硬件/协议无关。OpenHAB通过绑定，汇集了不同的总线系统、硬件设备和接口协议。 （2）C-BusC-Bus 系统由澳大利亚奇胜（Clipsal）公司开发，该公司是施耐德的子公司。C-Bus 是一种以非屏蔽双绞线作为总线载体，应用于建筑物内照明、空调、火灾探测、出入口、安防等综合管理的智能化控制系统。 （3）InsteonInsteon是一种复杂度低，功耗低，数据传输速率低，成本低的双向混合通信技术，具有即时响应，易安装，易使用，经济可靠的特点，且与X10兼容。之所以说Insteon是混合通信技术，是因为Insteon同时支持电力线通信与无线射频通信两种方式。 （4）KNXKNX是Konnex的缩写。1999年5月，欧洲三大总线协议EIB、BatiBus和EHSA合并成立了Konnex协会，提出了KNX协议。该协议以EIB为基础，兼顾了BatiBus和EHSA的物理层规范，并吸收了BatiBus和EHSA中配置模式等优点，提供了家庭、楼宇自动化的完整解决方案。 （5）UPBUPB是Universal powerline bus的简写，即通用电力线载波总线。UPB也是专门用于家居自动化（home automation）的通信协议，使用电力线传输信令与控制指令。UPB在1999年由美国的PCS Powerline System公司开发。 （6）X10X10是一种国际通用的智能家居电力载波协议，用X10的兼容产品可以通过电力线相互沟通，无需重新布线，被控制的电器可多达256路。20世纪80年代，美国SmartHome概念兴起,也就是现在智能家居的原型，在上世纪，X10技术被广泛应用。 结语应该说智能家居在互联网兴起以前就发展了一段时间了，因此有很多历史遗留的协议，比如X10, KNX等等。随着互联网的普及，基于IP的协议与传统协议之间就在智能家居领域存在很多竞争和共存的问题。现在智能家居的最大问题就是协议太多，即使底层用一套协议，各家厂商的上层协议也都互不兼容，最后导致用户使用起来很麻烦。这是智能家居没有得到广泛应用的主要问题。想要了解物联网的其他领域应用，请继续关注“微说互联网”及“纵论物联网”系列文章。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（十）：物联网应用层协议]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F10%2F</url>
    <content type="text"><![CDATA[导语物联网的关键技术主要解决三个方面的问题：物体的识别、物体的连接、物体的数据交换。每个方面都有一些技术解决方案，在前面的文章中，我们介绍了RFID、NFC等物体识别及电子标签的技术，也介绍了物联网节点组网与接入的技术。这篇文章主要讲一下物联网的数据是如何处理的。 物联网关键技术大全 物联网应用层协议LoRa、NB-IoT以及Zigbee、蓝牙主要解决的是物体互联以及接入网络的问题，从网络协议分层来看，基本上都属于数据链路层协议。对于物联网的数据交换，主要依靠应用层协议来解决。在移动互联网中，最常用的应用层协议就是HTTP协议，HTTP协议同样可以用于物联网系统中。HTTP协议采取的是请求-响应（Request-Response）的通信机制，服务器没有办法主动给客户端发送消息。如果要实现这种消息推送，就需要借助WebSocket这种全双工的通信机制。不过对于很多计算和存储资源有限的物联网节点，不太适合使用HTTP协议。除了HTTP协议以外，也有很多更适合于物联网应用的协议，比如MQTT、CoAP、AMQP、STOMP等。 各个物联网软件平台最常使用的物联网协议 发布-订阅机制很多物联网应用层协议都是基于发布-订阅(Publish-Subscribe)机制，这种机制非常适合物联网系统应用。MQTT协议、STOMP协议、AMQP协议以及DDS协议都属于这种发布-订阅的机制。每个传感器节点，采集的数据需要上传到网络，相当于是一个消息的发布，这个消息需要基于某个主题，比如传感器的类型。所有关心这个主题的节点，都可以通过订阅这个主题的消息，实时获取最新的数据。 消息的发布和订阅是基于某个主题的，实现机制一般依赖于消息队列 MQTT协议消息队列遥测传输协议（MQTT : Message Queuing Telemetry Transport）是为大量计算能力有限，工作带宽有限、网络环境不可靠的传感器或控制器而设计的协议。 MQTT协议基于TCP协议 MQTT协议原来是IBM开发的一个即时通讯协议，基于TCP协议实现。MQTT客户端需要通过消息代理（MQTT Broker）来进行消息的发布和订阅。MQTT协议的兼容性非常好，几乎支持所有平台，可以把各种物联网设备都连接起来。所以MQTT协议也是目前应用最广泛的物联网应用层协议。 CoAP协议受限应用协议（CoAP：Constrained Application Protocol）是6LowPAN协议栈中的应用层协议，基于REST（表述性状态传递）架构风格，支持REST交互。 CoAP协议基于UDP协议 CoAP基于UDP协议，其设计初衷就是尽可能地方便地转换为HTTP协议。CoAP让用户可以像使用HTTP协议一样，在资源受限的物联网设备中使用CoAP协议。 AMQP协议高级消息队列协议（AMQP：Advanced Message Queuing Protocol）是一个提供统一消息服务的应用层标准高级消息队列协议，为面向消息的中间件设计。 AMQP的工作原理 AMQP的工作原理与MQTT类似，也是基于发布-订阅机制。消息代理Broker的交换机组件（Exchange）会把接收到的消息，根据消息的主题，分配到不同的队列中，以便订阅者接收。RabbitMQ就是在AMQP协议基础上实现的一个消息系统，遵循Mozilla Public License开源协议。RabbitMQ在互联网应用中常被用作消息服务器。 STOMP协议简单(流)文本定向消息协议（STOMP: Simple (or Streaming) Text Orientated Messaging Protocol)，提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。当前非常流行的开源消息服务器ActiveMQ、Apollo、RabbitMQ（需要插件）都支持STOMP协议。 ActiveMQ支持TCP、XMPP、STOMP等协议进行消息传输 STOMP基于TCP协议，客户端和服务器之间的通信是通过“帧”（Frame）来实现，每个帧由多“行”（Line）组成。STOMP协议定义了帧结构。 Stomp帧格式STOMP帧第一行是命令，紧跟着键值对形式的Header内容。然后是一个空行，最后是Body内容。数据分发服务DDS数据分发服务（DDS：Data Distribution Service for Real-Time Systems），是面向实时系统的数据分布服务，是由OMG组织提出的协议。 DDS的数据分发的实时效率非常高，能做到秒级内同时分发百万条消息到众多设备。DDS在服务质量（QoS）上提供非常多的保障途径，因此适用于国防军事、工业控制这些高可靠性、可安全性应用领域的原因。不过DDS目前还只限于在有线网络部署，无线网络的可靠性可能满足不了DDS的QoS要求。 总结上面列出了一些比较常见的物联网应用层协议，但并不全面，还有一些相对更加小众的协议，公开资料也比较少。目前很难说哪种物联网应用层协议会实现垄断局面，还要看各自生态和市场需求的未来发展。如果希望了解更多关于物联网的信息，请继续关注“微说互联网”的“纵论物联网”系列。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（六）：基于Linux的物联网操作系统]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F6%2F</url>
    <content type="text"><![CDATA[提到物联网操作系统，就不能不提Linux，因为Linux可能是目前在物联网设备中应用最广的操作系统了。前面的文章刚刚介绍了不少非Linux类的物联网操作系统，本文就来介绍一下目前常用的基于Linux的物联网操作系统。 在传统Linux内核基础上，经过裁剪，就可以移植到嵌入式系统上运行。不过，还有很多开源组织和商业公司对Linux进行了一番改造，使其更符合嵌入式系统或物联网应用的需求，比如改为实时操作系统。 RTLinuxRTLinux（Real-Time Linux）是Linux中的一种实时操作系统。它由新墨西哥矿业及科技学院的V. Yodaiken开发。现在已被WindRiver公司（大名鼎鼎的嵌入式操作系统VxWorks就是这家公司的产品）收购。RT-Linux开发者并没有针对实时操作系统的特性而重写Linux的内核，因为这样做的工作量非常大，而且要保证兼容性也非常困难。RTLinux是将Linux的内核代码做了一些修改，将Linux本身的任务以及Linux内核作为优先级很低的任务，而实时任务作为优先级最高的任务。 uClinuxuClinux（www.uclinux.org）表示micro-control linux，即“微控制器领域中的Linux系统”，是Lineo公司的主打产品，同时也是开放源码的嵌入式Linux的典范之作。uCLinux主要是针对目标处理器没有存储管理单元MMU（Memory Management Unit）的嵌入式系统而设计的。它已经被成功地移植到了很多平台上。由于没有MMU，在uCLinux上实现多任务需要一定的技巧。 Brillo谷歌提出了Project IoT物联网计划，并发布了Brillo操作系统。Brillo是一个物联网底层操作系统。Brillo是源于Android，是对Android底层的一个细化，得到了Android的全部支持，比如蓝牙、Wifi等技术，并且能耗很低，安全性很高，任何设备制造商都可以直接使用。LiteOS2015年5月在华为网络大会上，华为发布了敏捷网络3.0，主要包括最轻量级的物联网操作系统LiteOS、敏捷物联网关、敏捷控制器三部分。其中LiteOS声称可以作为只有10KB大小的内核来部署。在华为的官方网站（www.huawei.com/minisite/liteos/cn/）上，可以了解到更多关于LiteOS的信息。 OpenWrt很多智能路由器都基于OpenWrt的衍生版本开发而成轻量级OpenWrt（www.openwrt.org.cn）是一个基于Linux的操作系统，市场上很多智能路由器固件都是基于OpenWrt及其衍生版本的。OpenWrt包括很多衍生版本，这些衍生版本还有很多分支版本。LEDE（lede-project.org）。LEDE全称是Linux嵌入式开发环境(Linux Embedded Development Environment)项目，LEDE就是一个基于OpenWrt的OS。其他衍生版本还有DD-Wrt，以及面向Arduino的Linino，等等。 Ostro Linux Ostro? OS is a Linux* distribution optimized for the development of connected and embedded devices. In fact, Ostro Project is designed specifically to support IoT device development. It integrates connectivity and networking, device-to-device interconnectivity standards, pre-configured sensors, and over-the-air update capabilities. Ostro（ostroproject.org）是一套基于Linux并且为物联网智能设备特别量身订做的开源操作系统，支持蓝牙、WiFi和NFC等等的连接方式，并且支持多种如IoTivity的设备对设备互联互通标准。提到Ostro，不得不再说一下Linux基金会的Yocto Project。Yocto不是一款Linux发行版，而是一个开源协作项目，为开发人员提供构建自定义嵌入式堆栈的模块、工具和方法。Yocto Project构成了大多数商用嵌入式Linux发行版的基础，比如Ostro Linux、Qt for Device Creation都是基于这个项目。 其他Linux物联网项目（1）RaspbianRaspbian成为树莓派爱好者的最佳选择Raspbian是一个专门面向树莓派（Raspberry Pi）计算机的Linux发行版，基础是Debian操作系统。两位志愿者针对树莓派硬件对Debian进行了专门的优化和移植。而Raspbian不仅仅是一个OS，它附带着35000个软件包以及预编译的软件。 （2）Snappy Ubuntu CoreUbuntu希望继续让Linux成为让物联网更智能和可扩展的核心。Snappy Ubuntu Core是面向智能设备的最新平台，其承诺可以运行存储在本地或依赖于云端的相同软件。 （3）TizenLinux基金会托管的这个嵌入式Linux项目主要得到了三星的支持。Tizen广泛用于三星的电视和智能手表中，包括新的Gear S3，也零星地实施在三星的相机和消费级设备中。 结语在Linux系统基础上发展起来的面向物联网应用的项目非常多，Linux的碎片化程度也挺严重。至于哪个版本的Linux会成为主流，取决于应用场景、文档及开发资源支持和整个开发者生态的建立。在移动互联网时代，基于Linux的Android系统和互联网应用大放异彩；在物联网时代，Linux仍然会发挥着巨大作用。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网]]></title>
    <url>%2F2017%2F10%2F26%2Fiot%2F0%2F</url>
    <content type="text"><![CDATA[最近在网上看到一篇介绍物联网的系列文章《纵论物联网》，但是很遗憾，都是来回转载的，也没有找到出处，零零散散的，东一篇西一篇，看起来很不方便。现汇总收集如下，既做整理，也做收藏。 纵论物联网（一）：无线技术分类纵论物联网（二）：LPWAN技术纵论物联网（三）：3GPP物联网技术纵论物联网（五）：除了Linux，还有什么物联网操作系统纵论物联网（六）：基于Linux的物联网操作系统纵论物联网（七）：面向智能家居的物联网解决方案纵论物联网（八）：面向可穿戴设备的无线物联网技术纵论物联网（九）：物联网设备的标识技术纵论物联网（十）：物联网应用层协议]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音交互系统的自动化测试思考]]></title>
    <url>%2F2017%2F09%2F01%2Frobot-os%2Ftest%2Fautotest%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 机器人OS 不同于传统的OS，不同之处在于交互方式的不同。人机交互界面（HMI)，简化思考无外乎就是输入输出（I/O)，之前的自动化测试可以很大程度上覆盖需求，是否就是很大程度上模拟了输入输出，并分析了输出的结果（不知者无畏）? 长远考虑，从稳定性或者测试效率考虑，搞搞自动化测试应该利大于投入吧？ 原理上能否实现？基本思路如下图： 结合机器人OS，输入有（asr/keyevent/mic matrix/visual) 输出有（tts/display/app/motion)，这些在framework部中基本都对应一个server，真实的输入输出由与其绑定的运行在其他进程中的service实现。server的作用基本就是消息转发。对应于系统的整体框架图，基本就是下图中红线框出的部分。 特别说明AppServer 也作为一个输出Server，它输出的是对应用的调度动作。综上：在架构实现上需要在（替换/插入）测试service的地方需要在现有代码中做判断：在正常使用时加载正常的service，在测试环境下替换加载测试用的service。测试用service在独立apk中实现，通过service的绑定机制绑定到对应server中。 可以这样实现：基于以上原理，实现一个autotest的apk，在测试模式下替换了正常的AsrService，当机器人开始listen的时候从模拟asr的service中返回预先写好的剧本中的一句话，实现可控输入。操作说明：1、打开自动测试开关修改配置项 auto_test_replace_asr的值为true。2、编写剧本文件目前是固定的文件名（autotest.txt)，稍后实现可选择加载不同的剧本文件每行一个输入语句，换行即为下一条输入。将剧本 push 到 机器人的 sdcard下。例如： 123456# 这是注释你好slient 2loop 5今天天气怎么样？end 3、安装机器人AutoTest.apk。4、重启机器人，等待进入执行脚本，执行过程中可根据具体测试用例，认为制造些异常（例如断网等），目前还不支持模拟摸头，唤醒词模拟等(lll￢ω￢)，所以需要手动5、测试过程中，更新autotest.txt 文件修改完重新push后，打开autotest 应用的界面，点击重新加载剧本即可。 长远实现：1、补全可自动化测试的模块实现HeadServiceTest, MicServiceTest, VisualServiceTest, 在自动化时挂载入系统模拟 这几类输入实现TTSServiceTest，DisplayServiceTest, MotionServiceTest, AppServiceTest, 在自动化时插入系统中，获取相应模块执行的结果并记录。2、脚本语法丰富（注释/Listen/Head/Mic/Visual）关键字的简单实现，记录结果的简单语法实现（Speak/App/Show/Do)3、分析：比较输入脚本和记录的输出结果，分析bug4、报告：根据分析结果提供可视化的报告。]]></content>
      <categories>
        <category>机器人OS</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RT-Linux机器人控制系统实时性的探讨]]></title>
    <url>%2F2017%2F08%2F31%2Frobot-os%2Farch%2Frtlinux%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 在机器人控制器的设计中，如何最大程度的提高机器人控制的实时性是一个关键问题。这里我们运用了将软件任务划分实时域与非实时域的思想，实现了一种将RT-Linux与Linux结合的实时机器人控制系统。该系统的优点是：提供了非常高效的满足底层硬件设备的实时性能，可以充分利用 Linux的强大功能；而且RT-Linux是完全开放源代码的免费软件，降低了开发成本。 本文是一篇不知从何处舶来的文章，作于2016年11月3日… RT-Linux的系统结构 RT-Linux的基本思想就是使Linux运行在实时核心之下，如图1所示。RT—Linux是一个可加载的核心模块。一个小的RT-Linux实时内核同原来的Linux内核共同控制处理器。实时内核直接管理硬件中断，因此实时内核操纵着机器的响应时间，原来的Linux就无法影响实时任务了。在RT- Linux中设计了两类中断。软中断是正常的Linux中断，硬中断则是真正的实时中断，执行时几乎没有任何延迟。实现时，RT-Linux是通过在 Linux核心和中断处理器之间设计一个仿真软件来达到其目的的。 在RT-Linux中采用两种调度策略。一种是基于优先级的抢占式调度算法；另一种是lsmaelRipoll实现的 EDF（EarliestDeadlineFirst）算法。对于周期性任务可以采用单调率调度算法，即周期短的任务能够获得较高的优先级。调度策略将 Linux视为赋予最低优先级的实时任务。 Linux仅仅在实时系统没有其它任务时运行。Linux和实时任务之间的转换依据上述提及的软中断状态而定。RT-Linux通过这样一种设计方法，将标准的Linux核心改成一个可抢占的、具有低延迟中断处理的实时系统。 实时机器人控制系统的软／硬件结构硬件系统结构 整个实时机器人控制系统主要的硬件部件为：与IBM—PC兼容PentiumIII733MHzq-业控制微机（IPC），内存l28MB；三轴位置控制卡（PCL一832）；l0／100M自适应网卡、集线器等以太网连接设备；机器人本体为具有5个自由度的日产PT500机器人。 机器人控制器运行于一台工业控制微型计算机（IPC）上。在该IPC上安装了两块三轴位置控制卡。每块三轴位置控制卡能对三轴进行联动插补控制。每轴有专用位置芯片控制，构成一个伺服位置和速度环。放在DDA脉冲缓冲器中的脉冲数被传到DDA发生器，在下一个DDA周期中输出。然后由三轴位置控制卡将各轴对应的脉冲数解释为相应的电平信号，驱动伺服驱动器以驱动机器人本体的运动。 软件系统结构 整个机器人实时控制器的系统结构如图2所示，整个系统分为2个域：实时域和非实时域。实时域中实现的是实时设备驱动程序，负责PCL-832位置控制卡的控制与中断响应，驱动机器人本体运动；非实时域中实现的是上层的机器人控制界面和远程监控子系统；二者之问通过实时先进先出（RT-FIFO）缓冲队列进行数据交换。内核调度策略将Linux视为赋予最低优先级的实时任务，Linux中的非实时任务仅仅在实时系统没有其它任务时运行，以确保实时任务的最高实时优先级。 RT-Linux中的实时模块 实时域中的软件模块主要是三轴位置控制卡（PCL一832）的设备驱动程序。驱动程序是能够直接访问硬件的模块，具有应用程序不具备的处理中断和读写端口的能力，是嵌入操作系统核心的底层软件。三轴位置控制卡以毫秒级发出DDA中断请求，对DDA中断的响应的快慢是决定整个机器人控制器实时性能的关键指标。RT-Linux中的三轴位置控制卡的实时设备驱动程序必须处理以下事务： ① 响应三轴位置卡的插补周期中断（DDA），并输出位置脉冲数值； ② 响应三轴位置卡的误差溢出中断（Ov），通知应用程序进行相应处理； ③ 为应用程序提供服务，如读写I／O端口、设置参数、读取状态等。 Linux中的非实时模块 非实时域中的软件模块由机器人控制器和远程监控子系统组成。本地的机器人控制器负责将文本机器人指令解释成相应的位置脉冲数据，通过先进先出（RT- FIFO）缓冲队列发送给实时域中的驱动程序驱动机器人本体运动。同时具有权限的用户能够以离线编程方式或在线操作方式通过高速以太网分别与离线编程与仿真数据发生器和机器人控制器进行连接，实现离线编程和对机器人的实际控制。 实时系统的性能评估 实时系统的性能评估主要在8个方面进行。它们分别是任务换道性能、任务优先级性能、内存分配性能、任务内部通信性能、中断延迟时间、操作系统运行时效率、初始化时间和关机时间。而在机器人控制中最讲究的就是中断响应时问。因为就本项目而言，我们最关I～，RT-Linux系统对三轴位置控制卡（PCL一 832）的DDA中断的响应时间，所有工作的目的就是为了尽量减少中断响应时间。 测试环境及方法 用于测试的工业控制微机的硬件配置为IntelPentium（clockl20MHz），RAM64MB；服务器软件是用 RedHatLinux6.0（内核版本号2.2.5一l5），RT-Linux的版本号2.2；网络环境l0／100M自适应网卡。中断响应时间的快慢直接反映了这样一个过程的快慢：在用户层的用户进程通过系统调用将脉冲数据写入位于核心层的实时驱动程序的数据缓冲队列，在下一个DDA中断请求到来时，中断服务例程将数据缓冲队列中的脉冲数据写入三轴位置控制卡的动作控制芯片的缓冲区，驱动机器人本体运行。图3反映了上述过程。基于RT-Linux机器人控制系统实时性的探讨 测试结果 分别设置DDA周期为8、12、16、24ms的4种情况作了测试，经过计算，可以得出表1所示的结果。基于RT-Linux机器人控制系统实时性的探讨 表1 低负载下D DA中断响应处理时问测试结果 由此得出，在低负载下RT-Linux的测量时间要比Linux下快0.5—0.6ms左右，证明采用RT—Linux系统确实能够提高系统的实时性能。需要注意的是： ① RT—Linux直接接受硬件中断，所以我们将PCL一832卡的DDA中断和OV中断安装在实时域中，目的就是让RT-Linux最先捕获这两个实时中断，进行处理。 ② 如果用户应用层开辟大量的用户进程，则对于分时的标准Linux来说会受到很大程度的影响。 由测试结果可看出，RT-Linux系统中断响应比标准Linux延时时间短，这个结果也预示在系统高负载情况下RT-Linux系统中的实时性能的优势将更为明显。实际使用该实时机器人控制器时，机器人运行非常稳定，能够满足实时控制的需要。]]></content>
      <categories>
        <category>机器人OS</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷. 硝烟中的scrum和xp]]></title>
    <url>%2F2017%2F08%2F31%2Fold%2Fscrum%26xp%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 本文是一篇读书笔记，作于2012年3月6日… scrum不能解决问题，解决问题靠开发团队自己 出色的团队最重要的是有良好素质的团队，这些素质包括进取心、责任心、良好的习惯、热情，其次才是技术、流程scrum提供了一套实践方法，帮助软件团队养成良好的习惯 scrum原理 目标驱动，在统一的软件交付目标下组织团队 依靠团队的智慧做项目评估、计划乃至设计、开发、测试（？） 抓住项目的最基本开发属性. 周期+质量周期用T表示，质量用B表示（bug数目量化），scrum有助于T*B 尽量小， scrum的角色和职责 产品负责人(product owner)，定义开发目标、需要实现的features和优先级 scrum master，保证团队高效而不受打扰的工作，优化工作条件、过程 团队(team)，自组织的完成项目开发,使用一切可行手段保证进度和质量外围有user,customer,Management scrum过程 前期. 产品负责人整理业务需求，形成product backlog库 执行. 以sprint为单位进行迭代完成sprint backlog，每日例会+issues，sprint结束时交付可运行的产品 后期. sprint完成后通过sprint回顾发现问题和改进点，制定下个sprint要引入的新的实践? scrum的精髓 以上过程也没什么特别的，和UP的迭代几乎一样。精髓在于“检查并适应”，在三个角色、三种仪式（sprint计划、sprint回顾、每日例会）、三种制品（backlog、sprint backlog、燃尽图）的基础上，可以根据公司和项目情况，因地制宜的引入任何有利于缩短开发周期、提高产品质量的实践。 具体细节 sprint前. 产品负责人收集需求，形成backlog，backlog以统一格式定义，重要的属性有. 名称、重要性、估算时间、简单描述、如何演示等，详细的需求可以在其他需求文档中定义。产品负责人可以通过任何渠道、方式获取和确认需求。 sprint启动会议. 一个sprint周期为两周，一次sprint会议约一个下午，参与人员为3个角色都参加，scrum master主持会议。会议内容详细沟通产品负责人选定的重要性高的产品backlog细节，确保团队对需求的理解无误。团队根据需求理解将backlog拆分成任务，并给出每个backlog的估算时间，产品负责人和团队根据sprint内可用的人天和backlog的时间估算，选定需要排入本次sprint的backlog，scrum master和团队分派任务，制定sprint计划。 sprint中. 整理一面任务墙，将sprint内的backlog和任务按照未开始、进行中、已完成等状态进行归类（任务单位以小于等于1天为宜），同时展示sprint的燃尽图scrum master每天早上固定时间组织团队的每日例会 （站立会议，控制时间为10-15分钟），确认每个成员前一天完成的工作、当天要进行的工作、工作中碰到的问题、并更新任务墙。任何需求变更都进行实时评估，超过规划人天的backlog视情况进行拆分或者推迟其他重要性低的backlog。任何完成的backlog都需要演示给产品负责人和QA后才能提交测试。 sprint后. scrum master召集、组织sprint回顾会议。回顾会议以头脑风暴的方式review sprint过程和结果，发现和列举存在的问题，与会人员投票决定需要在下个sprint中解决1-3个问题，探讨解决方案，确定实践方式。 scrum精神 团队目标终于岗位职责 团队工作优于独立作战 高效沟通强于标准化的文档 高能动性、自组织的团队胜于角色划分清晰的流水线 务实的解决问题的方法好于经典理论 快速实践、快速反馈、持续优化 我们怎样编写产品Backlog其他人也可以添加backlog条目，但重要性必须由产品负责人决定迭代开发基本需求. 迭代要有固定时长（时间盒），不能超过六个星期。 在每一次迭代的结尾，代码都必须经过OA的测试，能够正常工作。Nokia的Scrum标准 Scrum团队必须要有产品负责任，而且团队都清楚这个人是谁。 产品负责人必须要有产品Backlog，其中包括团队对他进行的估算。 团队必须要有燃尽图，而且要了解他们自己的生产率。 在一个Sprint中，外人不能干预团队的工作。产品backlog 包括需求、故事、特性组成的列表，按重要性排序，包含了客户想要的东西，用客户的术语加以排序如何让产品backlog停留在业务层次上“给Events表添加索引” 应该 被 “提高后台系统中搜索事件的响应速度” 代替添加索引只是一种解决方案，而且还未必能真正解决问题，回归到问题的原始出发点，这个可以用《你的灯亮着吗》来指导 backlog条目 标识符（ID）， 名称（name）， 重要性（Importance），这个故事有多重要 如. 10或150 分数越高越重要 初始估算（Initial estimate）， 工作量估算（把3个人关在一起，大约需要4天时间） 如何做演示（How to demo）， （先这样做，然后那样做，就应该得到…的结果） 注释（Notes）如. 格外的故事字段 Track（类别） Components（组件） Requestor（请求者） 我们怎样准备Spring计划 产品Backlog必须存在 只能有高一产品Backlog和一个产品负责人（对于一个产品而言） 所有重要的Backlog条目都已经根据重要性被评分过，不同的重要程度对应不同的分数。注意. 产品负责任之外的人也可以向产品Backlog中添加故事，但是他们不能说这个故事有多重要，这是产品负责任独有的权利，他们不能添加时间估算，这是开发团队独有的权利。Spring计划会议 sprint目标 团队成员名单 sprint backlog 故事列表。 确定好sprint演示日期。 确定好时间地点，供举行每日scrum会议。 产品负责人必须参加？（scope（范围）和重要性（importance）由产品负责人设置 estimate（估算）有团队设置 ） 用本能反应来估算工作时间（如. 兄弟在三天能完成故事A吗？） sprint会议开始前需要定一个大致的时间计划， 每个sprint的目标要有一个概要的描述， 团队成员名单以及每个人的投入程度， 其他 一个sprint包含多少故事由团队决定，而不是产品负责人或其他人，产品负责人只能通过修改故事范围、优先级来让团队选择哪些故事进入sprint， 定义完成. 放入测试环境可以测试 时间估算. 团队所有成员对故事进行估算，包括测试人员、开发人员，集合大家的估算确定最终确定故事力求在1-5人天完成 故事拆分成任务，故事是可以交付的，任务是不可交付的 技术故事. 需要完成但又是不可交付的东西，比如安装持续集成服务器，编写系统设计概览。 技术故事不由产品负责人管理，如果产品负责人可以对技术故事的优先级进行评估为什么都交给他呢？ bug: 如果开发完的功能被测试出bug，bug用jira进行了管理，也有优先级，建议将bug当做是sprint backlog的一部分，按照优先级进行评估是否进入sprint， 怎样让别人了解我们的sprint我们要让整个公司了解我们在做些什么，这件事情至关重要。否则其他人就会发出抱怨，甚或对我们的工作做出臆断。 使用sprint信息页，将sprint列举出来，将sprint信息放到wiki上，邮件通知到家 怎样编写sprint backlog一块白板，记录没开始的故事，今天开始的故事，这个sprint完成的故事。故事用白纸，任务用黄色贴纸，燃尽图. 横坐标是日期（去掉非工作日），竖坐标是工作量，story point，可以用人*时表示， 怎样布置团队房间让团队坐在一起， 怎样进行每日例会团队每个人自觉更新sprint backlog的状态， 怎样进行sprint演示所有sprint都结束于演示快速演示，演示我们实现了什么而不是我们怎么实现的， 怎样做sprint回顾这是改进的最佳时机，你不需要在回顾会议上得到什么好点子，在家中的浴盆里就能做得到！轮流发言，scrum master最后总结哪些做法可以保持，哪些做法可以改进，具体改进的想法， sprints之间的休整片刻，在启动新的 sprint 之前，每个人都应该至少度过一个不需要考虑 sprint 的夜晚。更好的是sprint结束在周五，这样就一个周末，最好结束在周四，周五大家搞一个LAB Day，（lab day也是要准备的。。） 如何制定发布计划处理固定价格的合同 我们怎样组合使用 Scrum和 XPScrum 注重的是管理和组织实践，而XP 关注的是实际的编程实践。CI. 把这一切搭建起来需要大量工作，但付出的每一分钟都物有所值。 怎样做测试把测试人员加入到Scrum团队中，测试人员就是验收先生]]></content>
      <categories>
        <category>旧日往昔</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android FileObserver 类使用指南]]></title>
    <url>%2F2017%2F08%2F30%2Fandroid%2Ffileobserver%2F</url>
    <content type="text"><![CDATA[有一种知识就是知道与不知道的区别，我们遇到的很多困难都是这种类型，不知道死活都想不到，知道了也就不过如此最近我们的开发框架在做插件化的功能，用来已插件的形式加载场景和功能（这俩都是开发框架的概念），插件已一个独立apk的形式存在，放在固定的目录下不需要安装，框架启动时就会去加载apk中包裹的插件。有这么个需求，就是该目录下的这些个apk发生变动时 新增 , 删除 , 更新 时，能够load或unload或reload 其中对应的插件，说白了就是监控这个目录的变化。 进入正文 inotify本文要讲的是android 的 FileObserver类，而inotify则是该类功能实现所依赖的基础。 Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。使用 inotify 很简单：创建一个文件描述符，附加一个或多个监视器（一个监视器 是一个路径和一组事件），然后使用 read 方法从描述符获取事件。read 并不会用光整个周期，它在事件发生之前是被阻塞的。 以上是百度百科对inotify的描述，FileObserver的原理大致就是如此，关于 inotify 了解到此即可。 FileObserver下面引用android源码中的注释，对于学习而言android的源码及源码的注释简直就是个巨大的宝藏 123456789101112131415161718/** * Monitors files (using &lt;a href="http://en.wikipedia.org/wiki/Inotify"&gt;inotify&lt;/a&gt;) * to fire an event after files are accessed or changed by by any process on * the device (including this one). FileObserver is an abstract class; * subclasses must implement the event handler &#123;@link #onEvent(int, String)&#125;. * * &lt;p&gt;Each FileObserver instance monitors a single file or directory. * If a directory is monitored, events will be triggered for all files and * subdirectories inside the monitored directory.&lt;/p&gt; * * &lt;p&gt;An event mask is used to specify which changes or actions to report. * Event type constants are used to describe the possible changes in the * event mask as well as what actually happened in event callbacks.&lt;/p&gt; * * &lt;p class="caution"&gt;&lt;b&gt;Warning&lt;/b&gt;: If a FileObserver is garbage collected, it * will stop sending events. To ensure you keep receiving events, you must * keep a reference to the FileObserver instance from some other live object.&lt;/p&gt; */ FileObserver 可以监听的事件类型如下： 事件 说明 ACCESS 即文件被访问 MODIFY 文件被修改 ATTRIB 文件属性被修改，如 chmod、chown、touch 等 CLOSE_WRITE 可写文件被 close CLOSE_NOWRITE 不可写文件被 close OPEN 文件被 open MOVED_FROM 文件被移走，如 mv MOVED_TO 文件被移来，如 mv、cp CREATE 创建新文件 DELETE 文件被删除，如 rm DELETE_SELF 自删除，即一个可执行文件在执行时删除自己 MOVE_SELF 自移动，即一个可执行文件在执行时移动自己 CLOSE 文件被关闭，等同于(IN_CLOSE_WRITE IN_CLOSE_NOWRITE) ALL_EVENTS 包括上面的所有事件 FileObserver的实现也很简单，创建自己的obsever类继承自FileObserver即可，只需重写唯一的一个abstract方法 onEvent 。示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 class PluginFileObserver extends FileObserver &#123; private static final String TAG = "PluginFileObserver"; public static int PLUGIN_FILE_CHANGED = CREATE | DELETE | MODIFY | MOVED_FROM | MOVED_TO; private static ArrayList&lt;PluginFileObserver&gt; stubs = new ArrayList&lt;&gt;(); private Context mContext; private String mPath; private int mMask; public PluginFileObserver(Context context, String path) &#123; this(context, path, ALL_EVENTS); &#125; public PluginFileObserver(Context context, String path, int mask) &#123; super(path, mask); mContext = context; mPath = path; mMask = mask; stubs.add(this); &#125; @Override public void onEvent(int event, String path) &#123; Logger.i(TAG, "[PLUGIN] PluginFileObserver onEvent with event:" + event + " path:" + path); switch (event) &#123; case FileObserver.CREATE: case FileObserver.MOVED_TO: Logger.i(TAG, "[PLUGIN] PluginFileObserver will add plugin: " + path); break; case FileObserver.DELETE: case FileObserver.MOVED_FROM: Logger.i(TAG, "[PLUGIN] PluginFileObserver will remove plugin: " + path); break; case FileObserver.MODIFY: Logger.i(TAG, "[PLUGIN] PluginFileObserver will update plugin: " + path); break; default: Logger.i(TAG, "[PLUGIN] PluginFileObserver don't care this event"); break; &#125; &#125;&#125; 使用也很简单，创建FileObserver对象，指定要监控的路径，指定监控的事件 ，调用startWatching()启动监控，使用完毕调用stopWatching()停止监控。 12345 PluginFileObserver observer = new PluginFileObserver(mContext, pluginPath, PluginFileObserver.PLUGIN_FILE_CHANGED); //开始监控observer.startWatching();//停止监控observer.stopWatching(); 遇到一坑 必须调用startWatching()方法，否则接收不到事件 必须保证FileObserver对象不被GC回收，否则回收后接收不到事件 指定路径如果是个目录，对目录下的子目录内内容变动，接收不到事件，不过可以递归创建子目录的FileObserver。 有时候处理不当，会造成事件循环产生，先入死循环。 最坑 当你把代码写好了，要进行测试了，连接上adb shell 后，修改下目录下的文件已用来测试，结果收不到事件。对的，在adb shell 下操作对应的文件，收不到事件，若要测试，最好直接操作设备的文件管理器或者写代码创建删除文件测试。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom配置入门]]></title>
    <url>%2F2017%2F08%2F29%2Fblog-skill%2Fatom-skill%2Fatom%20config%2F</url>
    <content type="text"><![CDATA[atom 编辑器就是这样一款利器，得益于其强大而方便的插件化安装，几乎可以满足你的任意写作需求。另外，它提供全平台支持，无论是windows还是ubuntu都有很好的支持，且使用体验完全一致。对于在多种操作系统上工作学习的同学来说，极大的减少了再各平台重复学习的成本。以上都是闲话… 获取atom 可从官方地址下载：Atom 各人有各人的需求，我主要是需要快速完成一些文档兼简要的写些另外的文档以记录一下完成这些文档学习到的新技能，理所当然的钟爱markdown。markdown 是一种可以使用普通的文本编辑器编写的标记语言。通过简单的语法标记，可以使文本具有一定的格式。 基本语法介绍 比如如下的简单格式： 123456789### 这是三级标题&gt;工欲善其事必先利其器——这是引用#### 简单语法- 标题- 列表- 待办事项- 引用- [ ] 这是未完成的待办事项- [x] 这是已完成的待办事项 经过markdown编辑器预览可以是： 再比如如下的内容是一个表格：1234| 序号 | 内容 || -- | -- || 1 | 这是第一行 || 2 | 这是第二行 | 经过markdown编辑器预览可以是： 另外还可以插入高亮的代码：123456789public class Demo &#123; private String name; private int age; public Demo(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 经过markdown编辑器预览可以可以是： 实用插件配置markdown 预览atom 默认已经安装了markdown的预览插件：markwon-preview 但是默认的往往功能不够强大，强烈建议卸载之（可以实用快捷键 ctrl+shift+p 这个万能键，然后在弹出的框内输入uninstall package 就会列出提示，然后进入对应的界面卸载就可以了）建议安装插件：markdown preview Enhanced， 安装后使用快捷键 ctrl+shift+m 进行预览，该预览插件支持 mermaid 图形预览 和 MathJax 数学公式预览markdown preview Enhanced 还有很多非常强大的功能： - 更多介绍可参考 markdown preview enhanced 简介 - 项目gitup atom-mermaid 图形预览如下是mermaid的官方说明： Generation of diagrams and flowcharts from text in a similar manner as markdown.在atom 中使用 则需要安装包 atom-mermaid 下图是从官网的介绍中获取的一张图：正如官方的描述，mermaid的作用就是使用简单的文本语法，使用文本来绘制图。更多mermaid的用法可以参考 mermaid 官方介绍。但是划重点了啊 在markdown中使用，需要将其当做代码块输入，示例如下： 12&lt;pre class=&quot;mermaid&quot;&gt; graph LRA --&gt;B&lt;/pre&gt; 而且必须指明语言类型为”mermaid”本文只解决了解的问题，此处不再做更详细的介绍，更多使用的详细语法，还请移步官方介绍 MathJax 数学公式如要在atom markdwon 预览使用 mathjax， 需要在 markdown-preview-enhanced 的设置项【Math Rendering option】选项中指明使用 mathjax 渲染。除此之外倒是没有发现需要独立安装其他package。 MathJax 项目的github MathJax 具体的使用文档 在markdown 中使用math jax 有两种用法：一种是行内公式，公式内容写在两个$中间，例如： 1$(x^&#123;(i)&#125;, y^&#123;(i)&#125;)$:ith training example, 代表训练集中的第i个数据 这种写法的展现效果如下： $(x^{(i)}, y^{(i)})$:ith training example, 代表训练集中的第i个数据另外一种是独立行公式，公式前后以$$为标记，例如： 123$$h_\theta(X)=\theta_0+\theta_1X$$ 这种写法的展现效果如下： $$h_\theta(X)=\theta_0+\theta_1X$$ 结语如上所述，介绍了atom 编辑markdown的一些插件和方法，至于一些更常用的操作，比如，如何导出pdf等，可以百度一下了。在atom 中使用markdown，可以有格式，有列表，有代码，有引用，有表格，有图标，有公式，基本可以满足所有的写作需求了。这还只是这些功能的皮毛而已，可见markdown真的是无敌的强大。]]></content>
      <categories>
        <category>Blog 写作 教程</category>
        <category>Atom 教程</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javah 命令详解]]></title>
    <url>%2F2017%2F08%2F19%2Fjava%2Fjavah%2F</url>
    <content type="text"><![CDATA[在JNI/NDK开发的过程中我们会遇到一个很关键的命令 javah 在ubuntu 上使用 man 命令查阅使用手册，可知 javah 命令的作用如下： javah - C Header and Stub File Generator. javah produces C header files and C source files from a Java class. These files provide the connective glue that allow your Java and C code tointeract. 简单讲就是为java类中的navtive方法生成 c 语言的头文件。先看下ubuntu上的帮助如下： 123456789101112131415$ javah --helpUsage: javah [options] &lt;classes&gt;where [options] include: -o &lt;file&gt; Output file (only one of -d or -o may be used) -d &lt;dir&gt; Output directory -v -verbose Enable verbose output -h --help -? Print this message -version Print version information -jni Generate JNI-style header file (default) -force Always write output files -classpath &lt;path&gt; Path from which to load classes -bootclasspath &lt;path&gt; Path from which to load bootstrap classes&lt;classes&gt; are specified with their fully qualified names(for example, java.lang.Object). 其中重要的几个参数 o d classpath 重点关注下。 遇到一坑在百度搜索 Android studio jni 开发，好多的文章都是这么写的： 再打开Terminal输入指令cd app/build/intermediates/classes/debug然后再输入指令javah -jni com.wobiancao.ndkjnidemo.ndk.JniUtils注意 这里javah -jni后面跟的是JniUtils类的全路径，如果javah报不存在之类的，是你的java环境没有配置好。摘自Android Studio ndk-Jni开发详细 注：本文不解决如何开始jni开发的问题，这个问题可参考Android Studio ndk-Jni开发详细 一般情况下这样写没啥问题，然后我的类是这个样子的时候，报错了： 12345678910111213package com.test.mylibrary;import org.json.JSONObject;public class Test &#123; public static String doTest(JSONObject jsObj) &#123; test(); return ""; &#125; public static native void test();&#125; 错误如下： 123456$ javah -jni com.test.mylibrary.TestError: Class org.json.JSONObject could not be found.$ javah -classpath ~/tools/adt-bundle/sdk/platforms/android-26/android.jar com.test.mylibrary.TestError: Could not find class file for &apos;com.test.mylibrary.Test&apos;.$ javah -classpath ./:~/tools/adt-bundle/sdk/platforms/android-26/android.jar com.test.mylibrary.TestError: Class org.json.JSONObject could not be found. 其实也没啥特别的就是import 了个JSONObject ，import 其他的类也没有问题，然后根据网上的各种经验指定classpath的路径，还是继续Error 。 解决其实也很简单，就是不要在build目录下执行即可，在src/main/java 目录下呢直接执行就可以了，不在src/main/java 目录下则指定classpath路径也可以，如下： 12345$ javah -jni com.test.mylibrary.Test$ cd ../$ javah -classpath java -jni com.test.mylibrary.Test$ cd ../$ javah -classpath main/java -jni com.test.mylibrary.Test 其中 -jni 生成jni格式的头文件是默认的，所以不写也是可以的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 编码规范]]></title>
    <url>%2F2017%2F08%2F12%2Fjava%2Fcode%20standards%2F</url>
    <content type="text"><![CDATA[1 介绍本规范参考java 官方编码规范，简化而来，更详细的介绍请参考Code Conventions for the Java TM Programming Language本规范适用但不限于OS Lite项目使用。 2 文件名这项目组列出了常用的文件名及其后缀。 2.1 文件后缀Java程序应用下列文件后缀： 文件类别 文件后缀 Java源文件 .java Java字节码文件 .class 2.2 常用文件常用的文件名包含： 文件名 用处 README.md 大的独立模块下用来说明该模块打使用注意事项等 3 文件组织一个文件由被空行分隔而成的段落以及标识每个段落的注释共同构成。超过2000行的程序难以浏览，应当尽量避免。 3.1 Java源文件若private类或interface与一个public类关系紧密，可以将它们放入同一个源文件，但是public类必须是这个文件中的第一个类或接口。 Java源文件应遵守以下规范： 开首注释 包和引入语句 类和接口声明 3.1.1 文件头注释为了方便生成api ref，所有的源文件都应当有文件头注释例如： 1234567/*** Version information** Date** Copyright notice*/ 3.1.2 包和引入语句在多半Java源文件中，第一个非注释行是包语句。在它之后可以跟引入语句 123package com.turing123.robotframe;import android.content.Context; 3.1.3 类和接口声明下表描述了类和接口声明 序号 类/接口声明的各项目 注解 1 类/接口文档注释（/*……/） 该注释中所需包含的信息，拜见”文档注释” 2 类或接口的声明 3 类的（静态）变量 开头是类的公共常量，最后是私有常量。 4 实例变量 同上 5 构造方法 6 成员方法 这些方法应当按功能分组。例如，一个私有的类方法可以置于两个公有的实例方法之间。其目标是为了更便于浏览代码。 4 缩进排版4个空格作为缩进排版的一个单位。 4.1 行长度尽量避免一行的长度跨越100个字符。 4.2 换行当一个表达式无法容纳在一行内时，可以根据如下规则断开之： 在一个逗号后面断开 在一个操纵符前面断开 新的一行应当与上一行同一级别表达式的开首处对齐 12public void prepare(@NonNull MessageInterceptor interceptor, @NonNull final RobotFramePreparedListener listener) if语句的换行,例如： 123456if (behaviors == null || behaviors.behaviors == null || behaviors.behaviors.size() == 0) &#123; //do something&#125; 三元运算表达式打换行，例如： 12345alpha = （aLongBooleanExpression） ？ beta : gamma;alpha = （aLongBooleanExpression）？ beta : gamma; 5 注释5.1 注释的格式程序可以有4种实现注释的风格：块（block）、单行（single-line）、尾端（trailing）和行末（end-of-line）。 5.1.1 块注释块注释每个文件的开端处以及每个方法之前。它们也可以被用于方法内部。在功能和方法内部的块注释应当和它们所描述的代码具有一样的缩进格局。 块注释可以以/**开头 123456/** * Set NLP Sever's ApiKey and Secret. * * @param apiKey Your ApiKey. * @param secret Your Secret. */ 5.1.2 单行注释短注释可以显示在一行内,单行注释之前应当有一个空行。 12345if （condition） &#123; /* Handle thecondition. */ ...&#125; 5.1.4 行末注释1234567891011121314151617if （foo &gt; 1） &#123; // Do adouble-flip. ...&#125;else &#123; return false; // Explain why here.&#125;//if （bar &gt; 1）&#123;//// // Do a triple-flip.// ...//&#125;//else &#123;// return false;//&#125; 5.2 文档注释文档注释描述Java的类、接口、方法以及字段（field）。每个文档注释都邑被置于注释定界符/*…/之中，一个注释对应一个类、接口或成员。该注释应位于声明之前，该注释将被用来生成javadoc api ref. 12345678910/** * Provide ASR function */public final class ASR extends FunctionBase&#123; /** * Chat Mode: CHAT_MODE_AUTO * Robot framework's chat will auto running, you needn't care about asr and ask the cloud. */ public static final int CHAT_MODE_AUTO = 0;&#125; 6 声明6.1 每行声明变量的数量推荐一行一个声明，因为这样利于写注释 12int level; // indentation levelint size; // size of table 6.2 初始化尽量在声明局部变量的同时初始化 6.3 布局只在代码块的开端处声明变量,不要在初次用到该变量时才声明它。 12345678void myMethod（） &#123; int int1 = 0; // beginning of method block if （condition） &#123; int int2 = 0; // beginning of "if"block ... &#125;&#125; 6.4 类和接口的声明当编写类和接口是，应当遵守以下格局规范： 在方法名与其参数列表之前的左括号”（”间不要有空格 左大括号”{“位于声明语句同业的末尾 右大括号”}”另起一行，与响应的声明语句对齐，除非是一个空语句，”}”应紧跟在”{“之后1234567891011121314151617181920212223242526public class Behavior &#123; public String exception; public IntentInfo intent; public Recommend recommend; public List&lt;ResponseResult&gt; results; public List&lt;Sequence&gt; sequences; public Emotion emotion; public Behavior() &#123; &#125; public Behavior(String exception) &#123; this.exception = exception; &#125; public Behavior(String exception, IntentInfo intent, Recommend recommend, List&lt;ResponseResult&gt; results, List&lt;Sequence&gt; sequences, Emotion emotion) &#123; this.exception = exception; this.intent = intent; this.recommend = recommend; this.results = results; this.sequences = sequences; this.emotion = emotion; &#125;&#125; 7 语句7.1 简单语句123argv++; // Correctargc--; // Correctargv++; argc--; // AVOID! 7.2 复合语句 被括此中的语句应当较之复合语句缩进一个层次 左大括号”{“应位于复合语句开端行的行尾；右大括号”}”应另起一行并与复合语句首行对齐。 7.3 返回语句一个带返回值的return语句不应用小括号”（）” 7.4 if，if-else，if else-if else语句（if， if-else， if else-if elseStatements）if-else语句应当具有如下格示： 1234567891011121314151617if （condition） &#123; statements;&#125;if （condition） &#123; statements;&#125; else &#123; statements;&#125;if （condition） &#123; statements;&#125; else if （condition） &#123; statements;&#125; else &#123; statements;&#125; 7.5 for语句一个for语句应当具有如下格示： 123for （initialization; condition; ） &#123; statements;&#125; 一个空的for语句应当具有如下格示： 1for （initialization; condition; ）; 7.6 while语句一个while语句应当具有如下格示： 123while （condition） &#123; statements;&#125; 一个空的while语句应当具有如下格示： 1while （condition）; 7.7 do-while语句一个do-while语句应当具有如下格示： 123do &#123; statements;&#125; while （condition）; 7.8 switch语句一个switch语句应当具有如下格示： 12345678910111213141516switch （condition） &#123;case ABC: statements; /* falls through */case DEF: statements; break;case XYZ: statements; break;default: statements; break;&#125; 7.9 try-catch语句一个try-catch语句应当具有如下格示： 12345try &#123; statements;&#125; catch （ExceptionClass e） &#123; statements;&#125; 或 1234567try &#123; statements;&#125; catch （ExceptionClass e） &#123; statements;&#125; finally &#123; statements;&#125; 8 空白8.1 空行空行将逻辑相干的代码段分隔开。 下列景象应当是应用两个空行： 一个源文件的两个片段（section）之间 类声明和接口声明之间 下列景象应当是应用一个空行： 两个方法之间 方法内的局部变量和方法的第一条语句之间 8.2 空格下列情况当应用空格： 一个紧跟着括号的关键字应当被空格分隔，例如： 123while （true） &#123; ...&#125; 注意：空格不该该置于法名与其左括号之间。这将有助于区分关键字和方法调用。 空白应当位于参数列表中逗号的后面 所有的二元运算符，除了”.”，应当应用空格将之与操纵数分隔。一元操纵符和操纵数之间不因该加空格，比如：负号（”-“）、自增（”++”）和自减（”–”）。例如： 9 命名规范 标识符类型 命名规范 例子 包 一个独一包名的前缀老是全部小写的ASCII字母并且是一个域名，这类命名规范可能以特定目次名的构成来区分部 门（department），项目（project）。 com.turing123.robotframe 类 命名规范：类名是个一名词，采取大小写混淆的体式格式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。应用完全单词，避免缩写词 class Behavior 接口 命名规范：大小写规范与类名类似 interface IASRCallback 方法 方法名是一个动词，采取大小写混淆的体式格式，第一个单词的首字母小写，其后单词的首字母大写。 void onStartRecord() 变量 除了变量名外，所有实例，包含类，类常量，均采取大小写混淆的体式格式，第一个单词的首字母小写，其后单词的首字母大写。变量名不该以下划线或美元符号开首，尽管这在语法上是容许的。变量名应简短且富于描述。变量名的选用应当易于记忆，即，可以或许指出其用处。尽量避免单个字符的变量名，除非是一次性的姑且变量。姑且变量凡是被取名为i，j，k，m和n，它们一般用于整型；c，d，e，它们一般用于字符型。 char c; 实例变量 大小写规范和变量名类似 常量 类常量应当全部大写，单词间用下划线隔开 public static final int CHAT_MODE_AUTO = 0 10 Java源文件示例下面的例子，显示了一公共类的Java源程序（仅作为示例）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.turing123.robotframe;import android.content.Context;/** * &lt;p&gt; * The entry to use RobotFrame.&lt;br/&gt;&lt;br/&gt; * Usage:&lt;br/&gt; * The method &lt;font color="blue"&gt;prepare&lt;/font&gt; must be called prior to any method calling on this frame. * The normal steps to use this frame are as blow:&lt;br/&gt; * 1. call &lt;font color="blue"&gt;getInstance()&lt;/font&gt;&lt;br/&gt; * 2. call &lt;font color="blue"&gt;prepare(prepareListener)&lt;/font&gt;&lt;br/&gt; * 3. waiting for prepareListener callback&lt;br/&gt; * 4.1 if success, call &lt;font color="blue"&gt;start()&lt;/font&gt; to launch the robot up&lt;br/&gt; * 4.2 if error occurred, check and fix the issue according to error message&lt;br/&gt; * 5. if robot is attempting to shutdown, call method &lt;font color="blue"&gt;shutDown(shutdownListener)&lt;/font&gt; * first and wait until the shutdownListener called back.&lt;br/&gt; * &lt;p&gt; * &lt;strong&gt;&lt;font color="red"&gt;WARNING: Any violation from the steps above will cause unpredictable * behaviors.&lt;/font&gt;&lt;/strong&gt; */public class RobotFrameManager &#123; /** * Chat Mode: CHAT_MODE_AUTO * Robot framework's chat will auto running, you needn't care about asr and ask the cloud. */ public static final int CHAT_MODE_AUTO = 0; /** * Chat Mode: CHAT_MODE_MANUAL * Robot framework‘s Chat requires manual call ASR and ask the cloud. * In this mode, the output mode only is &#123;@link #OUTPUT_MODE_ASSEMBLE&#125; */ public static final int CHAT_MODE_MANUAL = 1; private static RobotFrameManager mInstance = null; private FrameService mService; private Context mContext; public RobotFrameManager(Context context) &#123; mContext = context; SystemProperties.getInstance().init(context); mService = new FrameService(context); PluginService.setUp(mContext); &#125; /** * Be RobotFrame prepared, must be called prior to any calling to other method * * @param states the Frame working mode and states(if has) * @param listener the callback listener */ public void prepare(int states, @NonNull final RobotFramePreparedListener listener) &#123; mService.prepare(states,listener); &#125; /** * The robot starting run */ public void start() throws IllegalStateException &#123; mService.start(); &#125; /** * Set NLP Sever's ApiKey and Secret. * * @param apiKey Your ApiKey. * @param secret Your Secret. */ public void setApiKeyAndSecret(String apiKey, String secret) &#123; Preconditions.checkNotNull(apiKey, true); Preconditions.checkNotNull(secret, true); Settings.init(mContext); Settings.put(SettingsKey.TURING_APIKEY, apiKey); Settings.put(SettingsKey.TURING_SECRET, secret); Settings.deInit(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习笔记（二）]]></title>
    <url>%2F2017%2F08%2F07%2Fmachine-learning%2Fnote2%2F</url>
    <content type="text"><![CDATA[学习资源 6、2 - 1 - Model Representation 【中文】 学习内容监督学习的特点：针对每一个问题都给出了正确的答案 监督学习的过程可描述为：通过把Training Set 喂给 Learning algorithm 得出一个 hypothesis，然后传入要预测的特征值给得到的 hypothesis，从而得到预测的结果。 线性回归模型 是典型的且最简单的监督学习模型。 符号表示监督学习中关于Traning Set 定义了一些符号： m: number of Training set x’s: “input” variable/features y’2: “output” variable/“target” variable (x, y): one training example, 代表一个训练集中的数据 $(x^{(i)}, y^{(i)})$:ith training example, 代表训练集中的第i个数据 单变量的线性回归可用如下表达式表示：$$h_\theta(X)=\theta_0+\theta_1X$$]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习笔记（一）]]></title>
    <url>%2F2017%2F08%2F07%2Fmachine-learning%2Fnote1%2F</url>
    <content type="text"><![CDATA[背景介绍AI 已是大势所趋，况且又处在这个行业，又在一家人工智能的公司工作做聊天机器人的技术工作。然而，所做的工作又与机器学习基本毫不相干，这么高大上又前景颇好的东西近在眼前确触碰不到，多么可惜啊… 学习资源不知如何入门，在B站偶然发现Andrew Ng 的机器学习教程，争取可以坚持学完。第一天入门，主要学习以下内容: 1、1 - 1 - Welcome to Machine Learning【中英】 2、1 - 2 - Welcome【中英】 3、1 - 3 - What is Machine Learning【中英】 4、1 - 4 - Supervised Learning 【中英】 5、1 - 5 - Unsupervised Learning 【中文】 学习内容这几节主要其实主要是讲了机器学习的概念机器学习可以按照如下分类： 监督学习 无监督学习 监督学习主要分为两大问题：分类问题 和 回归问题。 分类问题预期的是有限个数的离散输出结果，典型的例子：根据已有的肿瘤大小与肿瘤恶性还是良性的数据，预测肿瘤是良性还是恶性的。 回归问题预期的是连续的输出结果，典型的例子：根据已有的房价与房屋面积的数据，已知房屋面积预测房屋价格。 无监督学习典型的算法有聚类算法： eg1: social network analysis 根据好友的互动数据，自动分组人群 eg2: market segmentation 根据客户数据，自动分类细分市场 使用工具的最佳建议学习机器学习，如果使用c++或java语言开发，代码会非常多，且需要链接到各种库去处理特殊功能。机器学习的研究者通常的做法是，先使用octave或Matlab语言实现好原型，在用其他的语言进一步开发。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Quick Start]]></title>
    <url>%2F2017%2F07%2F29%2Fblog-skill%2Fhexo-skill%2FHexoQuickStart%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" Create a new draft1$ hexo new draft "My new draft" Publish draft1$ hexo publish [layout] &lt;filename&gt; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog 写作 教程</category>
        <category>Hexo 教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
