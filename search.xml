<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android性能优化之帧率测试]]></title>
    <url>%2F2018%2F06%2F21%2Fandroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%A7%E7%8E%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[作为一名anroid开发，经常会听到产品或者测试说，他们感觉界面卡顿。然而这感觉二字该如何修改？须得以数字说话方可。人为感受界面的流畅度，转换为衡量指标，一般都使用帧率（FPS： frame per second）衡量。人眼感受界面流畅须得60fps方可，这样处理每一帧的时间就必须短于1000ms/60=16ms左右。android的UI绘制原理，叫垂直同步机制，简单描述就是每隔一个时间间隔（16ms),android 会发起一次中断，cpu/gpu 响应该中断就去判断一次是否有处理缓冲好的数据需要显示，如果有则将数据刷新到屏幕上，如果没有则再等一个时间间隔，这个时间间隔叫做vsync时间。假设16ms内没准备好要显示的数据，则cpu就不去刷新UI，结果就是在接下来的16ms内界面未发生变化，人眼就会感觉到动画的不连续，这就叫做卡顿。所以结合这个原理，我们只要获取到图像帧的处理数据，就可以用数据说明当前显示的动画是否发生了卡顿，进而有针对性的去分析卡顿的原因，从而解决问题。android 系统服务为我们提供了大量的工具来从系统获取信息，使用如下命令查看可获取哪些服务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677» adb shell service list Found 75 services:0 motionEventService: [android.hardware.robot.IMotionEventService]1 motionCtrlService: [android.hardware.robot.IMotionControlService]2 ledCtrlService: [android.hardware.robot.ILedControlService]3 keyEventService: [android.hardware.robot.IKeyEventService]4 media_router: [android.media.IMediaRouterService]5 assetatlas: [android.view.IAssetAtlas]6 dreams: [android.service.dreams.IDreamManager]7 commontime_management: []8 samplingprofiler: []9 diskstats: []10 appwidget: [com.android.internal.appwidget.IAppWidgetService]11 backup: [android.app.backup.IBackupManager]12 uimode: [android.app.IUiModeManager]13 serial: [android.hardware.ISerialManager]14 usb: [android.hardware.usb.IUsbManager]15 audio: [android.media.IAudioService]16 wallpaper: [android.app.IWallpaperManager]17 dropbox: [com.android.internal.os.IDropBoxManagerService]18 search: [android.app.ISearchManager]19 country_detector: [android.location.ICountryDetector]20 location: [android.location.ILocationManager]21 devicestoragemonitor: []22 notification: [android.app.INotificationManager]23 updatelock: [android.os.IUpdateLock]24 servicediscovery: [android.net.nsd.INsdManager]25 connectivity: [android.net.IConnectivityManager]26 wifi: [android.net.wifi.IWifiManager]27 wifip2p: [android.net.wifi.p2p.IWifiP2pManager]28 netpolicy: [android.net.INetworkPolicyManager]29 netstats: [android.net.INetworkStatsService]30 textservices: [com.android.internal.textservice.ITextServicesManager]31 network_management: [android.os.INetworkManagementService]32 clipboard: [android.content.IClipboard]33 statusbar: [com.android.internal.statusbar.IStatusBarService]34 device_policy: [android.app.admin.IDevicePolicyManager]35 lock_settings: [com.android.internal.widget.ILockSettings]36 mount: [IMountService]37 accessibility: [android.view.accessibility.IAccessibilityManager]38 input_method: [com.android.internal.view.IInputMethodManager]39 bluetooth_manager: [android.bluetooth.IBluetoothManager]40 input: [android.hardware.input.IInputManager]41 window: [android.view.IWindowManager]42 alarm: [android.app.IAlarmManager]43 consumer_ir: [android.hardware.IConsumerIrService]44 vibrator: [android.os.IVibratorService]45 battery: []46 hardware: [android.os.IHardwareService]47 content: [android.content.IContentService]48 account: [android.accounts.IAccountManager]49 user: [android.os.IUserManager]50 entropy: []51 permission: [android.os.IPermissionController]52 cpuinfo: []53 dbinfo: []54 gfxinfo: []55 meminfo: []56 procstats: [com.android.internal.app.IProcessStats]57 activity: [android.app.IActivityManager]58 package: [android.content.pm.IPackageManager]59 scheduling_policy: [android.os.ISchedulingPolicyService]60 telephony.registry: [com.android.internal.telephony.ITelephonyRegistry]61 display: [android.hardware.display.IDisplayManager]62 appops: [com.android.internal.app.IAppOpsService]63 usagestats: [com.android.internal.app.IUsageStats]64 batterystats: [com.android.internal.app.IBatteryStats]65 power: [android.os.IPowerManager]66 sensorservice: [android.gui.SensorServer]67 media.audio_policy: [android.media.IAudioPolicyService]68 media.camera: [android.hardware.ICameraService]69 batterypropreg: [android.os.IBatteryPropertiesRegistrar]70 media.player: [android.media.IMediaPlayerService]71 media.audio_flinger: [android.media.IAudioFlinger]72 SurfaceFlinger: [android.ui.ISurfaceComposer]73 drm.drmManager: [drm.IDrmManagerService]74 android.security.keystore: [android.security.keystore] 获取帧相关信息主要会用到其中的两个service：SurfaceFlinger 和 gfxinfo。 第一步在设置–&gt;开发者选项–&gt;GPUU呈现分析中选择通过adb分析第二步 看下当前的界面显示layer情况12345678» » adb shell dumpsys SurfaceFlinger --list zhaojie@zhaojie-desktopDimLayerDimLayercom.ijourney.bindrobot/com.ijourney.bindrobot.MainBindActivityFocusedStackFrameSurfaceViewDimLayerDimLayer 其中每一行可以理解为是一个图层，找到我们想要查看的图层比如：com.roobo.bindrobot 第三步 获取帧信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219» adb shell dumpsys gfxinfo com.ijourney.bindrobot zhaojie@zhaojie-desktopApplications Graphics Acceleration Info:Uptime: 320375 Realtime: 320375** Graphics info for pid 610 [com.ijourney.bindrobot] **Recent DisplayList operations ConcatMatrix DrawBitmap RestoreToCount DrawDisplayList Save ClipRect DrawText RestoreToCount RestoreToCount DrawDisplayList DrawDisplayList DrawRoundRect DrawRoundRect Save ClipRect DrawDisplayList Save ConcatMatrix DrawBitmap RestoreToCount DrawDisplayList Save ClipRect DrawText RestoreToCount RestoreToCount DrawDisplayList DrawDisplayList DrawDisplayListDrawRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawRoundRectDrawBitmapmultiDraw DrawBitmapmultiDraw DrawBitmapDrawBitmapmultiDraw DrawTextCaches:Current memory usage / total memory usage (bytes): TextureCache 3084240 / 25165824 LayerCache 0 / 16777216 RenderBufferCache 0 / 2097152 GradientCache 0 / 524288 PathCache 240 / 10485760 TextDropShadowCache 0 / 2097152 PatchCache 2880 / 131072 FontRenderer 0 A8 524288 / 524288 FontRenderer 0 RGBA 0 / 0 FontRenderer 0 total 524288 / 524288Other: FboCache 0 / 16Total memory usage: 3611648 bytes, 3.44 MBProfile data in ms: com.ijourney.bindrobot/com.ijourney.bindrobot.MainBindActivity/android.view.ViewRootImpl@41937b60 Dirty Regions: Disabled Draw Process Execute 1.39 3.84 0.93 2.46 2.92 0.90 2.77 4.02 1.09 1.79 4.36 1.24 1.78 4.47 1.30 1.51 3.76 1.57 1.82 4.39 1.39 1.62 4.48 1.41 1.46 4.18 1.78 2.55 5.81 1.08 1.78 4.21 1.91 1.77 3.62 5.87 1.84 4.04 1.78 2.03 3.21 1.17 1.89 3.53 1.16 1.55 3.90 1.47 2.24 3.32 1.05 2.14 3.63 1.12 1.58 3.52 0.99 1.52 2.66 1.30 1.44 2.68 1.15 1.42 2.67 1.19 1.39 2.65 2.55 1.77 3.72 1.31 1.22 2.75 0.93 1.63 2.95 1.24 1.30 3.15 1.41 1.49 2.94 1.03 0.69 2.16 0.84 1.98 2.90 0.97 1.56 2.96 0.99 1.37 3.03 1.19 1.27 3.29 1.11 1.16 2.93 1.08 0.86 2.62 0.90 0.85 2.55 0.86 3.14 3.03 0.86 0.93 2.85 1.28 681.97 17.91 1.26 0.84 3.04 2.06 1.27 2.31 1.42 0.71 1.96 0.85 535.65 15.30 1.26 0.97 4.25 1.56 501.46 10.01 1.21 0.39 2.50 1.52 0.77 3.04 1.72 0.79 3.54 1.25 1.16 2.12 1.35 0.41 1.54 0.76 0.57 2.93 1.35 1.72 4.07 3.81 1.43 2.43 0.93 0.50 1.54 0.82 1.49 2.49 1.06 0.64 1.75 1.04 1.30 3.32 1.53 1.43 3.62 1.68 0.45 1.92 0.99 1.75 3.44 1.80 0.46 1.79 1.05 2.00 3.03 2.35 0.45 1.71 0.96 0.51 2.74 1.16 0.62 3.07 1.27 1.31 2.35 1.14 0.42 1.56 0.78 0.66 3.09 1.34 1.36 2.35 1.06 1.40 2.28 1.00 0.45 1.80 0.94 1.26 3.32 2.75 0.42 1.83 1.06 1.42 0.25 1.26 0.57 0.52 3.39 0.78 0.31 1.34 13.63 3.78 2.18 2.08 8.65 3.25 2.27 5.36 1.58 1.50 5.01 1.37 1.23 6.11 1.25 1.48 3.14 1.07 1.14 3.26 1.55 1.24 3.86 1.44 1.29 3.88 1.43 1.53 4.06 1.55 1.09 3.20 1.33 1.14 2.65 1.34 1.17 2.55 1.44 1.11 2.55 1.87 1.28 3.19 1.22 0.45 3.12 2.65 1.85 3.01 1.18 0.78 3.29 1.51 0.80 4.20 1.63 0.90 3.63 0.93 0.88 3.55 1.36 0.49 3.83 3.38 0.47 3.90 2.18 0.88 2.70 1.34 0.79 3.46 1.10 0.83 3.45 1.20 0.99 3.30 1.33 0.70 2.99 1.09 0.66 2.57 1.36 0.74 3.01 1.18 0.71 3.32 1.38 0.85 3.87 1.39 0.98 3.33 1.41 0.88 5.22 1.98 0.81 3.48 2.16 0.72 2.85 3.44 0.44 2.62 1.15 2.31 2.57 0.86 1.14 2.83 0.85 0.77 2.57 0.86 0.79 2.99 0.94 1.07 3.97 1.08 1.21 5.06 0.96 3.09 2.97 1.08 1.07 2.91 0.95 1.16 3.48 1.10 1.14 3.26 1.08 1.36 2.95 1.07 1.41 3.08 1.31 2.23 3.82 1.08 1.28 2.89 0.82 1.36 2.38 1.74View hierarchy: com.ijourney.bindrobot/com.ijourney.bindrobot.MainBindActivity/android.view.ViewRootImpl@41937b60 50 views, 3.78 kB of display lists, 348 frames renderedTotal ViewRootImpl: 1Total Views: 50Total DisplayList: 3.78 kB 上面的数据中包含128帧最新的耗时数据 第四步，利用excel生成堆积柱状图如下：这样就一目了然的看出图像显示的耗时情况，也能分析出是否会出现掉帧。]]></content>
      <categories>
        <category>android</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robot OS 框架杂谈]]></title>
    <url>%2F2018%2F06%2F21%2FRobot-OS-%E6%A1%86%E6%9E%B6%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[大概是2015年开始，人工智能突起，出现了非常多家的机器人公司，其中有一类发力于家庭服务机器人。为了满足各家机器人的使用需要，各家争相开发自己的机器人OS，或者叫机器人框架。时至今日，有的机器人OS已经死亡，有的奄奄一息，有的还在继续成长，有的已经成熟。有幸接触了几家的OS，现罗列如下，以作纪念。 总章何为机器人OS目前或者说之前，大家通常的做法都是在andrid系统之上，添加诸如asr\tts\nlp等相关功能，添加自己的业务逻辑已实现自己的需求，这样的一套东西，合起来通常被叫做机器人OS。另外现在家庭娱乐类型的机器人基本都得联网使用，其核心处理逻辑，诸如语义理解、图像识别多需在线完成，所以机器人OS也该包含相应的云端服务。综上，机器人OS可以描述为，承载了交互规范，集成了机器人基本能力，对不同用户场景进行调度的一套框架；分为两大部分：终端展示层和云端核心大脑层。本文重点描述各家终端机器人的框架 TuringOS 1.5TuringOS1.5 是北京光年无限开发（图灵机器人）开发的基于android深度定制的机器人OS，其核心组成部分如上图。 图灵机器人OS开放生态这部分主要包含图灵的云端大脑（提供语义服务及场景决策相关），支持自定义意图的平台、终端的OS。终端的OS与android系统深度耦合，主要核心服务运行在SystemServer进程中。主要核心服务按照大的模块可分为两部分：基础支撑和交互逻辑。基础支撑主要定义了机器人的输入输出，输入包括asr(听)、机器视觉（看）、传感器（触），输出主要包括tts(说)、表情（情绪）、动作（身）、LED等。图灵将这样的一种多种输入与多种输出同时与用户交互定义为多模特输出。交互逻辑主要定义了语音交互的对话流程，既语音交互界面，类比触摸输入与屏幕展示，基础对话服务可理解为VUI（Voice user interface)的基础；交互逻辑的另一主要部分是场景切换逻辑，主要规定了场景的优先级及场景切换策略。场景管理切换主要依托于android的packagemanager 和 activiymanager进行，好处是利用了android已经有的机制，坏处是与android系统绑定太紧,对于想打造一款真正的类似windows/android这样的机器人操作系统来说，这样做是好的，但是对于大多数希望快速盈利的公司，这种深度耦合，增加了移植成本，所以turing的这种深耦合做法遭到了大家的鄙夷。终端OS部分，另一重要的部分是对云端协议的解析，这是控制机器人的中枢指令，相当重要。另外终端OS也包含一些自由的资源文件、以及为保护这些所添加的加密芯片等。 图灵机器人SDKturingOS 1.5设计之初就在为平台化做准备，所以为了支撑这一目标，提供了完备的SDK及SDK的使用文档，为了配合开发者为平台开发应用，还在OS内部集成了对开发好的应用进行合法性检查的模块。不同于别家的SDK，turingOS1.5的SDK 与android sdk融合在了一起，这样使的整个图灵OS看起来更像是一个完整的OS，而不是跑在android系统之上的一个APP，可惜了，在当时，这样的设计太过超前，在没有持续投入的情况下，伟大的目标往往是悲剧的开端。 图灵APK图灵apk 主要有三方来源，一是自己开发的核心功能组件，二是自己开发的核心业务场景apk，三是授权开发者开发的场景apk。 在此，turingOS1.5死的颇为可惜，哀悼与怀念三分钟。 TuringOS LiteturingOS Lite 与turingOS1.5思想上一脉相承，是turingOS1.5的子孙后代。上图为turingOSLite 在android整个框架中的位置，也大致分为三个部分 TuringOSLite 本体turingOSLite 其实早期被称作机器人开发框架，设计原则是小而轻便，灵活易替换易扩展。对于他来说重要的是概念，在这个框架上定义了三个核心的概念：场景（scenario）和功能（function),以及控制场景调用功能的事件拦截器。场景是机器人的业务单元，代表用户的应用场景。功能是机器人的固有能力，表达的是机器人的固有属性。除此之外对于turingOSLite一切具像的场景和功能都不重要，因为核心就是定义出这些概念，具体实现不同的开发者按照自己的思路去实现就好了。感觉这是图灵又走了另外一个极端，太实则太重，太虚则无力。当时的意图可能觉得图灵的核心是语义这些表象的东西定义好规范，让别人去照做也不影响核心业务。导致最后竞争力较弱，颇显惋惜。 TuringOS Lite API实质上，TuringOSLite 可算作是个早产儿，发育还不足月。作为一个SDK，必须与开发出的应用绑定在一起，作为API只是对核心功能的暴露，虽然在逻辑分层上存在api这一层，但是它确是与核心服务物理上在一块的，此处还有较大改进空间。 TuringOS Lite 场景此处的场景就不是以独立apk的形式存在了，物理上就是一个实现了Scenario接口的类，顶多算个个语义上的存在。当然可以按照TuringOSLite 插件的形式去开发这些类。 Roobo ROS.AI为什么roobo的ROS（此ROS 非彼ROS）还活着，窃以为它介于TuringOS1.5 和 TuringOSLite 之间。ROS 也是基于android定制的，但是没有把核心服务死死的绑定到android的framework里，也向外提供api,但是使用此api开发的应用又都是实实在在的安卓apk。从框图上看，也可将其分为三部分。 ROS 核心服务群核心服务主要包含两部分，管理核心服务的框架和具体的核心服务实现，核心服务框架为core.apk，具体的服务实现为各种service apk，这些service均挂载在core上由core统一对外提供服务。在core当中另外一个重要的工作是场景管理和焦点管理，焦点管理用来解决硬件资源使用冲突的问题，焦点这个思想应该是来源于android的音频焦点管理。 ROS SDKROS 的SDK 主要包含两部分内容，能力API和负责场景APK和core之间的跨进程通信。实现还是相对巧妙的，SDK中有一默认的DefaultService，当Core去管理场景APK时，通过启动这个service从而带起整个场景APK的进程，然后创建通信渠道，发送指令。而这一切都在SDK中做好了，对于场景APK来说都是无感的，这样进一步降低了android app开发者在ROS上开发应用的难度。 ROS AppROS APP 与 android app 大体上无异，不同之处就在上面刚提到的app中的sdk部分创建的进程间通信渠道，另一不同之处在于清单文件中加了几个标识，以表明这是个ROS的场景，场景的名称叫什么，这些信息会被core收集，从而用来对其进行管理。 总之，不错。 腾讯小薇腾讯小薇是私以为就是个智能音箱方案，强用来做机器人略显不合适，具体结构见上图，有个特点就是，他的场景在未创建前都是通用的模板类，创建具体的skills对象时，结合skills 类和具体的 appkit组合而成处理具体业务的skills对象。还有两点长处：一是，跨平台：其核心控制层可按不同平台编译为不同的so库（c++开发）;二是，资源优势：毕竟腾讯家的音视频资源还是很有优势的。]]></content>
      <categories>
        <category>机器人OS</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu grub 引导丢失修复]]></title>
    <url>%2F2018%2F03%2F13%2Fubuntu-grub-%E5%BC%95%E5%AF%BC%E4%B8%A2%E5%A4%B1%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[第一章 工作就得这么弄自己家的电脑，需要能写代码，也要能供不写代码的时候用，比起ubuntu来说，win10还是要好用非常多的，何况买的dell品牌台式机，win1o 是正版的，office是正版的，还有dell的一堆服务，废了多可惜啊，都是钱买的。所以一狠心，一咬牙装了个win10+ubuntu的双系统。 两年了，除了装系统的时候费了点事，一直以来大家相安无事，各过各的。ubuntu一路从16.04升级到了17.10没出过任何叉子，windows10？还好吧，一直以来也本本分分的。 直到昨天晚上，都要睡觉了，翻着墙看了个乐视网的微电影。这有毛病吗？关机的时候，点错了，关机按钮点到了重启上，这有毛病吗？然后就重启了，然后就没出现grub的引导，直接进入了win10。心里暗骂一句，微软流氓，肯定是悄悄升级了，还改了efi文件。多大点事啊，上网找个攻略修一下也就好了，遂找了一篇，照着鼓捣。这次倒好，直接提示，没有可引导的设备。 第二章 那无眠的夜说来网上的文章也有些坑人，绝大多数都是legacy+mbr引导，对于uefi+gpt方式的引导，真是少，或者是怪我瞎？从11点弄到凌晨3、4点，尝试了无数遍easybcd，easyefi都没整成，放弃了，睡觉吧，反正现在都没有可引导的设备了。 第三章 需要一个livecd 启动盘还好，找着一个U盘，还好，里面还有个ubuntu系统。感谢Startup Disk createor ！！！ 第四章 执行命令在坚持不起作用时，最好的方法是睡觉。觉醒后，从uefi u盘启动，执行如下命令：1sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get update 有提示，按回车1sudo apt-get install -y boot-repair &amp;&amp; boot-repair 等一会，执行界面上的recommended repair 等着吧，一会就好了。当然也不能干等着，人家提示你forword的时候你就forword，提示打开终端执行命令，你就把他提示的命令复制到终端里执行一遭。若是失败了？那你就按他说的再做一遍也就成了。 第五章 大功告成撒花，撒花，看到grub 了，就是里边的内容有点多，那就进入ubuntu，必须说一下，还是ubuntu用起来顺手啊，关键是方便，进/boot分区下，把那些不会再用到的内核删了，然后执行1sudo update-grub 至此算是搞定了，记录一下，以兹纪念！]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android O 电源管理之从设备唤醒谈起]]></title>
    <url>%2F2018%2F03%2F11%2Fandroid-O-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E4%B9%8B%E4%BB%8E%E8%AE%BE%E5%A4%87%E5%94%A4%E9%86%92%E8%B0%88%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[为何从此谈起andoird PowerManagerService 中有一个成员变量mWakefulness，其定义如下：123// Indicates whether the device is awake or asleep or somewhere in between.// This is distinct from the screen power state, which is managed separately.private int mWakefulness; 注释写的很明白，用来指示当前设备是醒是睡还是处于半醒半睡间的某中状态，本文即从此处讲起。 无论设备电源状态如何变化，走了多少曲折的流程，最终会层层调用到对该变量的修改，用以指示设备电源变化后的状态，设备唤醒也不例外。常见的分析电源管理的文章多分析电源管理的框架结构及调用流程，鲜有对唤醒后，睡眠前其他模块所做工作的描述。本篇即主要阐述设备从睡眠状态唤醒，设置mWakefulness为WAKEFULNESS_AWAKE后，整个系统都做了些什么。 摸着代码过河起点则从setWakefulnessLocked开始，至于是从何处调用过来的，以后再说，其源码如下：123456789private void setWakefulnessLocked(int wakefulness, int reason) &#123; if (mWakefulness != wakefulness) &#123; mWakefulness = wakefulness; mWakefulnessChanging = true; mDirty |= DIRTY_WAKEFULNESS; //定义于frameworks/base/services/core/java/com/android/server/power/Notifier.java中 mNotifier.onWakefulnessChangeStarted(wakefulness, reason); &#125;&#125; 可见mWakefulness修改之后一方面标记了wakefulness修改过（mWakefulnessChanging 和 mDirty 的标记将在updatePowerStateLocked 函数中做为wakefulness修改过的证据）；一方面则调用了mNotifier的方法 onWakefulnessChangeStarted，在这个方法的后面就是android系统的一些核心服务对电源状态变化的响应了。 哪些service会做出响应那些直接响应了interactive变化的manager先摘录Notifier的注释如下以说明它是何物： 123456789101112131415161718/** * Sends broadcasts about important power state changes. * &lt;p&gt; * This methods of this class may be called by the power manager service while * its lock is being held. Internally it takes care of sending broadcasts to * notify other components of the system or applications asynchronously. * &lt;/p&gt;&lt;p&gt; * The notifier is designed to collapse unnecessary broadcasts when it is not * possible for the system to have observed an intermediate state. * &lt;/p&gt;&lt;p&gt; * For example, if the device wakes up, goes to sleep, wakes up again and goes to * sleep again before the wake up notification is sent, then the system will * be told about only one wake up and sleep. However, we always notify the * fact that at least one transition occurred. It is especially important to * tell the system when we go to sleep so that it can lock the keyguard if needed. * &lt;/p&gt; */final class Notifier 再摘录onWakefulnessChangeStarted的注释如下以说明它将作何用处：1234567/** * Notifies that the device is changing wakefulness. * This function may be called even if the previous change hasn't finished in * which case it will assume that the state did not fully converge before the * next transition began and will recover accordingly. */public void onWakefulnessChangeStarted(final int wakefulness, int reason) 此方法一进来先判断了下变化后的wakefulness是否为可交互的状态，判断的标准则是wakefuleness是否为WAKEFULNESS_AWAKE 或是 WAKEFULNESS_DREAMING，也就是说设备在唤醒状态及屏保状态，系统认为设备处在一种可交互的状态下。本篇主要分析的是AWAKE后的事，所以将略过变为其他状态时的处理。 ActivityManager的响应12345678// Tell the activity manager about changes in wakefulness, not just interactivity.// It needs more granularity than other components.mHandler.post(new Runnable() &#123; @Override public void run() &#123; mActivityManagerInternal.onWakefulnessChanged(wakefulness); &#125;&#125;); 在唤醒后，ActivityManager将调用到方法updateSleepIfNeededLocked，此方法根据当前是否是睡眠及接下来是否应该睡眠作为判断条件（是否应该继续睡眠由传入的wakefulness，及是否是语音交互，当前是否显示键盘锁等条件综合判定），因此处讨论的是唤醒后大家都做了什么，所以唤醒后假定也没有键盘锁，也没有像屏保等的阻止栈顶activity进入可交互状态的sleepToken，也就是说可以顺利往下执行唤醒操作的情况下，ActivityManager 做了如下操作 修改当前不再是睡眠状态 重新跟踪resumed activity的时长。 设置当前栈顶activity所在进程状态为PROCESS_STATE_TOP 标记activities的sleep状态为false，该操作将触发调用onStart，之后会调用在休眠前正处于pausing状态的activity走完pause流程 如果是VR模式，则通知VRManagersleep状态为false 调用updateOomAdjLocked 接下来的执行，只有在交互状态确实改变的情况下（保存的是否为交互状态与本次wakefulness改变判定的状态是否一致）才会继续进行。执行主要涉及的是WindowManagerPolicy。 WindowManagerPolicy的响应继续之前的流程，假定现在交互的状态确实发生了变化（根据本次修改wakefulness的值判断得到的interactive与保存的mInteractive的值不同）。 假设此次的交互状态变化时，上次的变化还未结束，（再次提醒，我们讨论的是唤醒后的系统响应，即之前的交互状态为false），则会先完成上一次的交互状态改变，调用了WindowManagerPolicy的finishGoingToSleep方法，具体做了如下操作： 标记“正在进入sleep”这个状态为false。 开始接收手势传感器的事件以使能手势唤醒功能。 disable 方向传感器 重新计算锁屏界面超时时间 调用键盘锁服务的onFinishedGoingToSleep方法，并标注键盘锁交互状态为INTERACTIVE_STATE_SLEEP 将在sleep状态时可使用camera手势（双击电源键唤醒相机）的标记置为false。 之后，修改PowerManagerService内部的mInteractive为true，然后调用WindowManagerPolicy的startWakeingUp方法，具体做了的操作如下： 标记 awake 状态为 true。 不再接收手势传感器事件以diable调手势唤醒功能 enable方向传感器 调用键盘锁服务的onStartedWakingUp方法，并标记键盘锁交互状态为INTERACTIVE_STATE_AWAKE InputManager 的响应看到的只是将native层InputManagerService中的mInteractive置为了true。因为在sleep的时候置为了false，而mInteractive应该会影响到是否对输入进行响应。 InputMethodManager 的响应 设置了可交互状态为true。 更新systemui 决定是否要显示输入法 设置输入法为interactive为true。 BatteryStats 的响应 设置可交互状态标记为true 启动mInteractiveTimer 响应ACTION_SCREEN_ON的系统组件以上各相关manager处理完之后，Notifier 还会发送出Intent.ACTION_SCREEN_ON 广播，一些系统服务收到后会做一些操作 AlarmManagerService 处理那些在休眠阶段到时间但是nonWakeup的闹钟 更新例如最大延迟时间等变量的值AudioService 使能RotationHelper，这样屏幕旋转时可调节双speaker方案的左右声音输入，sleep的时候会disable掉RotationHelper以减少由于屏幕方向变化导致的唤醒 向底层audio device设置screenState参数为on，用来修改声音输出帧率FMRadioService退出FM的低电模式GestureManagerServicestop gesture service when screen on and unregister pocket sensorGnssLoctionProvider退出gps的低电模式 还有一些其他的service也在响应ACTION_SCREEN_ON，此处就不一一列出了]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android包管理之App安装前的校验]]></title>
    <url>%2F2018%2F02%2F06%2FAndroid%E5%8C%85%E7%AE%A1%E7%90%86%E4%B9%8BApp%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[初识Package Verification之前在做机器人操作系统的时候有过这样的需求，希望在安装应用的时候判断该应用是否符合机器人系统的操作规范，说白了就是需要扫描一下这个apk，是否符合某些规则。当然，这个需求可以在andoird 安装应用的过程实现。但是查看源码发现了Package Verification，这是一个没有多少文档介绍也没有相应demo的特性。最近在做车机系统的时候，大家讨论热修复，聊到在海外渠道以及一些海外应用商店平台上，禁止带有热修复功能的应用上架，甚至带有热修复功能的app安装都不会成功。聊到此处想起了Package Verification，料想使用此特性实现的。早在android J 中就在PackageManagerService源码中加入了此特性。大体思路是，在安装应用前会发送一个需要对此包进行验证的广播，该广播可叫做Verify Request，如果系统中有实现了该广播的Receiver，则该应用被叫做Verifier，则Verifier取得广播中携带的附属信息，包括包的路径等，则通过或是扫描该包或是对比其他信用，总之对要安装的这个应用做出校验，然后调用PowerManager的接口告诉PowerManagerService 本次校验是否通过，通过则继续执行安装过程，否则提示用户安装被拒绝。也可以讲，android通过这样的方式，将android包安装校验这一任务外包给了第三方应用（通常为应用商店等）进行校验。比如校验不通过会弹出如下的界面(就算没见过这个，也见过类似的吧)： 使用Package VerificationVerify 流程如下：其中verifier 检查要安装的应用这个子过程即可实现为一个独立应用，在其中做具体的校验逻辑。 Verify 过程中使用到的PackageManager API请求对即将安装的包进行验证PackageManagerService 会在应用安装前发送ACTION_PACKAGE_NEEDS_VERIFICATION 广播请求对要安装的包进行验证，它会携带PowerManager.EXTRA_VERIFICATION_ID 待Verifier验证结束后会使用该ID通知PackageManagerService验证结果。另外几个在API中被hide的附属值为： EXTRA_VERIFICATION_URI EXTRA_VERIFICATION_INSTALLER_PACKAGE EXTRA_VERIFICATION_INSTALL_FLAGS EXTRA_VERIFICATION_INSTALLER_UID EXTRA_VERIFICATION_PACKAGE_NAME EXTRA_VERIFICATION_VERSION_CODE另外，应用程序也可在自己的manifest中使用标签来指定Verifier 例如：123&lt;package-verifier android:name="org.mycompany.verifier" android:publicKey="Zm9vYmFy..." /&gt; 这类Verifier被叫做Sufficient Verifiers，配置中的publickey 为 应用安装完成后在/data/system/package.xml 中保存的对应应用的编码。 Verifier 的实现Verifier 需要具有权限PACKAGE_VERIFICATION_AGENT，然后实现接受ACTION_PACKAGE_NEEDS_VERIFICATION广播的BroadcastReceiver。待校验结束后调用PackageManager.verifyPendingInstall 返回校验结果，结果常量为： PowerManager.VERIFICATION_ALLOW PowerManager.VERIFICATION_REJECT结果返回后会被PackageManagerService处理响应 Package Verification 机制实现分析。Package Verification 机制的实现在PackageManagerService中，与应用的安装过程紧紧的结合在一起，但此处不在介绍安装过程。当安装进行到函数startCopy这一步时，在handleStartCopy方法中有如下代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192if (ret == PackageManager.INSTALL_SUCCEEDED) &#123; // TODO: http://b/22976637 // Apps installed for "all" users use the device owner to verify the app UserHandle verifierUser = getUser(); if (verifierUser == UserHandle.ALL) &#123; verifierUser = UserHandle.SYSTEM; &#125; /* * Determine if we have any installed package verifiers. If we * do, then we'll defer to them to verify the packages. */ // mRequiredVerifierPackage 和 mOptionalVerifierPackage在 // PackageManagerService初始化时初始化 final int requiredUid = mRequiredVerifierPackage == null ? -1 : getPackageUid(mRequiredVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, verifierUser.getIdentifier()); final int optionalUid = mOptionalVerifierPackage == null ? -1 : getPackageUid(mOptionalVerifierPackage, MATCH_DEBUG_TRIAGED_MISSING, verifierUser.getIdentifier()); final int installerUid = verificationInfo == null ? -1 : verificationInfo.installerUid; if (!origin.existing &amp;&amp; (requiredUid != -1 || optionalUid != -1) &amp;&amp; isVerificationEnabled( verifierUser.getIdentifier(), installFlags, installerUid)) &#123; // 开始构造请求Verify的广播的Intent final Intent verification = new Intent( Intent.ACTION_PACKAGE_NEEDS_VERIFICATION); verification.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); verification.setDataAndType(Uri.fromFile(new File(origin.resolvedPath)), PACKAGE_MIME_TYPE); verification.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // Query all live verifiers based on current user state // 把当前所有能做校验的Receiver都找出来。 final List&lt;ResolveInfo&gt; receivers = queryIntentReceiversInternal(verification, PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier()); if (DEBUG_VERIFY) &#123; Slog.d(TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers"); &#125; // 生成此次的verificationId，用来唯一标识此次校验 final int verificationId = mPendingVerificationToken++; // 添加需要携带给Verifier 的数据 verification.putExtra(PackageManager.EXTRA_VERIFICATION_ID, verificationId); verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_PACKAGE, installerPackageName); verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALL_FLAGS, installFlags); verification.putExtra(PackageManager.EXTRA_VERIFICATION_PACKAGE_NAME, pkgLite.packageName); verification.putExtra(PackageManager.EXTRA_VERIFICATION_VERSION_CODE, pkgLite.versionCode); if (verificationInfo != null) &#123; if (verificationInfo.originatingUri != null) &#123; verification.putExtra(Intent.EXTRA_ORIGINATING_URI, verificationInfo.originatingUri); &#125; if (verificationInfo.referrer != null) &#123; verification.putExtra(Intent.EXTRA_REFERRER, verificationInfo.referrer); &#125; if (verificationInfo.originatingUid &gt;= 0) &#123; verification.putExtra(Intent.EXTRA_ORIGINATING_UID, verificationInfo.originatingUid); &#125; if (verificationInfo.installerUid &gt;= 0) &#123; verification.putExtra(PackageManager.EXTRA_VERIFICATION_INSTALLER_UID, verificationInfo.installerUid); &#125; &#125; // 创建PackageVerificationState 对像用来跟踪校验状态。 final PackageVerificationState verificationState = new PackageVerificationState( requiredUid, args); // 把verificationState保存起来，方便以后查找使用。 mPendingVerification.append(verificationId, verificationState); // 获取到sufficientVerifiers，上文提到过，其中pkgLite经过解析manifest而来 final List&lt;ComponentName&gt; sufficientVerifiers = matchVerifiers(pkgLite, receivers, verificationState); // 这里应该是android6.0 后添加的，避免在校验的过程中系统进入休眠。 DeviceIdleController.LocalService idleController = getDeviceIdleController(); final long idleDuration = getVerificationTimeout(); /* * If any sufficient verifiers were listed in the package * manifest, attempt to ask them. */ if (sufficientVerifiers != null) &#123; final int N = sufficientVerifiers.size(); if (N == 0) &#123; Slog.i(TAG, "Additional verifiers required, but none installed."); ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; &#125; else &#123; for (int i = 0; i &lt; N; i++) &#123; final ComponentName verifierComponent = sufficientVerifiers.get(i); // 与doze模式相关，避免休眠 idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier"); final Intent sufficientIntent = new Intent(verification); sufficientIntent.setComponent(verifierComponent); // 发送验证请求 mContext.sendBroadcastAsUser(sufficientIntent, verifierUser); &#125; &#125; &#125; if (mOptionalVerifierPackage != null) &#123; final Intent optionalIntent = new Intent(verification); optionalIntent.setAction("com.qualcomm.qti.intent.action.PACKAGE_NEEDS_OPTIONAL_VERIFICATION"); final List&lt;ResolveInfo&gt; optional_receivers = queryIntentReceiversInternal(optionalIntent, PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier()); final ComponentName optionalVerifierComponent = matchComponentForVerifier( mOptionalVerifierPackage, optional_receivers); optionalIntent.setComponent(optionalVerifierComponent); verificationState.addOptionalVerifier(optionalUid); if (mRequiredVerifierPackage != null) &#123; mContext.sendBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT); &#125; else &#123; mContext.sendOrderedBroadcastAsUser(optionalIntent, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final Message msg = mHandler.obtainMessage(CHECK_PENDING_VERIFICATION); msg.arg1 = verificationId; mHandler.sendMessageDelayed(msg, getVerificationTimeout()); &#125; &#125;, null, 0, null, null); mArgs = null; &#125; &#125; final ComponentName requiredVerifierComponent = matchComponentForVerifier( mRequiredVerifierPackage, receivers); if (ret == PackageManager.INSTALL_SUCCEEDED &amp;&amp; mRequiredVerifierPackage != null) &#123; Trace.asyncTraceBegin( TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId); /* * Send the intent to the required verification agent, * but only start the verification timeout after the * target BroadcastReceivers have run. */ verification.setComponent(requiredVerifierComponent); idleController.addPowerSaveTempWhitelistApp(Process.myUid(), mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier"); // 之前基础发送给各种verifier 进行校验，最后发送给required的verifier进行校验 mContext.sendOrderedBroadcastAsUser(verification, verifierUser, android.Manifest.permission.PACKAGE_VERIFICATION_AGENT, new BroadcastReceiver() &#123; // 此处巧妙，此Receiver做为orderedBroadcast的最后一站，将接收到intent。 @Override public void onReceive(Context context, Intent intent) &#123; final Message msg = mHandler .obtainMessage(CHECK_PENDING_VERIFICATION); msg.arg1 = verificationId; // 延时发送校验结束的消息，即超时时间到后发送校验结束，由于未携带 // 校验结果，将被判定为REJECT. mHandler.sendMessageDelayed(msg, getVerificationTimeout()); &#125; &#125;, null, 0, null, null); /* * We don't want the copy to proceed until verification * succeeds, so null out this field. */ mArgs = null; &#125; &#125; else &#123; /* * No package verification is enabled, so immediately start * the remote call to initiate copy using temporary file. */ ret = args.copyApk(mContainerService, true); &#125;&#125;mRet = ret; 以上为发送校验请求，当校验结束后会需要调用verifyPendingInstall 方法通知PackageManagerService 校验结束了，该方法会发送消息PACKAE_VERIFIED给PackageManagerService的PackageHandler.handleMessage 处理，处理流程如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case PACKAGE_VERIFIED: &#123; final int verificationId = msg.arg1; final PackageVerificationState state = // 通过verificationId 取得 校验状态对象，该对象用来跟踪校验过程的状态变化。 mPendingVerification.get(verificationId); if (state == null) &#123; Slog.w(TAG, "Invalid verification token " + verificationId + " received"); break; &#125; final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj; // 更新校验状态，会根据calleruid来判断是那个verifier校验的结果。 state.setVerifierResponse(response.callerUid, response.code); if (state.isVerificationComplete()) &#123; mPendingVerification.remove(verificationId); final InstallArgs args = state.getInstallArgs(); final Uri originUri = Uri.fromFile(args.origin.resolvedFile); int ret; if (state.isInstallAllowed()) &#123; ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR; // 校验通过会通知下verifier们校验最终通过了，大家都安心，其实没啥用。 broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser()); try &#123; // 继续安装流程 ret = args.copyApk(mContainerService, true); &#125; catch (RemoteException e) &#123; Slog.e(TAG, "Could not contact the ContainerService"); &#125; &#125; else &#123; // 校验失败，返回安装失败的结果。 ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE; &#125; Trace.asyncTraceEnd( TRACE_TAG_PACKAGE_MANAGER, "verification", verificationId); processPendingInstall(args, ret); mHandler.sendEmptyMessage(MCS_UNBIND); &#125; break;&#125; 整个校验的流程其实挺简单的，实际上就是在应用安装的过程中横插了一杠，发送了请求校验的广播出去，然后停止安装，等着有能力校验的应用校验完成后，根据校验的结果继续完成安装过程。至于校验者应用，官方文档介绍，GooglePlay实现了这一校验功能，据说是会扫描采集安装包的信息到Google的后台按照一些规则计算衡量后判定是否符合安装的要求，这大概就是一些应用海外版不能具有某种“黑科技技术”实现的原因吧，因为人家的机子上都有GooglePlay对这些应用进行检查。实际上现在国内许多手机厂商都会实现自己的Verifier，例如我使用的华为P9在安装一些应用的时候，华为的应用商店也会进行校验，然后弹出类似文章开头处的界面。 参考其他人介绍Package Verifiers的文章Android Internals: Package Verifiers Package安装过程The following process executes in Package Manager Service. Waiting Add a package to the queue for the installation process Determine the appropriate location of the package installation Determine installation Install / Update new Copy the apk file to a given directory Determine the UID of the app Request the installd daemon process Create the application directory and set permissions Extraction of dex code to the cache directory To reflect and packages.list / system / data / packages.xml the latest status Broadcast to the system along with the name of the effect of the installation is complete package Intent.ACTION_PACKAGE_ADDED: If the new ( Intent.ACTION_PACKAGE_REPLACED): the case of an update 流程如下图： PackageManager 详细介绍： In Depth: Android Package Manager and Package Installer Android パッケージインストール処理のしくみを追うst=>start: Start e=>end: end install=>operation: PackageManagerService 调用到handleStartCopy方法 verifierOk=>condition: 获取系统中存在的Verifier,判断系统中是否存在Verifier。 completeInstall=>operation: PackageManagerService完成安装 requestVerify=>operation: 发出广播ACTION_PACKAGE_NEEDS_VERIFICATION，设置最大验证超时时长 timeout=>condition: 是否超时 verify=>subroutine: Verifier 接收到ACTION_PACKAGE_NEEDS_VERIFICATION广播并检查要安装的应用 verifyResult=>condition: app是否允许安装 verifyAllow=>operation: 调用PackageManager.verifyPendingInstall 参数为本次验证的任务ID，结果为VERIFICATION_ALLOW verifyReject=>operation: 调用PackageManager.verifyPendingInstall 参数为本次验证的任务ID，结果为VERIFICATION_REJECT handleVerifyResult=>condition: 判断返回的verify结果 stopInstall=>operation: 终止安装，提醒安装被拒绝 st->install->verifierOk verifierOk(no)->completeInstall verifierOk(yes)->requestVerify->verify->verifyResult verifyResult(no)->verifyReject->handleVerifyResult verifyResult(yes)->verifyAllow->handleVerifyResult handleVerifyResult(yes)->completeInstall handleVerifyResult(no)->stopInstall stopInstall->e completeInstall->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android O 电源管理之从automotive谈起]]></title>
    <url>%2F2018%2F02%2F04%2Fandroid-O-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E4%B9%8B%E4%BB%8Eautomotive%E8%B0%88%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[android o 在源码工程/package/service/目录下新增了一个目录Car, 做为android automotive的重要组成部分，这部分可理解为在android世界的基础上，调用android的api构造出的Vehicle框架，该框架将android这一系统获得从手机迁移到目前最大的智能设备————车上的能力。从automotive 开始分析android O 的电源管理，一方面可以站在android api用户的角度，从调用逐层的深入下去直达kernel，另一方面也可以帮助理清android automotive的框架结构。对于android automotive的框架结构的更详细的介绍可以参考另外的说明，本文当然重点还是在于从头到位的串讲下android O的电源管理。 android O automotive 框架层中的电源管理Car Power Management 框架源码分析在关于Android O Vehicle的相关文章中有详细描述，此处不在赘述，上一张框架图如下： androidO automotive 中定义的AP Power 状态Android Vehicle 的电源管理概括起来两件事：同步android与车载MCU的电源状态和通过PowerManager的API控制android的电源状态。 AP 的官方文档解释：Application Processor, aka SOC. The processor chip running Android. 可以简单理解为Android系统。 车上的MCU通过gpio或数据总线等方式与AP进行沟通并对AP的电源进行管理，通过get和set属性AP_POWER_STATE的值实现. AP_POWER_STATE get的值（VMCU –&gt; AP）android O 的automotive在VehicleProperty中定义了VehicleApPowerState，其中定义了五种状态, hal在监测到车身有如下五种状态间的变化时，向AP上报变化后的状态，如下： 状态 值 说明 OFF 0 vehicle hal 不会向AP上报此状态 DEEP_SLEEP 1 vehicle hal 不会向AP上报此状态 ON_DISP_OFF 2 AP 运行但是灭屏 ON_FULL 3 AP 运行且亮屏，此时用户可交互 SHUTDOWN_PREPARE 4 电源管理请求AP关机，AP视情况进入SLEEP状态或者关机，也可以通过发送SHUTDOWN_POSTPONE请求延时关机 SHUTDOWN_PREPARE 状态携带参数 VehicleApPowerStateShutdownParam，该参数有三个取值如下： 参数 值 说明 SHUTDOWN_IMMEDIATELY 1 AP 必须立即关机，延迟关机不被允许 CAN_SLEEP 2 AP 可以使用深度睡眠来代替关机 SHUTDOWN_ONLY 3 允许延迟关机 这五种状态间的切换关系如下： AP_POWER_STATE set的值 (AP –&gt; VMCU)AP开机或其他业务需求触发或响应VMCU对AP的电源管理需求的过程中，需要向VMCU同步AP的电源变化，在VehiclePropertyType 中有如下定义: 状态 值 说明 BOOT_COMPLETE 0x1 AP 已经完成启动 DEEP_SLEEP_ENTRY 0x2 AP 正在进入deep sleep 状态 DEEP_SLEEP_EXIT 0x3 AP 正在退出deep sleep 状态 SHUTDOWN_POSTPONE 0x4 AP 请求延时关机，单次最大支持5000ms SHUTDOWN_START 0x5 AP 正在关机，可携带参数指定关机多久后开机 DISPLAY_OFF 0x6 用户请求关闭显示 DISPLAY_ON 0x7 用户请求打开显示 以上为automotive 部分的电源管理，automotive 部分说明了对android电源管理的请求从VMCU来或者从调用Car接口来。但是automotive 对电源管理请求最终的处理，还得到android系统中，再进一步到kernel中去。 Android 电源管理automotive 通过调用 PowerManager的API实现对Android的电源管理，android 系统的电源管理牵涉的模块非常的多，但是其主要框架是以PowerManagerService核心的，PowerManagerService 做为系统Service与其他系统Service 一起在SystemServer中被初始化。 android 的电源管理整体框架由图可知，电源管理框架可分为如下基层： 应用层：例如Vehicle的电源管理、设置等其他应用等。 Framework层：主要实现android电源管理的策略，负责调度和通知其他模块对电源管理做出响应。主要分为JavaFramework 和以com_android_server_power_PowerManagerService.cpp为核心的nativeFramework。 HAL层：主要包含传统的hardware_legacy中的power.c和android O 新增的Vendor Interface 对应的Hardware/Interface/Power 中的power.hal 部分。 Kernel层：主要包含linux的电源管理策略，以及对suspend lock的控制和reboot系统调用。PowerManagerService 的基本结构 automotive 中调用到的PowerManager相关部分主要在SystemInterfaceImpl中 API 说明 shutdown Turn off the device goToSleep Forces the device to go to sleep PARTIAL_WAKE_LOCK Ensures that the CPU is running; the screen and keyboard backlight will be allowed to go off FULL_WAKE_LOCK Ensures that the screen and keyboard backlight are on shutdown 会依次调用到 goToSleep调用goToSleep的时候第三个参数为GO_TO_SLEEP_FLAG_NO_DOZE(Go to sleep flag: Skip dozing state and directly go to full sleep)这里提到的Doze 模式,是android 6.0 后新增的特性如上图：Doze模式提供一个复发的maintenance window给app去使用网络和处理挂起的操作Doze 模式下的限制: 网络访问功能被关闭 系统会忽略wake locks，即app无法持续占有电源 标准闹钟 AlarmManager（包括setExact()和setWindow()）都会被延时到下一个maintenance window才激活3.1. 如果app仍需要在Doze时使闹钟生效，可以使用setAndAllowWhileIdle()或setExactAndAllowWhileIdle()3.2. 使用函数setAlarmClock()设置的闹钟在Doze时仍会生效，系统会在闹钟生效前推出Doze。 系统不会进行Wi-Fi扫描 系统不允许异步Adapters运行 系统不允许JobScheduler运行 Doze 主要由DeviceIdleController实现，在DeviceIdleController中通过设备逐渐的满足条件，使得系统一步步的进入到doze状态下，流程如下图(android O貌似与此图有些微不同)： 分析源码可知，goToSleep 的实现最终也是依赖WakeLock锁来实现的，实现的流程先省略。且往下看。 WakeLock这里主要用到了两种锁如下 锁 cpu display keyboard 电源键影响 PARTIAL_WAKE_LOCK = 0x00000001 On off off 不受 FULL_WAKE_LOCK = 0x0000001a On Bright On 受 android 中其他锁的定义如下表： 锁类型 cpu display keyboard 电源键影响 备注 PARTIAL_WAKE_LOCK = 0x00000001 on off off 不受 SCREEN_DIM_WAKE_LOCK = 0x00000006 on dim off 受 SCREEN_BRIGHT_WAKE_LOCK = 0x0000000a on bright off 受 FULL_WAKE_LOCK = 0x0000001a on bright off 受 PROXIMITY_SCREEN_OFF_WAKE_LOCK = 0x00000020 距离传感器导致的灭屏后on，否则可正常off 距离传感器检测到有物体off,否则on off 受 需要设备支持距离传感器，不能和ACQUIRE_CAUSES_WAKEUP一起用 DOZE_WAKE_LOCK = 0x00000040 off off off 受 系统支持doze DRAW_WAKE_LOCK = 0x00000080 on off off 不受 windowManager允许应用在dozing状态绘制屏幕 配合锁使用的两个flag flag 说明 备注 ACQUIRE_CAUSES_WAKEUP = 0x10000000 正常情况下，获取wakelock是不会唤醒设备的，加上该标志之后，acquire wakelock也会唤醒设备 不能和PARTIAL_WAKE_LOCK 一起用 ON_AFTER_RELEASE = 0x20000000 和用户体验有关，当wakelock释放后如果没有该标志，屏幕会立即黑屏，如果有该标志，屏幕会亮一小会然后在黑屏。 不能和PARTIAL_WAKE_LOCK 一起用 对于锁的使用无非就是两种操作，acquire和release。对于这两个过程，见如下流程图： WakefulnessPowerManagerService 中的 mWakefulness 用来指示当前设备所处的状态，它有四种取值 Wakefulness 值 说明 WAKEFULNESS_ASLEEP 0 表示系统当前处于休眠状态，只能通过调用wakeup()唤醒 WAKEFULNESS_AWAKE 1 表示系统当前处于正常运行状态 WAKEFULNESS_DREAMING 2 表示系统当前处于屏保状态 WAKEFULNESS_DOZING 3 表示系统当前处于“Doze”状态，在该状态只有低功耗的屏保可以运行，其他应用进程将被挂起 在PowerManagerService 中无论是开关机，还是影响电源管理的用户行为（UserActivity）的管理，还是对wakelock锁的使用，（PowerManagerService中有两个很重要的底层SuspendBlockerLock:CPU锁————PowerManagerService.WakeLocks和Display锁————PowerManagerService.Display，系统通过向设备节点文件/sys/power/wake_lock 和 /sys/power/wake_unlock写入这两个锁的名字来控制cpu和display），最终都会调用到一个很重要的方法updatePowerStateLocked，该方法是整个PowerManagerService的核心。其大体调用逻辑如下： Android HAL 及更底层的电源管理Android的电源管理提出wakelock的是一套全新的机制，借用C++里智能指针思想来设计电源的使用和分配。wake_lock保持使用计数，只不过这种“智能指针”的所使用的资源不再是内存，而是电量。应用程序会通过特定的WakeLock去访问硬件，然后硬件会根据引用计数是否为0来决定是不是需要关闭这一硬件的供电。 这种机制在SuspendBlockerImpl 中实现，通过对mReferenceCount的判断是否调用nativeAcquireSuspendBlocker和nativeReleaseSuspendBlocker, 底层调用通过向设备节点文件/sys/power/wake_lock 和 /sys/power/wake_unlock 里写入锁的名字实现对对应设备是否休眠的操作。 PowerManagerService 对应的 hardware interface位置： hardware/interface/power/1.0/ 其中IPower.hal 提供如下四个接口： setInteractive(bool interactive) 设置系统是否交互状态，通常亮灭屏调用 powerhint(Powerhint hint, int32_t data) 调整cpu频率等参数时用来传递hint setFeature(Feature feature, bool activate) 用来使能实际的feature getPlatformLowPowerStats()generates(vec), statuss retval); 参考资源linux 电源管理相关blog: 电源管理子系统 st=>start: Start A=>operation: PowerManagerService.BinderService.shutdown B=>operation: PowerManagerService.shutdownOrRebootInternal C=>operation: ShutdownThread.shutdown D=>operation: shutdownInner E=>operation: beginShutdownSequence F=>operation: 在ShutdownThread的run方法中 AMS PMS 等Service的shutdown方法做清理工作 G=>operation: PowerManagerService.lowLevelShutdown 修改属性sys.powerctl值为shutdown H=>operation: property_service 监测到属性变化后最终调用到init.cpp中的property_changed] I=>operation: 调用reboot.cpp的HandlePowerctlMessage->DoReboot中进行一些清理工作->RebotSystem 最终调用系统调用reboot e=>end: End st->A->B->C->D->E->F->G->H->I->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O Vehicle之Car Service]]></title>
    <url>%2F2018%2F02%2F03%2FAndroid-O-Vehicle%E4%B9%8BCar-Service%2F</url>
    <content type="text"><![CDATA[Car Service 是 android O automotive 的核心实现。第一承担部分具体业务逻辑，第二向上为Car API 提供支撑，第三向下调用android api 或者调用 Vehicle Hal 获取车辆数据，控制车辆行为。 CarService层的构建CarServiceCar Service层的入口实现为CarService 类。CarService 继承自Service，主要初始化在onCreate中12345678910111213141516171819202122232425public void onCreate() &#123; Log.i(CarLog.TAG_SERVICE, "Service onCreate"); mCanBusErrorNotifier = new CanBusErrorNotifier(this /* context */); mVehicle = getVehicle(null /* Any Vehicle HAL interface name */); if (mVehicle == null) &#123; throw new IllegalStateException("Vehicle HAL service is not available."); &#125; try &#123; mVehicleInterfaceName = mVehicle.interfaceDescriptor(); &#125; catch (RemoteException e) &#123; throw new IllegalStateException("Unable to get Vehicle HAL interface descriptor", e); &#125; Log.i(CarLog.TAG_SERVICE, "Connected to " + mVehicleInterfaceName); mICarImpl = new ICarImpl(this, mVehicle, SystemInterface.getDefault(this), mCanBusErrorNotifier); mICarImpl.init(); SystemProperties.set("boot.car_service_created", "1"); linkToDeath(mVehicle, mVehicleDeathRecipient); super.onCreate();&#125; 其中主要初始化两个对象 mVehicle 与 mICarImpl。mVehicle 是 VehicleHal 在客户端（针对HAL层来说的客户端）的代理对象，它的类型为IVehicle,其实质是一个IVehicle.Proxy 对象。之后会通过此成员变量与VehicleHal进行跨进程的通信；mICarImpl 是 ICarImpl 类的实例，ICarImpl才是CarService中众多manager的真正创建着和管理者。 ICarImplICarImpl 继承自ICar.Stub，是CarService的具体实现，也作为Car API对应的真实的Service端提供服务。在CarService 类的 OnCrate方法中，先是创建了mICarImpl对象，之后调用了该对象的init方法。接下来依次分析这两个过程。ICarImpl的构造函数方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public ICarImpl(Context serviceContext, IVehicle vehicle, SystemInterface systemInterface, CanBusErrorNotifier errorNotifier) &#123; mContext = serviceContext; // 创建VehicleHal对象，该对象管理着各Service的HalService mHal = new VehicleHal(vehicle); mSystemActivityMonitoringService = new SystemActivityMonitoringService(serviceContext); // 电源管理服务，后续将以此为例介绍 mCarPowerManagementService = new CarPowerManagementService( mHal.getPowerHal(), systemInterface); mCarSensorService = new CarSensorService(serviceContext, mHal.getSensorHal()); mCarPackageManagerService = new CarPackageManagerService(serviceContext, mCarSensorService, mSystemActivityMonitoringService); mCarInputService = new CarInputService(serviceContext, mHal.getInputHal()); mCarProjectionService = new CarProjectionService(serviceContext, mCarInputService); mGarageModeService = new GarageModeService(mContext, mCarPowerManagementService); mCarInfoService = new CarInfoService(serviceContext, mHal.getInfoHal()); mAppFocusService = new AppFocusService(serviceContext, mSystemActivityMonitoringService); mCarAudioService = new CarAudioService(serviceContext, mHal.getAudioHal(), mCarInputService, errorNotifier); mCarCabinService = new CarCabinService(serviceContext, mHal.getCabinHal()); mCarHvacService = new CarHvacService(serviceContext, mHal.getHvacHal()); mCarRadioService = new CarRadioService(serviceContext, mHal.getRadioHal()); mCarNightService = new CarNightService(serviceContext, mCarSensorService); mInstrumentClusterService = new InstrumentClusterService(serviceContext, mAppFocusService, mCarInputService); mSystemStateControllerService = new SystemStateControllerService(serviceContext, mCarPowerManagementService, mCarAudioService, this); mCarVendorExtensionService = new CarVendorExtensionService(serviceContext, mHal.getVendorExtensionHal()); mPerUserCarServiceHelper = new PerUserCarServiceHelper(serviceContext); mCarBluetoothService = new CarBluetoothService(serviceContext, mCarCabinService, mCarSensorService, mPerUserCarServiceHelper); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; mVmsSubscriberService = new VmsSubscriberService(serviceContext, mHal.getVmsHal()); mVmsPublisherService = new VmsPublisherService(serviceContext, mHal.getVmsHal()); &#125; if (FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; mCarDiagnosticService = new CarDiagnosticService(serviceContext, mHal.getDiagnosticHal()); &#125; // Be careful with order. Service depending on other service should be inited later. // 为方便管理和遍历所有service，将所有service的引用构建为一个数组。 List&lt;CarServiceBase&gt; allServices = new ArrayList&lt;&gt;(Arrays.asList( mSystemActivityMonitoringService, mCarPowerManagementService, mCarSensorService, mCarPackageManagerService, mCarInputService, mGarageModeService, mCarInfoService, mAppFocusService, mCarAudioService, mCarCabinService, mCarHvacService, mCarRadioService, mCarNightService, mInstrumentClusterService, mCarProjectionService, mSystemStateControllerService, mCarVendorExtensionService, mCarBluetoothService, mPerUserCarServiceHelper )); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; allServices.add(mVmsSubscriberService); allServices.add(mVmsPublisherService); &#125; if (FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; allServices.add(mCarDiagnosticService); &#125; mAllServices = allServices.toArray(new CarServiceBase[0]);&#125; 构造方法主要内容就是构造了一堆的Service，并没有其他的东西。接下来看init：12345678public void init() &#123; // 调用VehicleHal 的init方法。 mHal.init(); // 循环调用各service的init方法。 for (CarServiceBase service : mAllServices) &#123; service.init(); &#125;&#125; VehicleHal在ICarImpl中一个比较重要的角色就是VehicleHal了，官方注释如下 Abstraction for vehicle HAL. This class handles interface with native HAL and do basic parsing of received data (type check). Then each event is sent to corresponding {@link HalServiceBase} implementation. It is responsibility of {@link HalServiceBase} to convert data to corresponding CarService for CarManager API. 意思就是说 这个类是native HAL 的接口，会解析收到的数据，并把收到的每个事件都分发给对应的HalServiceBase的具体实现类，比方PowerHalService 就会接收并处理关于AP_power_STATE的相关事件。 VehicleHal 在ICarImpl中创建并被调用init方法。其构造方法如下：123456789101112131415161718192021222324252627282930313233343536373839public VehicleHal(IVehicle vehicle) &#123; // 首先创建一个工作线程VEHICLE-HAL mHandlerThread = new HandlerThread("VEHICLE-HAL"); mHandlerThread.start(); // passing this should be safe as long as it is just kept and not used in constructor // 以下的这些service均继承自HalServiceBase mPowerHal = new PowerHalService(this); mSensorHal = new SensorHalService(this); mInfoHal = new InfoHalService(this); mAudioHal = new AudioHalService(this); mCabinHal = new CabinHalService(this); mRadioHal = new RadioHalService(this); mHvacHal = new HvacHalService(this); mInputHal = new InputHalService(this); mVendorExtensionHal = new VendorExtensionHalService(this); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; mVmsHal = new VmsHalService(this); &#125; if(FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; mDiagnosticHal = new DiagnosticHalService(this); &#125; mAllServices.addAll(Arrays.asList(mPowerHal, mSensorHal, mInfoHal, mAudioHal, mCabinHal, mRadioHal, mHvacHal, mInputHal, mVendorExtensionHal)); if (FeatureConfiguration.ENABLE_VEHICLE_MAP_SERVICE) &#123; mAllServices.add(mVmsHal); &#125; if(FeatureConfiguration.ENABLE_DIAGNOSTIC) &#123; mAllServices.add(mDiagnosticHal); &#125; // 创建HalClient，与VehicleHal的通信就仰赖于此。 mHalClient = new HalClient(vehicle, mHandlerThread.getLooper(), this /*IVehicleCallback*/);&#125; VehicleHal 创建完成后，就紧接着调用了init方法，代码如下：123456789101112131415161718192021222324252627282930313233343536public void init() &#123; // 首先获取所有支持的属性 Set&lt;VehiclePropConfig&gt; properties; try &#123; properties = new HashSet&lt;&gt;(mHalClient.getAllPropConfigs()); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Unable to retrieve vehicle property configuration", e); &#125; synchronized (this) &#123; // Create map of all properties for (VehiclePropConfig p : properties) &#123; mAllProperties.put(p.prop, p); &#125; &#125; // 然后循环遍历所有的HALService，将HALService关心的属性与Service对应起来，保存在map中 for (HalServiceBase service: mAllServices) &#123; // 获取到各HALService 所关注的property. Collection&lt;VehiclePropConfig&gt; taken = service.takeSupportedProperties(properties); if (taken == null) &#123; continue; &#125; if (DBG) &#123; Log.i(CarLog.TAG_HAL, "HalService " + service + " take properties " + taken.size()); &#125; synchronized (this) &#123; for (VehiclePropConfig p: taken) &#123; mPropertyHandlers.append(p.prop, service); &#125; &#125; properties.removeAll(taken); // 最后依次调用个HALService 的init 方法 service.init(); &#125;&#125; CarServiceBase 和 HALServiceBase在ICarImpl中管理了众多的车辆服务，这些服务均实现了CarServiceBase接口，对应的在VehicleHAL中管理着众多的HalService 这些HALService 通过VehicleHAL中的HALClient 与 HAL层通信，处理相应的属性变化，这些HALService 均继承自HALServiceBase。例如：CarPowerManagementService 对应于 PowerHalService。在上文中ICarImpl init 的时候会调用各CarService 的init 方法，VehicleHAL init 的时候也会调用各HALService 的 init 方法，以下以电源管理举例。CarPowerManagementService 的 init 方法：123456789101112131415161718192021222324252627282930public void init() &#123; // 创建一个处理Power 业务逻辑的工作线程 synchronized (this) &#123; mHandlerThread = new HandlerThread(CarLog.TAG_POWER); mHandlerThread.start(); mHandler = new PowerHandler(mHandlerThread.getLooper()); &#125; // CarPowerManagementService 同时实现了PowerHalService.PowerEventListener接口，该i // 接口用来从PowerHalService获取AP_POWER_STATE属性变化的事件。 // mHal 即为PowerHalService mHal.setListener(this); // 以下为电源管理的业务逻辑，此处不分析 if (mHal.isPowerStateSupported()) &#123; mHal.sendBootComplete(); PowerState currentState = mHal.getCurrentPowerState(); if (currentState != null) &#123; onApPowerStateChange(currentState); &#125; else &#123; Log.w(CarLog.TAG_POWER, "Unable to get get current power state during " + "initialization"); &#125; &#125; else &#123; Log.w(CarLog.TAG_POWER, "Vehicle hal does not support power state yet."); onApPowerStateChange(new PowerState(PowerHalService.STATE_ON_FULL, 0)); mSystemInterface.switchToFullWakeLock(); &#125; mSystemInterface.startDisplayStateMonitoring(this);&#125; PowerHalService 的 init 方法如下：123456789101112131415161718192021public synchronized void init() &#123; // mProperties 在VehicleHal 初始化时调用了各HalService的takeSupportedProperties方法 // 初始化完成，对于PowerHalService来说此处的属性为AP_POWER_STATE 和 // DISPLAY_BRIGHTNESS. for (VehiclePropConfig config : mProperties.values()) &#123; if (VehicleHal.isPropertySubscribable(config)) &#123; // 此处的mHal 为 VehicleHal，subscribeProperty 会调用到HalClient 的subscribe 方法 mHal.subscribeProperty(this, config.prop); &#125; &#125; VehiclePropConfig brightnessProperty = mProperties.get(DISPLAY_BRIGHTNESS); if (brightnessProperty != null) &#123; mMaxDisplayBrightness = brightnessProperty.areaConfigs.size() &gt; 0 ? brightnessProperty.areaConfigs.get(0).maxInt32Value : 0; if (mMaxDisplayBrightness &lt;= 0) &#123; Log.w(CarLog.TAG_POWER, "Max display brightness from vehicle HAL is invalid:" + mMaxDisplayBrightness); mMaxDisplayBrightness = 1; &#125; &#125;&#125; 由以上代码可知，在HalService 初始化的时候会订阅关心的属性变化，并且在CarPowerManagementService初始化时向PowerHalService注册了属性变化的回调，这样当VehicleHal相应的属性发生变化的时候就会回调到CarPowerManagementService的回调方法onApPowerStateChange 和 onDisplayBrightnessChange 方法了。 接下来详细讲解在CarService 这一层获取VehicleHal属性变化（get）和向VehicleHal 设置属性（set)的一系列流程。 CarService 对 VehicleHAL property的读写沿袭上文以Car Power Management 为例 CarService层读取VehicleHAL property订阅Vehicle property在 VehicleHal类的构造方法中创建了HALClient对象，HALClient对象的构造方法如下：12345678// IVehicle 为 IVehicle.proxy 对象是 Vehicle Binder的客户端// looper 为线程名为“VEHICLE-HAL” 的线程的looper，该线程在VehicleHAL对象初始化时创建// callback 对象即为ICalImpl的实例。HalClient(IVehicle vehicle, Looper looper, IVehicleCallback callback) &#123; mVehicle = vehicle; Handler handler = new CallbackHandler(looper, callback); mInternalCallback = new VehicleCallback(handler);&#125; 在PowerHalService 的 init方法中，有如下调用1mHal.subscribeProperty(this, config.prop); 此处的mHal 为VehicleHal 对象，VehicleHAL的subscribeProperty实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void subscribeProperty(HalServiceBase service, int property) throws IllegalArgumentException &#123; subscribeProperty(service, property, 0f, SubscribeFlags.DEFAULT);&#125;/** * Subscribe given property. Only Hal service owning the property can subscribe it. * * @param service HalService that owns this property * @param property property id (VehicleProperty) * @param samplingRateHz sampling rate in Hz for continuous properties * @param flags flags from &#123;@link android.hardware.automotive.vehicle.V2_0.SubscribeFlags&#125; * @throws IllegalArgumentException thrown if property is not supported by VHAL */ // service 为PowerHalService // property 为AP_POWER_STATE 和 DISPLAY_BRIGHTNESSpublic void subscribeProperty(HalServiceBase service, int property, float samplingRateHz, int flags) throws IllegalArgumentException &#123; if (DBG) &#123; Log.i(CarLog.TAG_HAL, "subscribeProperty, service:" + service + ", property: 0x" + toHexString(property)); &#125; VehiclePropConfig config; synchronized (this) &#123; config = mAllProperties.get(property); &#125; if (config == null) &#123; // 表示此property没被支持 throw new IllegalArgumentException("subscribe error: config is null for property 0x" + toHexString(property)); // 根据property的配置判断属性是否被订阅 &#125; else if (isPropertySubscribable(config)) &#123; SubscribeOptions opts = new SubscribeOptions(); opts.propId = property; opts.sampleRate = samplingRateHz; opts.flags = flags; synchronized (this) &#123; // 检验订阅该属性的service是否是该属性的所有者。 assertServiceOwnerLocked(service, property); mSubscribedProperties.put(property, opts); &#125; try &#123; // 调用 HalClient 的subscribe 最终去订阅该属性。 mHalClient.subscribe(opts); &#125; catch (RemoteException e) &#123; Log.e(CarLog.TAG_HAL, "Failed to subscribe to property: 0x" + property, e); &#125; &#125; else &#123; Log.e(CarLog.TAG_HAL, "Cannot subscribe to property: " + property); &#125;&#125; 接下来继续看HalClient 的 subscribe方法如下：123456public void subscribe(SubscribeOptions... options) throws RemoteException &#123; // mVehicle 为 Vehicle Interface 的客户端，此处的mInternalCallback 为之前创 // 建HalClient 时，使用传入的VehicleHal 对象构建的VehicleCallback 对象。当订阅的属性 // 变化时会回调IVehicleCallback的方法。 mVehicle.subscribe(mInternalCallback, new ArrayList&lt;&gt;(Arrays.asList(options)));&#125; IVehicleCallback 共有三个方法：123oneway onPropertyEvent(vec&lt;VehiclePropValue&gt; propValues);oneway onPropertySet(VehiclePropValue propValue);oneway onPropertySetError(StatusCode errorCode, int32_t propId, int32_t areaId); 响应Vehicle属性变化上文向Vehicle Interface订阅了属性，当Vehicle Interface上报数据后，会调用到IVehicleCallback的onPropertyEvent方法，该方法被VehicleHal实现。如下：123456789101112131415161718192021222324252627282930// propValues 为当前变化了的属性值public void onPropertyEvent(ArrayList&lt;VehiclePropValue&gt; propValues) &#123; synchronized (this) &#123; for (VehiclePropValue v : propValues) &#123; // 找到在VehicleHal 初始化时绑定好的属性与处理该属性的handler。 // 对于属性AP_POWER_STATE和DISPLAY_BRIGHTNESS来说，此处的service为PowerHalService HalServiceBase service = mPropertyHandlers.get(v.prop); if(service == null) &#123; Log.e(CarLog.TAG_HAL, "HalService not found for prop: 0x" + toHexString(v.prop)); continue; &#125; service.getDispatchList().add(v); mServicesToDispatch.add(service); VehiclePropertyEventInfo info = mEventLog.get(v.prop); if (info == null) &#123; info = new VehiclePropertyEventInfo(v); mEventLog.put(v.prop, info); &#125; else &#123; info.addNewEvent(v); &#125; &#125; &#125; for (HalServiceBase s : mServicesToDispatch) &#123; // 调用HALService 的 handleHalEvents来处理Vehicle Interface的属性变化事件。 s.handleHalEvents(s.getDispatchList()); s.getDispatchList().clear(); &#125; mServicesToDispatch.clear();&#125; 对于Power Management来说，调用的是PowerHalService的handleHalEvents方法，其实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142public void handleHalEvents(List&lt;VehiclePropValue&gt; values) &#123; PowerEventListener listener; synchronized (this) &#123; // 如果当前没有处理该消息的回调则将上报的事件先放入队列 if (mListener == null) &#123; if (mQueuedEvents == null) &#123; mQueuedEvents = new LinkedList&lt;&gt;(); &#125; mQueuedEvents.addAll(values); return; &#125; // mListener 为CarPowerManagementService初始化时向PowerHalService设置的listener // CarPowerManagementService 实现了该PowerEventListener // PowerEventListener 有两个方法：onApPowerStateChange 和 onDisplayBrightnessChange listener = mListener; &#125; // 分发处理该此属性变化事件 dispatchEvents(values, listener);&#125;private void dispatchEvents(List&lt;VehiclePropValue&gt; values, PowerEventListener listener) &#123; for (VehiclePropValue v : values) &#123; switch (v.prop) &#123; case AP_POWER_STATE: int state = v.value.int32Values.get(VehicleApPowerStateIndex.STATE); int param = v.value.int32Values.get(VehicleApPowerStateIndex.ADDITIONAL); // 如果为AP_POWER_STATE 则调用onApPowerStateChange listener.onApPowerStateChange(new PowerState(state, param)); break; case DISPLAY_BRIGHTNESS: int maxBrightness; synchronized (this) &#123; maxBrightness = mMaxDisplayBrightness; &#125; // 如果为DISPLAY_BRIGHTNESS 则调用onDisplayBrightnessChange listener.onDisplayBrightnessChange( (v.value.int32Values.get(0) * 100) / maxBrightness); break; &#125; &#125;&#125; 如此则回调到CarPowerManagementService中，最终完成对AP_POWER_STATE 和 DISPLAY_BRIGHTNESS属性变化的处理。 CarService 向 Vehicle Hal Interface Set 属性值。相对简单一些，已Power Management 在初始化时向Vehicle 同步启动完成状态为例 至此，CarService 以Power Management 举例的分析就结束了，各业务的Service具体实现可能不同，但是整体结构大体上是一致的。 st=>start: Start e=>end: End sendBootComplete=>operation: 调用PowerHalService的sendBootComplete VehicleHalSet=>operation: 调用VehicleHal的set方法, 使用属性IdAP_POWER_STATE,创建出VehiclePropValueStter对象 VehicleHalTo=>operation: 调用VehicleProValuesetter对象的to方法, 参数为属性的值BOOT_COMPLETE submit=>operation: to 方法中调用了submit方法, submit方法最终使用HalClient的setValue 方法将VehiclePropValue 对象设置到VehicleHal Interface层 st->sendBootComplete->VehicleHalSet->VehicleHalTo->submit->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O Vehicle之架构介绍]]></title>
    <url>%2F2018%2F02%2F03%2FAndroid-O-Vehicle%E4%B9%8B%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Android Automotive 是 Android Orea 中的一个特色功能，从AOSP的代码上看，android automotive 已经包含了从app层到framework层到hal层的各层级结构。本文简单介绍 Android Orea Vehicle 的架构形式 层次结构Google automotive 给出的架构如下图。从图中看，android vehicle 可划分为三层： Car APICar API 中包含与Car 相关的各种 manager API，通过这些manager 对app提供 car service 所能提供的服务，主要实现在/packages/services/Car/car-lib/目录下 Car ServiceCar Service 是android vehicle 的主要实现，在这一层会处理部分车辆业务逻辑，并向下调用Vehicle Hal 暴露的接口。主要实现在/packages/services/Car/service/目录下 Vehicle HalVehicle Hal 主要用来定义车辆属性，并向上提供读写属性的接口，以及对属性变化注册监听的接口。厂家需实现各自自定义的Vehicle Hal.主要实现在/hardware/interfaces/automotive. 层次实现Android O 对 Vehicle 的支持除HAL层，基本都在/packages/service/Car 目录下，android 的car 架构可以理解为在android framework之上，利用android framework的android api 实现的更高级的业务框架。下面以Power managment 为例来说明这种层次结构的更详细的细节，以更好的理解Vehicle 业务框架。android automotive power managment的类图如下： CarAPICar类是Vehicle 的 API层的具体实现。Car 通过aidl最终与CarService进行进程间通信。用户可使用如下代码使用Car的API:12345678910// 1.首先调用静态方法createCar创建Car对象Car car = Car.createCar(getContext(), mConnectionListener);// 2.连接Car service.car.connect();waitForConnection(DEFAULT_WAIT_TIMEOUT_MS);// 3.通过名字获取对应的manager对象。CarSensorManager carSensorManager =(CarSensorManager) car.getCarManager(Car.SENSOR_SERVICE);// 4.调用具体manager对象的方法carSensorManager.isSensorSupported(CarSensorManager.SENSOR_TYPE_CAR_SPEED); Car 类中有两个重要的成员变量12private ICar mService;private final HashMap&lt;String, CarManagerBase&gt; mServiceMap = new HashMap&lt;&gt;(); mService 是CarService的客户端，ICar.aidl定义如下：1234interface ICar &#123;IBinder getCarService(in String serviceName) = 0;int getCarConnectionType() = 1;&#125; 当调用getCarManager时会调用到mService的getCarService方法，再使用service name 与返回的对应Service的IBinder对象，一同创建出client端的manager对象。 mServiceMap 用来保存getCarManager创建出的manager对象，当再次需要获取该manager时即从此map中返回。接下来CarService Android O Vehicle之Car Service]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-EventLog-Tags 说明]]></title>
    <url>%2F2018%2F01%2F08%2FAndroid-EventLog-Tags-%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[简介Event Log, 官方的解释为 System diagnostic event record. System diagnostic events are used to record certain system-level events (such as garbage collection, activity manager state, system watchdogs, and other low level activity), which may be automatically collected and analyzed during system development.This is not the main “logcat” debugging log (Log)! These diagnostic events are for system integrators, not application authors.Events use integer tag codes corresponding to /system/etc/event-log-tags. They carry a payload of one or more int, long, or String values. The event-log-tags file defines the payload contents for each type code. 大概意思是说，是系统诊断事件的记录。这些事件都是系统级别事件，例如垃圾回收，ActivityManager的状态，系统看门够以及一些其他的事件。这些事件在系统开发的过程中会被自动的采集和分析。这些事件不是main debug调试log，它是给系统开发集成商看的，不是给应用开发者看的。但是，话虽这么说，event log 同样对于应用开发者有很大的帮助，例如可以看activity manager相关的tag去了解自己应用activity，service，broadcast等的相关情况，也可以通过分析dvm_lock_sample tag来判断程序中的锁持有或等待情况。 EventLog 打印12345678910111213141516171819$ adb logcat -v threadtime -b events01-01 08:00:00.340 289 289 I auditd : type=2000 audit(0.0:1): initialized01-01 08:46:59.550 289 289 I auditd : type=1403 audit(0.0:2): policy loaded auid=4294967295 ses=429496729501-01 08:46:59.560 289 289 I auditd : type=1404 audit(0.0:3): enforcing=1 old_enforcing=0 auid=4294967295 ses=429496729510-05 00:00:00.920 362 362 I boot_progress_start: 700302-08 23:06:39.045 362 362 I boot_progress_preload_start: 917302-08 23:06:42.121 362 362 I boot_progress_preload_end: 1224802-08 23:06:42.342 925 925 I boot_progress_system_run: 1246902-08 23:06:42.815 925 925 I boot_progress_pms_start: 1294302-08 23:06:43.043 925 925 I boot_progress_pms_system_scan_start: 1317102-08 23:06:45.124 925 925 I boot_progress_pms_data_scan_start: 1525102-08 23:06:45.929 350 1003 I dc_mm : time=1486566405000;i=1;e=play;v=video/avc,720,1280,002-08 23:06:56.918 350 1004 I dc_mm : time=1486566416000;i=1;e=play;v=video/avc,720,1280,002-08 23:07:01.606 925 925 I boot_progress_pms_scan_end: 3173402-08 23:07:01.665 925 925 I boot_progress_pms_ready: 3179202-08 23:07:01.842 925 941 I battery_status: [2,2,1,2,Li-ion]02-08 23:07:01.842 925 941 I battery_level: [30,3903,371]01-07 20:01:21.759 925 1518 I force_gc: Binder01-07 20:01:22.215 925 1422 I am_proc_start: [0,5225,10089,com.songshu.gallery:sspush,service,com.songshu.gallery/.SSPushService] 如上是一段开机阶段的event log，分析可知:event log 文件格式为：timestamp PID TID log-level log-tag tag-values可将其分为两部分：第一部分，timestamp PID TID 这部分就是时间，进程ID 和线程ID相对简单，没什么好说的。第二部分，log-tag tag-values 这部分是event log的主要部分，需要重点说下。 Event Log Tag 的说明：Android 源码目录/system/core/logcat/event.logtags 文件中有对event log tags的说明，源码注释如下：123# The entries in this file map a sparse set of log tag numbers to tag names.# This is installed on the device, in /system/etc, and parsed by logcat.# 在设备的/system/etc 目录下 可以找到所有event log tags的定义文件event-log-tags，每一个tag都有对应的tag number 和 tag name，例如： 20003 dvm_lock_sample (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6) 123# Tag numbers are decimal integers, from 0 to 2^31. (Let's leave the# negative values alone for now.)# tag number 是 0 到 2^31 的十进制整数123456# Tag names are one or more ASCII letters and numbers or underscores, i.e.# "[A-Z][a-z][0-9]_". Do not include spaces or punctuation (the former# impacts log readability, the latter makes regex searches more annoying).## Tag numbers and names are separated by whitespace. Blank lines and lines# starting with '#' are ignored. 12345# Optionally, after the tag names can be put a description for the value(s)# of the tag. Description are in the format# (&lt;name&gt;|data type[|data unit])# Multiple values are separated by commas.# tag values 的每一个value 格式为：(|data type[|data unit])1234567# The data type is a number from the following values:# 1: int# 2: long# 3: string# 4: list# 5: float# data 的类型如上12345678# The data unit is a number taken from the following list:# 1: Number of objects# 2: Number of bytes# 3: Number of milliseconds# 4: Number of allocations# 5: Id# 6: Percent# Default value for data of type int/long is 2 (bytes). data 的单位如上列表。 分析event log，举例如下，例如上文中log有这么一行：102-08 23:07:01.842 925 941 I battery_level: [30,3903,371] 分析如下：时间： 02-08 23:07:01.842进程ID： 925线程ID： 941log level: Ilog tag: _batterylevellog values: [30,3903,371]查找设备上的event-log-tags文件，找到battery_level的说明如下: 2722 battery_level (level|1|6),(voltage|1|1),(temperature|1|1) 分析values含义(level|1|6): 30 电量是30%(voltage|1|1): 3903 电压是3903(temperature|1|1): 371 温度是371 常用Event Log Tags的说明ActivityManager Num TagName 格式 功能 30001 am_finish_activity User,Token,TaskID,ComponentName,Reason 30002 am_task_to_front User,Task 30003 am_new_intent User,Token,TaskID,ComponentName,Action,MIMEType,URI,Flags 30004 am_create_task User ,Task ID 30005 am_create_activity User ,Token ,TaskID ,ComponentName,Action,MIMEType,URI,Flags 30006 am_restart_activity User ,Token ,TaskID,ComponentName 30007 am_resume_activity User ,Token ,TaskID,ComponentName 30008 am_anr User ,pid ,Package Name,Flags ,reason ANR 30009 am_activity_launch_time User ,Token ,ComponentName,time 30010 am_proc_bound User ,PID ,ProcessName 30011 am_proc_died User ,PID ,ProcessName 30012 am_failed_to_pause User ,Token ,Wanting to pause,Currently pausing 30013 am_pause_activit y User ,Token ,ComponentName 30014 am_proc_start User ,PID ,UID ,ProcessName,Type,Component 30015 am_proc_bad User ,UID ,ProcessName 30016 am_proc_good User ,UID ,ProcessName 30017 am_low_memory NumProcesses Lru 30018 am_destroy_activity User ,Token ,TaskID,ComponentName,Reason 30019 am_relaunch_resume_activity User ,Token ,TaskID,ComponentName 30020 am_relaunch_activity User ,Token ,TaskID,ComponentName 30021 am_on_paused_called User ,ComponentName 30022 am_on_resume_called User ,ComponentName 30023 am_kill User ,PID ,ProcessName,OomAdj ,Reason 杀进程 30024 am_broadcast_discard_filter User ,Broadcast ,Action,ReceiverNumber,BroadcastFilter 30025 am_broadcast_discard_app User ,Broadcast ,Action,ReceiverNumber,App 30030 am_create_service User ,ServiceRecord ,Name,UID ,PID 30031 am_destroy_service User ,ServiceRecord ,PID 30032 am_process_crashed_too_much User ,Name,PID 30033 am_drop_process PID 30034 am_service_crashed_too_much User ,Crash Count,ComponentName,PID 30035 am_schedule_service_restart User ,ComponentName,Time 30036 am_provider_lost_process User ,Package Name,UID ,Name 30037 am_process_start_timeout User ,PID ,UID ,ProcessName timeout 30039 am_crash User ,PID ,ProcessName,Flags ,Exception,Message,File,Line Crash 30040 am_wtf User ,PID ,ProcessName,Flags ,Tag,Message Wtf 30041 am_switch_user id 30042 am_activity_fully_drawn_time User ,Token ,ComponentName,time 30043 am_focused_activity User ,ComponentName 30044 am_home_stack_moved User ,To Front ,Top Stack Id ,Focused Stack Id ,Reason 30045 am_pre_boot User ,Package 30046 am_meminfo Cached,Free,Zram,Kernel,Native 内存 30047 am_pss Pid, UID, ProcessName, Pss, Uss 进程 下面列举tag可能使用的部分场景：am_low_memory：位于AMS.killAllBackgroundProcesses或者AMS.appDiedLocked，记录当前Lru进程队列长度。am_pss：位于AMS.recordPssSampleLocked(am_meminfo：位于AMS.dumpApplicationMemoryUsageam_proc_start:位于AMS.startProcessLocked，启动进程am_proc_bound:位于AMS.attachApplicationLockedam_kill: 位于ProcessRecord.kill，杀掉进程am_anr: 位于AMS.appNotRespondingam_crash:位于AMS.handleApplicationCrashInneram_wtf:位于AMS.handleApplicationWtfam_activity_launch_time：位于ActivityRecord.reportLaunchTimeLocked()，后面两个参数分别是thisTime和 totalTime.am_activity_fully_drawn_time:位于ActivityRecord.reportFullyDrawnLocked, 后面两个参数分别是thisTime和 totalTimeam_broadcast_discard_filter:位于BroadcastQueue.logBroadcastReceiverDiscardLockedam_broadcast_discard_app:位于BroadcastQueue.logBroadcastReceiverDiscardLocked Activity生命周期相关的方法:am_on_resume_called: 位于AT.performResumeActivityam_on_paused_called: 位于AT.performPauseActivity, performDestroyActivityam_resume_activity: 位于AS.resumeTopActivityInnerLockedam_pause_activity: 位于AS.startPausingLockedam_finish_activity: 位于AS.finishActivityLocked, removeHistoryRecordsForAppLockedam_destroy_activity: 位于AS.destroyActivityLockedam_focused_activity: 位于AMS.setFocusedActivityLocked, clearFocusedActivityam_restart_activity: 位于ASS.realStartActivityLockedam_create_activity: 位于ASS.startActivityUncheckedLockedam_new_intent: 位于ASS.startActivityUncheckedLockedam_task_to_front: 位于AS.moveTaskToFrontLocked Power Num TagName 格式 功能 2722 battery_level level, voltage, temperature 2723 battery_status status,health,present,plugged,technology 2730 battery_discharge duration, minLevel,maxLevel 2724 power_sleep_requested wakeLocksCleared 唤醒锁数量 2725 power_screen_broadcast_send wakelockCount 2726 power_screen_broadcast_done on, broadcastDuration, wakelockCount 2727 power_screen_broadcast_stop which,wakelockCount 系统还没进入ready状态 2728 power_screen_state offOrOn, becauseOfUser, totalTouchDownTime, touchCycles 2729 power_partial_wake_state releasedorAcquired, tag 部分含义：battery_level: [19,3660,352] //剩余电量19%, 电池电压3.66v, 电池温度35.2℃power_screen_state: [0,3,0,0] // 灭屏状态(0), 屏幕超时(3). 当然还有其他设备管理策略(1),其他理由都为用户行为(2)power_screen_state: [1,0,0,0] // 亮屏状态(1) 下面列举tag可能使用的部分场景：power_sleep_requested: 位于PMS.goToSleepNoUpdateLockedpower_screen_state:位于Notifer.handleEarlyInteractiveChange, handleLateInteractiveChange 附录最后附上从设备的/system/etc 下获取到event-log-tags文件.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-安装和使用Cisco AnyConnect Client]]></title>
    <url>%2F2018%2F01%2F07%2FLinux-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8Cisco-AnyConnect-Client%2F</url>
    <content type="text"><![CDATA[以前使用的vpn到期了，而且最近查的挺严，原先的好多vpn都用不了了，在同事的推荐下使用矩阵研究所 自己搭建的shadowsocks翻墙上网，他提供了windows、ios、android各平台的客户端，唯独未提供linux的客户端。不过他还好支持anyconnect，所以在linux还是可以配置anyconnect client 进行使用的。配置过程记录如下，供以后参考。 安装Cisco AnyConnect Client 安装依赖包 12$ sudo apt-get update$ sudo apt-get install lib32z1 lib32ncurses5 从UCI OIT Cisco Anyconnect/Linux instruction page下载Cisco AnyConnect Client根据linux 是32位还是64位选择适合自己的版本，查看系统版本号可使用如下命令： 12$ uname -aLinux xxxx-XPS-8910 4.13.0-21-generic #24-Ubuntu SMP Mon Dec 18 17:29:16 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 将下载好的压缩包解压到你想保存的路径下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889$ tar -xzvf anyconnect-predeploy-linux-64-4.3.05017-k9.tar.gzanyconnect-4.3.05017/anyconnect-4.3.05017/vpn/anyconnect-4.3.05017/vpn/vpn_install.shanyconnect-4.3.05017/vpn/vpnagentdanyconnect-4.3.05017/vpn/vpnagentd_initanyconnect-4.3.05017/vpn/vpn_uninstall.shanyconnect-4.3.05017/vpn/anyconnect_uninstall.shanyconnect-4.3.05017/vpn/libacciscossl.soanyconnect-4.3.05017/vpn/libacciscocrypto.soanyconnect-4.3.05017/vpn/libaccurl.so.4.3.0anyconnect-4.3.05017/vpn/vpnuianyconnect-4.3.05017/vpn/cisco-anyconnect.desktopanyconnect-4.3.05017/vpn/cisco-anyconnect.menuanyconnect-4.3.05017/vpn/cisco-anyconnect.directoryanyconnect-4.3.05017/vpn/libvpnagentutilities.soanyconnect-4.3.05017/vpn/libvpncommon.soanyconnect-4.3.05017/vpn/libvpncommoncrypt.soanyconnect-4.3.05017/vpn/libvpnapi.soanyconnect-4.3.05017/vpn/libvpnipsec.soanyconnect-4.3.05017/vpn/vpnanyconnect-4.3.05017/vpn/acinstallhelperanyconnect-4.3.05017/vpn/pixmaps/anyconnect-4.3.05017/vpn/pixmaps/company-logo.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-about.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-configure.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-connect.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-disconnect.pnganyconnect-4.3.05017/vpn/pixmaps/cvc-info.pnganyconnect-4.3.05017/vpn/pixmaps/systray_connected.pnganyconnect-4.3.05017/vpn/pixmaps/systray_disconnecting.pnganyconnect-4.3.05017/vpn/pixmaps/systray_notconnected.pnganyconnect-4.3.05017/vpn/pixmaps/systray_quarantined.pnganyconnect-4.3.05017/vpn/pixmaps/systray_reconnecting.pnganyconnect-4.3.05017/vpn/pixmaps/vpnui48.pnganyconnect-4.3.05017/vpn/pixmaps/downloader-arrow.pnganyconnect-4.3.05017/vpn/manifesttoolanyconnect-4.3.05017/vpn/ACManifestVPN.xmlanyconnect-4.3.05017/vpn/vpndownloaderanyconnect-4.3.05017/vpn/vpndownloader-clianyconnect-4.3.05017/vpn/update.txtanyconnect-4.3.05017/vpn/OpenSource.htmlanyconnect-4.3.05017/vpn/AnyConnectProfile.xsdanyconnect-4.3.05017/vpn/AnyConnectLocalPolicy.xsdanyconnect-4.3.05017/vpn/libacfeedback.soanyconnect-4.3.05017/vpn/license.txtanyconnect-4.3.05017/vpn/VeriSignClass3PublicPrimaryCertificationAuthority-G5.pemanyconnect-4.3.05017/dart/anyconnect-4.3.05017/dart/dart_install.shanyconnect-4.3.05017/dart/AMPEnabler.xmlanyconnect-4.3.05017/dart/AnyConnectConfig.xmlanyconnect-4.3.05017/dart/BaseConfig.xmlanyconnect-4.3.05017/dart/ConfigXMLSchema.xsdanyconnect-4.3.05017/dart/DARTGUI.gladeanyconnect-4.3.05017/dart/ISEPosture.xmlanyconnect-4.3.05017/dart/NetworkVisibility.xmlanyconnect-4.3.05017/dart/Posture.xmlanyconnect-4.3.05017/dart/RequestXMLSchema.xsdanyconnect-4.3.05017/dart/Umbrella.xmlanyconnect-4.3.05017/dart/cisco-anyconnect-dart.desktopanyconnect-4.3.05017/dart/cisco-anyconnect-dart.directoryanyconnect-4.3.05017/dart/cisco-anyconnect-dart.menuanyconnect-4.3.05017/dart/ciscoLogo.pnganyconnect-4.3.05017/dart/dartCustom.pnganyconnect-4.3.05017/dart/dartTypical.pnganyconnect-4.3.05017/dart/dart_uninstall.shanyconnect-4.3.05017/dart/dartclianyconnect-4.3.05017/dart/dartcli.symbolsanyconnect-4.3.05017/dart/dartuianyconnect-4.3.05017/dart/dartui.symbolsanyconnect-4.3.05017/dart/license.txtanyconnect-4.3.05017/dart/manifesttoolanyconnect-4.3.05017/dart/ACManifestDART.xmlanyconnect-4.3.05017/posture/anyconnect-4.3.05017/posture/ciscodanyconnect-4.3.05017/posture/cscananyconnect-4.3.05017/posture/ciscod_initanyconnect-4.3.05017/posture/cstubanyconnect-4.3.05017/posture/posture_install.shanyconnect-4.3.05017/posture/posture_uninstall.shanyconnect-4.3.05017/posture/libcsd.soanyconnect-4.3.05017/posture/libhostscan.soanyconnect-4.3.05017/posture/libinspector.soanyconnect-4.3.05017/posture/license.txtanyconnect-4.3.05017/posture/tables.datanyconnect-4.3.05017/posture/ACManifestPOS.xmlanyconnect-4.3.05017/posture/libaccurl.so.4.3.0anyconnect-4.3.05017/posture/libacciscocrypto.soanyconnect-4.3.05017/posture/libacciscossl.so 进入解压目录下确认文件是否完整：12345678910111213141516171819202122232425262728293031323334$ cd anyconnect-4.3.05017/vpn/$ ls -lhtotal 12M-rwxr-xr-x 1 XXXX XXXX 14K 12月 10 2016 acinstallhelper-rw-r--r-- 1 XXXX XXXX 262 12月 10 2016 ACManifestVPN.xml-rw-r--r-- 1 XXXX XXXX 6.6K 12月 10 2016 AnyConnectLocalPolicy.xsd-rw-r--r-- 1 XXXX XXXX 83K 12月 10 2016 AnyConnectProfile.xsd-rwxr-xr-x 1 XXXX XXXX 502 12月 10 2016 anyconnect_uninstall.sh-rw-r--r-- 1 XXXX XXXX 279 12月 10 2016 cisco-anyconnect.desktop-rw-r--r-- 1 XXXX XXXX 164 12月 10 2016 cisco-anyconnect.directory-rw-r--r-- 1 XXXX XXXX 603 12月 10 2016 cisco-anyconnect.menu-rwxr-xr-x 1 XXXX XXXX 2.6M 12月 10 2016 libacciscocrypto.so-rwxr-xr-x 1 XXXX XXXX 436K 12月 10 2016 libacciscossl.so-rwxr-xr-x 1 XXXX XXXX 232K 12月 10 2016 libaccurl.so.4.3.0-rwxr-xr-x 1 XXXX XXXX 168K 12月 10 2016 libacfeedback.so-rwxr-xr-x 1 XXXX XXXX 888K 12月 10 2016 libvpnagentutilities.so-rwxr-xr-x 1 XXXX XXXX 1.6M 12月 10 2016 libvpnapi.so-rwxr-xr-x 1 XXXX XXXX 530K 12月 10 2016 libvpncommoncrypt.so-rwxr-xr-x 1 XXXX XXXX 1.7M 12月 10 2016 libvpncommon.so-rwxr-xr-x 1 XXXX XXXX 1.1M 12月 10 2016 libvpnipsec.so-rw-r--r-- 1 XXXX XXXX 13K 12月 10 2016 license.txt-rwxr-xr-x 1 XXXX XXXX 480K 12月 10 2016 manifesttool-rw-r--r-- 1 XXXX XXXX 68K 12月 10 2016 OpenSource.htmldrwxr-xr-x 2 XXXX XXXX 4.0K 12月 10 2016 pixmaps-rw-r--r-- 1 XXXX XXXX 10 12月 10 2016 update.txt-rw-r--r-- 1 XXXX XXXX 1.8K 12月 10 2016 VeriSignClass3PublicPrimaryCertificationAuthority-G5.pem-rwxr-xr-x 1 XXXX XXXX 65K 12月 10 2016 vpn-rwxr-xr-x 1 XXXX XXXX 724K 12月 10 2016 vpnagentd-rw-r--r-- 1 XXXX XXXX 2.1K 12月 10 2016 vpnagentd_init-rwxr-xr-x 1 XXXX XXXX 424K 12月 10 2016 vpndownloader-rwxr-xr-x 1 XXXX XXXX 396K 12月 10 2016 vpndownloader-cli-rwxr-xr-x 1 XXXX XXXX 24K 12月 10 2016 vpn_install.sh-rwxr-xr-x 1 XXXX XXXX 176K 12月 10 2016 vpnui-rwxr-xr-x 1 XXXX XXXX 8.4K 12月 10 2016 vpn_uninstall.sh 安装1$ sudo ./vpn_install.sh 遇到提示直接y就可以了 重新载入 systemd，扫描新的或有变动的单元 1sudo systemctl daemon-reload 这是vpnagented进程应该已经启动了，可使用如下方式进行检查： 12$ ps auxw | grep vpnagentd | grep -v greproot 7677 0.1 0.0 259808 12720 ? Sl 11:24 0:00 /opt/cisco/anyconnect/bin/vpnagentd 同时安装过程中设置了开机启动，时候安装开机启动检查方式如下： 123456789$ find /etc/rc?.d -type l -name "*vpnagentd*"/etc/rc2.d/K25vpnagentd/etc/rc2.d/S85vpnagentd/etc/rc3.d/K25vpnagentd/etc/rc3.d/S85vpnagentd/etc/rc4.d/K25vpnagentd/etc/rc4.d/S85vpnagentd/etc/rc5.d/K25vpnagentd/etc/rc5.d/S85vpnagentd 使用Cisco AnyConnect UI Client 翻墙 为方便以后使用添加命令别名12$ alias vpn='/opt/cisco/anyconnect/bin/vpn'$ alias vpnui='/opt/cisco/anyconnect/bin/vpnui' 或者12345$ cat &gt;&gt; ~/.bash_aliasesalias vpn='/opt/cisco/anyconnect/bin/vpn'alias vpnui='/opt/cisco/anyconnect/bin/vpnui'^D$ _ 使用vpnui 配置anyconnect1$ vpnui 在弹出的界面中输入要连接的服务器，点击右侧的设置图标，弹出如下界面 取消图【Block connections to untrusted servers】前的选择，然后点击【close】按钮关闭设置，点击连接进行连接，连接过程中若弹出以下界面点击 按钮【Connect Anyway】 之后按照提示依次输入从矩阵研究所获得的AnyConnect 账号和密码即可连接成功。 使用Csico AnyConnect Command Client 翻墙 To start the client from a command-line prompt in a terminal window, using the alias you made above: 1$ vpn At the VPN&gt; prompt, type connect vpn.uci.edu and press Enter. (If you get an error message about an untrusted server or certificate, you can fix that following the instructions from Robert in the section NOTE 1 - Connect-error, below.) Otherwise, you should now see: 1234567VPN&gt; connect vpn.uci.edu &gt;&gt; Please enter your UCInetID and password. 0) Default-WebVPN 1) Merage 2) MerageFull 3) UCI 4) UCIFull If you do not see this, but get a connect error instead, please see NOTE 1 - Connect Error below. Ignore the message about entering your UCInetID and password, for now. Choose one of the choices by number and press return – usually UCI or UCIFull. (See the differences in the Tunnels below.) For instance, for UCI, press 3 and hit Enter. Enter your UCInetID and password in the Username and Password boxes and press return. At the accept? [y/n]: prompt, type y and press Enter. You may get several notices the first time about the downloader performing update checks. At the end you should see a &gt;&gt; state: Connected message and a new VPN&gt; prompt. You are now connected. Either leave the VPN&gt; prompt open or if you want your terminal back just type quit at the VPN&gt; prompt (the connection will remain active).]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 版本控制工具之rabbitvcs]]></title>
    <url>%2F2017%2F11%2F04%2FLinux-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E4%B9%8BRabbitvcs%2F</url>
    <content type="text"><![CDATA[新公司的文档管理居然使用ｓｖｎ，不知道适合原因．很久不用有一些忘却了.之前在win下用的是TortoiseSVN，在ubuntu下，与之及其相似的是rabbitvcs．官网地址下面是来自官方打介绍 特性介绍NautilusSeamlessly integrates into Nautilus workflow GeditProvides menus for accessing version control tools ThunarSeamlessly integrates into Thunar workflow Command Line InterfaceAn easy to use tool to launch our dialogs SubversionSupports most Subversion functionality GitSupports most Git functionality Fully InternationalizedPartial-to-full support for 26 languages! Ubuntu安装方法1234567891011### 添加源$ sudo add-apt-repository ppa:rabbitvcs/ppa### 导入key$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 34EF4A35### 更新源$ sudo apt-get update### 安装依赖$ sudo apt-get install python-nautilus python-configobj python-gtk2 python-glade2 python-svn python-dbus python-dulwich subversion meld### 安装ＲabbitVCS$ sudo apt-get install rabbitvcs-cli rabbitvcs-core rabbitvcs-gedit rabbitvcs-nautilus3### 如安装失败使用 rabbitvcs-nautilus3 替换为 rabbitvcs-nautilus 使用方法]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（六）：基于Linux的物联网操作系统]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8ELinux%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[提到物联网操作系统，就不能不提Linux，因为Linux可能是目前在物联网设备中应用最广的操作系统了。前面的文章刚刚介绍了不少非Linux类的物联网操作系统，本文就来介绍一下目前常用的基于Linux的物联网操作系统。在传统Linux内核基础上，经过裁剪，就可以移植到嵌入式系统上运行。不过，还有很多开源组织和商业公司对Linux进行了一番改造，使其更符合嵌入式系统或物联网应用的需求，比如改为实时操作系统。 RTLinuxRTLinux（Real-Time Linux）是Linux中的一种实时操作系统。它由新墨西哥矿业及科技学院的V. Yodaiken开发。现在已被WindRiver公司（大名鼎鼎的嵌入式操作系统VxWorks就是这家公司的产品）收购。RT-Linux开发者并没有针对实时操作系统的特性而重写Linux的内核，因为这样做的工作量非常大，而且要保证兼容性也非常困难。RTLinux是将Linux的内核代码做了一些修改，将Linux本身的任务以及Linux内核作为优先级很低的任务，而实时任务作为优先级最高的任务。 uClinuxuClinux（www.uclinux.org）表示micro-control linux，即“微控制器领域中的Linux系统”，是Lineo公司的主打产品，同时也是开放源码的嵌入式Linux的典范之作。uCLinux主要是针对目标处理器没有存储管理单元MMU（Memory Management Unit）的嵌入式系统而设计的。它已经被成功地移植到了很多平台上。由于没有MMU，在uCLinux上实现多任务需要一定的技巧。 Brillo谷歌提出了Project IoT物联网计划，并发布了Brillo操作系统。Brillo是一个物联网底层操作系统。Brillo是源于Android，是对Android底层的一个细化，得到了Android的全部支持，比如蓝牙、Wifi等技术，并且能耗很低，安全性很高，任何设备制造商都可以直接使用。LiteOS2015年5月在华为网络大会上，华为发布了敏捷网络3.0，主要包括最轻量级的物联网操作系统LiteOS、敏捷物联网关、敏捷控制器三部分。其中LiteOS声称可以作为只有10KB大小的内核来部署。在华为的官方网站（www.huawei.com/minisite/liteos/cn/）上，可以了解到更多关于LiteOS的信息。 OpenWrt很多智能路由器都基于OpenWrt的衍生版本开发而成轻量级OpenWrt（www.openwrt.org.cn）是一个基于Linux的操作系统，市场上很多智能路由器固件都是基于OpenWrt及其衍生版本的。OpenWrt包括很多衍生版本，这些衍生版本还有很多分支版本。LEDE（lede-project.org）。LEDE全称是Linux嵌入式开发环境(Linux Embedded Development Environment)项目，LEDE就是一个基于OpenWrt的OS。其他衍生版本还有DD-Wrt，以及面向Arduino的Linino，等等。 Ostro Linux Ostro? OS is a Linux* distribution optimized for the development of connected and embedded devices. In fact, Ostro Project is designed specifically to support IoT device development. It integrates connectivity and networking, device-to-device interconnectivity standards, pre-configured sensors, and over-the-air update capabilities. Ostro（ostroproject.org）是一套基于Linux并且为物联网智能设备特别量身订做的开源操作系统，支持蓝牙、WiFi和NFC等等的连接方式，并且支持多种如IoTivity的设备对设备互联互通标准。提到Ostro，不得不再说一下Linux基金会的Yocto Project。Yocto不是一款Linux发行版，而是一个开源协作项目，为开发人员提供构建自定义嵌入式堆栈的模块、工具和方法。Yocto Project构成了大多数商用嵌入式Linux发行版的基础，比如Ostro Linux、Qt for Device Creation都是基于这个项目。 其他Linux物联网项目（1）RaspbianRaspbian成为树莓派爱好者的最佳选择Raspbian是一个专门面向树莓派（Raspberry Pi）计算机的Linux发行版，基础是Debian操作系统。两位志愿者针对树莓派硬件对Debian进行了专门的优化和移植。而Raspbian不仅仅是一个OS，它附带着35000个软件包以及预编译的软件。 （2）Snappy Ubuntu CoreUbuntu希望继续让Linux成为让物联网更智能和可扩展的核心。Snappy Ubuntu Core是面向智能设备的最新平台，其承诺可以运行存储在本地或依赖于云端的相同软件。 （3）TizenLinux基金会托管的这个嵌入式Linux项目主要得到了三星的支持。Tizen广泛用于三星的电视和智能手表中，包括新的Gear S3，也零星地实施在三星的相机和消费级设备中。 结语在Linux系统基础上发展起来的面向物联网应用的项目非常多，Linux的碎片化程度也挺严重。至于哪个版本的Linux会成为主流，取决于应用场景、文档及开发资源支持和整个开发者生态的建立。在移动互联网时代，基于Linux的Android系统和互联网应用大放异彩；在物联网时代，Linux仍然会发挥着巨大作用。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（五）：除了Linux，还有什么物联网操作系统]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E9%99%A4%E4%BA%86Linux%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%A9%E8%81%94%E7%BD%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[在前面介绍物联网终端设备的文章中，我们已经简单地介绍了物联网操作系统。物联网操作系统的种类非常多，不过其中有很大一部分是基于Linux系统改造的，还有一些系统是商业公司或开源组织开发的，当然微软公司也开发了一系列面向嵌入式应用的操作系统。 出于成本或者定制化的需求，开发者往往更青睐开源的物联网操作系统。开源系统可以大致分为两大类：一类是基于Linux系统改造的物联网OS，如uCLinux、谷歌的Brillo、华为的Lite OS等；一类是非Linux类物联网OS，由开源社区或商业公司按照某种开源许可独立设计实现，如uCOS、FreeRTOS、mbed等。篇幅有限，本文重点介绍一下非Linux类的物联网OS，这类系统通常是比较轻量级的实时操作系统，更适合应用于存储性能有限的MCU。 FreeRTOSFreeRTOS（www.freertos.org）是一个迷你的实时操作系统内核，但麻雀虽小，五脏俱全，包括了任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等操作系统的基本功能。FreeRTOS创始人是Richard Barry，最初他设计这个系统的初衷，就是出于自身为工作项目中寻找RTOS的过程很痛苦。商业系统很贵，开源系统也缺乏好的文档支持。相对μC/OS-II、embOS等商业操作系统，FreeRTOS操作系统是完全免费的操作系统，源码公开、可移植、可裁减，可移植到各种单片机上运行，在嵌入式系统尤其是实时操作系统方面应用者众多，比如著名的智能手表Pebble就是用了FreeRTOS。 μC/OS-IIμC/OS-II 是一种基于优先级的抢占式多任务实时操作系统，包含了实时内核、任务管理、时间管理、任务间通信同步（信号量，邮箱，消息 队列）和内存管理等功能。μC/OS-II绝大部分的代码是用ANSII的C语言编写的，包含一小部分汇编代码，使之可供不同架构的微处理器使用。μC/OS-II经过了非常严格的测试，甚至都已经运用到美国航空管理局的飞行器上。μC/OS-II由Micrium公司以源代码的形式发布，但并不意味着它是免费软件。可以将其用于教学和私下研究（peaceful research）；但是如果将其用于商业用途，那么必须通过Micrium获得商用许可。 mbedmbed SDK 体系及目录结构mBed（mbed.org）是ARM公司官方提供的一套用于快速开发ARM架构单片机应用原型的工具集，包括免费的软件库（SDK），硬件设计参考（HDK）和基于Web的在线编译环境（mBed Compiler）三部分。由于mBed的代码和大部分硬件设计都是以开源（permissive Apache 2.0 licence）的方式提供的，再加上它面向的ARM系列单片机具有较高的性价比和广泛的应用基础，所以mBed在世界范围内已经吸引了大量的电子产品开发者，其产业生态链已经初级规模。 MiCOMICO系统架构2014年7月，MiCO号称是中国首款物联网操作系统，由上海庆科（MXCHIP）发布。根据官方解释，MiCO的意思是Micro-controller based Internet Connectivity Operating system，是基于微控制器（MCU）的互联网接入操作系统，这个解释其实和物联网操作系统的意思一回事。MiCO本身包括：接口，框架，核心功能和非核心功能四部分。开发者可以在各种微控制器平台上，基于MiCO来设计接入互联网的创新智能产品。庆科与阿里有合作关系，阿里云的物联网套件的C-SDK，也有MiCO系统的版本。关于MiCO的更多信息，可以去MiCO开发者论坛（mico.io）了解。 MynewtMynewt（mynewt.apache.org）是Apache软件基金会（ASF: Apache Software Foundation）发起的一个开源项目，专注于物联网应用的实时操作系统。Mynewt的最大特色是包括了低功耗蓝牙（BLE4.2）无线传输协议栈NimBLE。Mynewt支持丰富的实时操作系统特征，可以在不同的硬件平台上运行，包括ARM Cortex M0-M4微控制器，以及基于MIPS和RISC-V架构的处理器。 ContikiContiki （www.contiki-os.org）是一个适用于有内存的嵌入式系统的开源的、高可移植的、支持网络的多任务操作系统。包括一个多任务核心、TCP/IP 堆栈、程序集以及低能耗的无线通讯堆栈。Contiki起源于瑞典的大学，基础内核以及大部分的核心功能是Swedish Institute of Computer Science的Adam Dunkels开发的。Contiki 采用 C 语言开发的非常小型的嵌入式操作系统，运行只需要几K的内存。Contiki都很受学术机构以及高校的科研人员青睐，常用于无线传感器网络（WSN：Wireless Sensor Network）的研究项目中。 NuttXNuttx（www.nuttx.org） 是一个实时嵌入式操作系统，它很小巧，在微控制器环境中使用，可用于8位到32位系统。NuttX的特色在于完全符合POSIX API标准，完全实时，并完全开放。目前常用于无人机的飞控系统中。 RIOT OSRIOT（riot-os.org）的目标是在物联网领域起到Linux在互联网领域那样的影响力。RIOT是一个开源、免费的操作系统。支持8位到32位的微控制器，可以运行在大多数低功耗物联网设备上。在GitHub（github.com/RIOT-OS）上可以找到RIOT的源码。 TinyOSTiny OS是UC Berkeley（加州大学伯克利分校）开发的开放源代码操作系统，专为嵌入式无线传感网络设计。与Contiki类似，Tiny OS同样来自于高校，由于其文档非常完善，其受欢迎程度甚至超过Contiki，不过国内使用者不多。操作系统基于组件（component-based）的架构使得快速更新成为可能，同时又减小了受传感网络存储器限制的代码尺寸。Tiny OS只需要几KB的内存空间和几十KB的编码空间。 ZephyrZephyr尽管是由 Linux 基金会托管的开源项目, 但 Zephyr 是一款完全独立的操作系统, 并未采用 Linux 代码。Zephyr微内核能运行在只有10KB RAM的32位微控制器上，相比之下基于Linux的微控制器项目uClinux需要200KB RAM。 结语除了上面列出来的操作系统，其实还有更多没有列出来的。就连谷歌也没闲着，正在秘密开发一个完全独立于Android的新系统，叫做Fuchsia（灯笼海棠），据说这个系统有可能采用iOS策略，走封闭路线。难道谷歌被安卓碎片化问题伤心了？物联网操作系统要比PC OS以及移动OS体量小，开发起来门槛也没那么高，很多很小的系统都可以作为商用，所以对于物联网产品设计者来说还是有很多选择的。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（一）：无线技术分类]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[物联网的关键技术包括三个方面：物体的识别、物体的连接以及对数据的操作。随着联网物体的数量越来越多，无线技术在物联网中发挥的作用也越来越大。 物联网无线技术分类 常见的物联网无线技术可以按照覆盖范围分为两大类： 一类是长距离（几百米到几公里）覆盖的无线广域网（WWAN）技术。代表技术有：NBIOT、eMTC、GPRS、802.11ah、LoRa、SigFox、Weightless等。 另一类是短距离（100米以内）覆盖的无线局域网（WLAN）或者无线个域网（WPAN）技术。代表技术有：WiFi、Bluetooth、Zigbee、RFID、NFC、Z-Wave等。 短距无线技术的应用场景由于智能手机的普及，平时生活中接触比较多的无线技术就是WiFi、Bluetooth（蓝牙）及NFC，这些都是智能手机普遍提供的无线连接能力。 与NFC类似的RFID的主要功能不是用来连接和通信，而是用于物体的识别（Object Identification）, NFC目前主要用于移动支付，比如银联IC卡闪付、Apple Pay等。 NFC广泛用于支付场景 WiFi、蓝牙、Zigbee以及Z-Wave等短距离无线技术，常用于智能家居这样的应用场景。目前国内智能家居市场WiFi、蓝牙以及Zigbee技术应用得比较多。Z-Wave与Zigbee类似，是由丹麦Zensys公司主导的技术标准，在国内比较少用。 对于WiFi连接的物联网设备，一般都支持TCP/IP协议，带有IP地址，这样可以直接通过IP协议接入互联网的服务器上。用户也可以用手机APP，通过物联网服务器来远程查看或控制物联网设备。 对于蓝牙或者Zigbee连接的物联网设备，没有IP地址，一般需要借助一个网关设备，才能接入网络。智能家居网关都带有网络连接，通过WiFi或有线接入到路由器，另外网关一般都集成了多种通信协议，还起到协议转换的作用。 大范围覆盖：LPWA技术对于室外需要大范围覆盖的场景，以上这些无线技术就不适合应用了。因为物联网节点分布非常广而且非常分散，如果要让每个节点都接入附近的路由器，就需要布设大量的路由节点，这样成本高，而且部署复杂。所以对于这种应用场景，非常适合远距离无线技术。 与我们平时手机上网用的3G、4G不同，物联网所需要的远距离无线技术，对传输速率的要求不高，同时要求具有极低的功耗，属于低速率低功耗的无线通信技术。对于这类技术，目前一般统称为LPWA（Low Power Wide Area），NB-IoT和LoRa都是其中的代表。 关于NB-IoT以及LoRa的技术详解，请继续关注我们的头条频道：“微说互联网”及“纵论物联网无线技术”。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（八）：面向可穿戴设备的无线物联网技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8F%AF%E7%A9%BF%E6%88%B4%E8%AE%BE%E5%A4%87%E7%9A%84%E6%97%A0%E7%BA%BF%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[导语智能手环、智能手表为代表的可穿戴设备，在短短几年时间内，就已经在全世界普及开来。可穿戴设备是物联网领域很重要的一种设备类型，特点是功耗低、体积小、电量有限 。本文主要介绍可应用于可穿戴设备的无线技术有哪些？ 蓝牙最流行 蓝牙无疑是可穿戴设备最流行的技术，蓝牙耳机就是一种非常常见的可穿戴设备。不过蓝牙耳机所使用的蓝牙技术还属于比较早的版本，一般是蓝牙2.1+EDR版。可穿戴设备中最流行的蓝牙技术都是BLE（Bluetooth low energy ）技术，也就是蓝牙低功耗。目前BLE一般都是蓝牙4.0或4.1版本。可穿戴设备一般体积都比较小，无法容纳电量很大的电池，所以要求无线功耗必须很低，这样才能有较长的续航时间，而不需要经常性地充电。 ANT+：运动家的最爱各种基于ANT+技术的运动传感器 除了蓝牙BLE经常用于手环、智能手表以外，针对运动类的可穿戴产品，ANT+协议也应用得很广泛。可以说，在运动领域，ANT+技术是蓝牙最大的竞争对手。ANT是一个无线传感器网络技术，由Dynastream Innovations下面的ANT Wireless部门设计和推广。ANT工作于2.4GHz ISM频段，有一套完整的通信协议栈。ANT技术与BLE类似，不过只面向传感器应用。ANT+是由ANT+联盟设计和推广的基于ANT协议的兼容性标准，可以认为是ANT的子集。ANT+与ANT的关系，就像WiFi与802.11一样。ANT+的缺点显而易见，就是大多数手机都不支持，只有少数手机，比如Sony的几款手机，支持ANT+技术。不过国际上大多数运动设备，如心率带、踏频器等，都是基于ANT+的。 GPSGPS是一种定位技术，不是用来通信的，但实际上GPS就是一个无线通信系统，只不过GPS接收器是与卫星进行通信，接收卫星的数据然后确定自己的位置。GPS在手环上不常见，一般在高端的运动手表上经常可以看到。尤其对于户外运动爱好者，GPS运动手表是必需品。 其他技术（1）WiFi像Apple Watch这样的智能手表还有上网功能，也就是说，可穿戴设备不必借助手机就可以联网。对于这类可穿戴设备，不再是智能手机的附属品，本身就是一个独立的互联网终端。 （2）GPRS/LTE/eMTC通过WiFi联网只能在有无线AP的地方才行，对于户外就无能为力了。针对老人或者儿童的安全手表，需要有户外联网的能力。GPRS是目前最常采用的技术。对于可穿戴设备来说，LTE是比较少见的，毕竟功耗还是有点高。除非是一些对数据流量有特别需求的产品，比如Apple Watch有LTE版。但要注意的是：LTE与续航不可兼得。面向物联网应用的eMTC，可以支持语音功能，也具有一定的数据传输能力，且功耗比GPRS要低得多，相信在未来将是可穿戴设备联网的首选技术。 结语相信随着技术的进步，可穿戴设备的联网能力越来越强，携带的电池容量很变大，通信的功耗也会降低。到了一定的程度，智能手机可能会以可穿戴设备形式出现在我们的日常生活中。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（九）：物联网设备的标识技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A0%87%E8%AF%86%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[导语物联网主要由三个方面关键技术：连接、标识以及数据的操作。 在前面的文章中，我们已经谈了很多关于物联网中物体如何连接网络的技术，而实际上物体的标识才是物联网实现的第一步，就是我们要唯一地标识和区分每一个物体。以RFID为代表的物体标识技术曾经几乎就是物联网的代名词，而今RFID的演进技术NFC又在各个领域发挥着重要作用。通过这篇文章，我们来聊一聊物联网设备的标识技术，RFID与NFC究竟有什么关系？ RFID非接触式射频识别(RFID)本质上也是一种无线通信技术，也是通过无线电磁波来传送数据。不过和一般的通信技术不一样的是它的用途，不是打电话，或者发短信，RFID主要用来识别和跟踪物体上绑定的标签，从而实现对物体的管理。RFID技术广泛应用于仓储物流中，用于对货物进行跟踪 RFID系统使用标签（Tag）来识别物体。除了标签，RFID系统还有一个双向无线收发机，被称为读写器（Interrogator/Reader），向标签发送信号，并读取标签的反馈。RFID系统由读写器与标签组成RFID分为被动式RFID与主动式RFID。被动RFID一般是指不带电池的无源RFID，其完全依赖于接收电磁波来驱动电路工作，标签的可识别距离不会变化。主动RFID系统一般指有源的RFID标签，其可识别距离会随着电量的减少而降低。采用RFID技术的ETC系统让通行更加方便 主动RFID一般识别距离都比较长，比如高速公路自动收费站以及自动停车场的ETC系统，一般都采用工作于2.4GHz的主动RFID。不过ETC标签中有一个电池，要是电池没电，就需要更换电池才可以工作。 RFID标签RFID标签由集成电路（IC: Integrated Circuit）和天线两个部分组成：IC用来存储和处理数据，对RF信号进行调制和解调，另外还需要从读写器发出的信号中收集能量驱动自身工作。天线的作用就是发射和接收无线信号。 EPC码格式，EPC码可能逐渐会取代传统的UPC码，即商品条码 RFID标签中存着什么？RFID标签中存储的数据格式一般是EPC（Electronic Product Code）码。EPC码可以识别世界上所有的物体。EPC码的结构由EPCglobal Tag Data Standard标准定义，这个标准是一个公开标准，可以从EPCglobal Inc网站上面免费下载。 NFC技术说完RFID，再来说说近场通信（NFC: Near Field Communication）。NFC是目前手机非常常见的一个通信接口。可以让智能设备通过相互靠近的方式来交换数据。NFC设备也可以与一个无源的NFC标签之间进行通信，这个通信方式就和RFID是一样的。NFC的通信方式NFC技术是由RFID技术演变而来，除了通信协议，NFC标准还规定了数据交换格式。在NFC单一芯片上结合了感应式读卡器、感应式卡片和点对点的功能，能在短距离内与兼容设备进行识别和数据交换。 NFC与RFID的区别（1）工作频段NFC可以理解为RFID技术的一个子集，使用的是13.56MHz频段，而RFID还包括其他频段。RFID的工作频段有很多，低频段有125KHz，高频段有13.56MHz，超高频段有433.92MHz、915MHz，还有微波频段的2.45GHz等。（2）通信距离NFC被称为近场通信，通信距离确实非常近，不超过0.1m。RFID种类很多，可识别距离也不一样。像RFID门禁卡，识别距离和NFC差不多。但对于ETC这种应用场景，就要求识别距离比较长。长距离RFID的识别距离可达几十米甚至上百米。（3）应用场景RFID无论主动还是被动，主要工作还是用于对物体的识别，物流、运输、仓储都广泛使用了RFID技术来跟踪货物。NFC芯片的集成度更高，包括了读卡器与标签于一体。另外NFC的双向通信能力得到了加强。也就是说，NFC不仅可以当做标签来做识别，还可以作为一种双向通信方式用于数据交换。目前NFC最常用于支付领域。NFC技术被广泛应用于支付场景 总的来说，虽然NFC是在RFID技术基础上发展而来的，但是面向不同的应用场景，并不存在替代作用。况且现在RFID的应用场景还是非常多的，NFC暂时还比不了。即使在支付领域和近距离物体识别领域，二维码在很多场景下也能起到NFC的作用，目前对智能手机来说，NFC还不是一个必需的通信接口。如果希望了解更多关于物联网的信息，请继续关注“微说互联网”的“纵论物联网”系列。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（三）：3GPP物联网技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A3GPP%E7%89%A9%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[导语随着物联网应用的发展，对于大范围组网的需求越来越多，LPWAN技术备受关注。前面的LPWAN技术文章介绍过，LPWAN技术可根据工作频段分为两类：一类是工作于未授权频段的无线技术，以LoRa、SigFox为代表；一类是工作于授权频段下的无线技术，以3GPP支持的2/3/4G蜂窝通信技术为代表。 本文重点介绍一下国际电联下的标准化组织3GPP为物联网应用推进的技术标准，其中最具知名度的技术就是NB-IoT了。 3GPP是什么？ 为了解决各国2G蜂窝通信系统互不兼容的问题，各国通信标准化组织在1998年12月成立了3GPP，最初成立的目标是实现由2G网络到3G网络的平滑过渡，保证未来技术的后向兼容性，支持系统间的漫游。现在3GPP已经发展成为最具权威的国际移动通信标准制订机构，4G以及未来5G的通信标准都是由3GPP来制订。3GPP每一个标准规范都叫做一个Release，简称R-xx，xx是标准的数字编号，比如最早1999年的R99，之后的版本号是R4，R5，等等。3GPP与各种标准化组织的关系 GPRS是在GSM网络基础上发展起来的数据通信技术，用来解决2G网络中数据传输的业务需求。现在广泛应用于物联网项目中。不过由于GPRS的功耗较高、系统容量有限等缺点，所以业界一直寻求GPRS的低功耗低成本的替代方案，也就是LPWAN技术。前文介绍过的LoRa、SigFox都属于这类技术。不过LoRa，SigFox都是公司提出的私有标准，3GPP作为国际性的标准化组织当然也没闲着，针对物联网的技术需求，3GPP也提出了一系列物联网技术标准，总的来说可以分为三类：基于LTE网络演进的LTE-M技术基于GSM/EDGE网络演进的EC-GSM以NB-IoT为代表的Clean Slate技术。LTE-M（eMTC）LTE-M，即LTE-Machine-to-Machine，是基于LTE演进的物联网技术。LTE-M在3GPP标准R12中叫低功耗MTC（Low-Cost MTC），其中MTC是Machine Type Communications的缩写。在R13中LTE-M被称为enhanced MTC，也就是目前媒体在宣传的eMTC。旨在基于现有的LTE载波满足物联网设备需求。为了适应物联网应用场景，3GPP在早期的LTE标准中，曾定义了最低速率的UE设备为Cat-1，这种设备不支持MIMO，使用单天线传输速率低，功耗也低，上行速率为5Mbps，下行速率为10Mbps。为了进一步降低功耗并满足低速率需求，3GPP到了R12中又定义了更低成本、更低功耗的Cat-0，其上下行速率为1Mbps。一般的LTE设备的信道带宽可以达到20MHz，对于低速率的IoT设备来说，完全不需要这么宽的工作带宽。在R13标准中制定了Cat-M1设备标准，最大工作带宽只有1.4MHz，所能支持的最大速率是1Mbps。下图可以看出LTE cat-M1与LTE cat-1、LTE cat-0的传输速率比较。 各种物联网技术的速率比较 EC-GSM3GPP下面有好几个技术规范组（TSG），比如TSG RAN是负责制订LTE标准的。另外还有一个专门负责GSM/EDGE标准的TSG GERAN。GERAN是GSM/EDGE Radio Access Network是缩写，意思是GSM/EDGE无线接入网络。基于GSM演进的物联网标准自然也由TSG GERAN来负责。 3GPP组织结构 2014年3月，3GPP GERAN 提出，要将窄带（200 kHz）物联网技术迁移到GSM上，寻求比传统GPRS高20dB的更广的覆盖范围，并提出了5大目标：提升室内覆盖性能、支持大规模设备连接、减小设备复杂性、减小功耗和时延。这些目标也可以认为是LPWAN技术的共同追求。2015年，TSG GERAN #67会议报告表示，制订的EC-GSM技术已满足5大目标。EC-GSM，即扩展覆盖GSM技术（Extended Coverage-GSM）。虽然标准化已经完成，但没有什么落地的应用。NB-IoT3GPP在R12/R13在LTE标准中加入了MTC相关技术标准，但其本质是在既有LTE技术与架构上进行优化，并不是针对物联网全新设计。不同于MTC，蜂窝物联网(Cellular Internet of Thing, CIoT)项目建议针对物联网特性全新设计，不一定要兼容既有的LTE技术框架。2015年8月，3GPP的TSG RAN开始立项研究窄带无线接入全新的空口技术，称为Clean Slate CIoT。Clean Slate的字面意思就是清白历史，意味着抛掉LTE技术的历史包袱，重新开始设计。在正式标准开始制订以前，企业早已动手开始设计新的空中接口，并形成了两个主要的技术提案：NB-CIoT方案是由华为、沃达丰和高通联合提出，NB-LTE方案是由爱立信、诺基亚等厂家提出。最终，在2015年9月的RAN #69会议上经过激烈撕逼后协商统一，两大阵营相互妥协，最终版本的NB-IoT标准可认为是NB-CIoT和NB-LTE的融合。未来展望今年不断有消息称，国内三大运营商有计划关掉2G网络或者重耕900M频段，将其用于NBIoT网络，估计国内物联网未来eMTC和NBIoT会成为主流技术。但LoRa有先发优势，已经有成熟的商用项目。短期内估计NBIoT的芯片成本还降不下来，预计未来2~3年，多种LPWAN物联网技术会长期共存]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（七）：面向智能家居的物联网解决方案]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[导语智能家居是非常广泛的一类物联网应用。目前国内最常用的面向智能家居的无线协议有WiFi、Zigbee、433MHz无线技术，另外还有基于电力线载波的有线解决方案。今天我们聊一下常用于智能家居的技术有哪些？ 433MHz及红外 红外与433MHz常用于对家电或照明系统的遥控上。电视、空调通常配备的遥控器都是红外的。如果要通过网络实现远程控制的话，需要有一个能够联网的红外转发设备，把网络指令转换为遥控电器的红外信号。 BroadLink万能遥控器由手机通过WiFi控制，集成了红外及433MHz遥控能力433MHz与2.4GHz一样，也是一个免授权的频段，常用于遥控。与红外相比，433MHz的传输距离更远，不受视距限制，不需要对准被控物体，适合比较大的环境。目前有一些遥控电灯、遥控开关面板，都是基于433MHz的。 ZigbeeZigBee应用广泛Zigbee与WiFi都常用于智能家居的解决方案中。Zigbee协议基于IEEE 802.15标准，主要针对低功耗的射频节点组网而设计。Zigbee使用OQPSK调制技术，传输速率为250kbps，传输距离在10m到100m。Zigbee节点可以扮演中继的作用，组建Mesh网络，因此Zigbee设备可以经过多跳将数据传输到很远范围以外的节点。国内有很多公司都开发了基于Zigbee协议的智能家居解决方案。但相比WiFi来说，Zigbee方案中必须需要网关设备。网关起到协议转换的作用，否则Zigbee设备无法与手机进行互操作，也无法直接接入互联网。 WiFiWiFi可以说是目前最常见的智能家居解决方案。所有的设备都可以接入无线路由器，手机也可以对设备直接进行控制，不需要网关的协议转换，比Zigbee方案更容易被接受。基于WiFi的设备还可以直接接入网络，很容易实现远程控制。不过WiFi的耗电量相比Zigbee略高一些，所以可能不太适合对功耗要求比较苛刻的应用场景。 Z-WaveZ-Wave是由丹麦公司Zensys主导的专门面向智能家居应用的无线组网协议。Z-Wave使用GFSK调制技术，工作于ISM免授权频段。传输速率最高可以达到100kbps，没有Zigbee高。单跳的传输距离要比Zigbee远。与Zigbee类似，Z-Wave也有一个产业联盟，不过没有Zigbee联盟那么强大。Z-Wave联盟中包括了不少智能家居的相关产品，如HVAC、照明、安防等。目前Z-Wave在国内没有得到广泛应用，远远不如Zigbee更受市场青睐。 其他解决方案（1）OpenHABOpenHAB全称为open Home Automation Bus，即开放式家庭自动化总线，该项目旨在为家庭自动化构建提供一个通用的集成平台。OpenHAB是一个基于Java的开源项目，其设计是厂商中立的，与硬件/协议无关。OpenHAB通过绑定，汇集了不同的总线系统、硬件设备和接口协议。 （2）C-BusC-Bus 系统由澳大利亚奇胜（Clipsal）公司开发，该公司是施耐德的子公司。C-Bus 是一种以非屏蔽双绞线作为总线载体，应用于建筑物内照明、空调、火灾探测、出入口、安防等综合管理的智能化控制系统。 （3）InsteonInsteon是一种复杂度低，功耗低，数据传输速率低，成本低的双向混合通信技术，具有即时响应，易安装，易使用，经济可靠的特点，且与X10兼容。之所以说Insteon是混合通信技术，是因为Insteon同时支持电力线通信与无线射频通信两种方式。 （4）KNXKNX是Konnex的缩写。1999年5月，欧洲三大总线协议EIB、BatiBus和EHSA合并成立了Konnex协会，提出了KNX协议。该协议以EIB为基础，兼顾了BatiBus和EHSA的物理层规范，并吸收了BatiBus和EHSA中配置模式等优点，提供了家庭、楼宇自动化的完整解决方案。 （5）UPBUPB是Universal powerline bus的简写，即通用电力线载波总线。UPB也是专门用于家居自动化（home automation）的通信协议，使用电力线传输信令与控制指令。UPB在1999年由美国的PCS Powerline System公司开发。 （6）X10X10是一种国际通用的智能家居电力载波协议，用X10的兼容产品可以通过电力线相互沟通，无需重新布线，被控制的电器可多达256路。20世纪80年代，美国SmartHome概念兴起,也就是现在智能家居的原型，在上世纪，X10技术被广泛应用。 结语应该说智能家居在互联网兴起以前就发展了一段时间了，因此有很多历史遗留的协议，比如X10, KNX等等。随着互联网的普及，基于IP的协议与传统协议之间就在智能家居领域存在很多竞争和共存的问题。现在智能家居的最大问题就是协议太多，即使底层用一套协议，各家厂商的上层协议也都互不兼容，最后导致用户使用起来很麻烦。这是智能家居没有得到广泛应用的主要问题。想要了解物联网的其他领域应用，请继续关注“微说互联网”及“纵论物联网”系列文章。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（十）：物联网应用层协议]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[导语物联网的关键技术主要解决三个方面的问题：物体的识别、物体的连接、物体的数据交换。每个方面都有一些技术解决方案，在前面的文章中，我们介绍了RFID、NFC等物体识别及电子标签的技术，也介绍了物联网节点组网与接入的技术。这篇文章主要讲一下物联网的数据是如何处理的。物联网关键技术大全 物联网应用层协议LoRa、NB-IoT以及Zigbee、蓝牙主要解决的是物体互联以及接入网络的问题，从网络协议分层来看，基本上都属于数据链路层协议。对于物联网的数据交换，主要依靠应用层协议来解决。在移动互联网中，最常用的应用层协议就是HTTP协议，HTTP协议同样可以用于物联网系统中。HTTP协议采取的是请求-响应（Request-Response）的通信机制，服务器没有办法主动给客户端发送消息。如果要实现这种消息推送，就需要借助WebSocket这种全双工的通信机制。不过对于很多计算和存储资源有限的物联网节点，不太适合使用HTTP协议。除了HTTP协议以外，也有很多更适合于物联网应用的协议，比如MQTT、CoAP、AMQP、STOMP等。各个物联网软件平台最常使用的物联网协议 发布-订阅机制很多物联网应用层协议都是基于发布-订阅(Publish-Subscribe)机制，这种机制非常适合物联网系统应用。MQTT协议、STOMP协议、AMQP协议以及DDS协议都属于这种发布-订阅的机制。每个传感器节点，采集的数据需要上传到网络，相当于是一个消息的发布，这个消息需要基于某个主题，比如传感器的类型。所有关心这个主题的节点，都可以通过订阅这个主题的消息，实时获取最新的数据。消息的发布和订阅是基于某个主题的，实现机制一般依赖于消息队列 MQTT协议消息队列遥测传输协议（MQTT : Message Queuing Telemetry Transport）是为大量计算能力有限，工作带宽有限、网络环境不可靠的传感器或控制器而设计的协议。MQTT协议基于TCP协议 MQTT协议原来是IBM开发的一个即时通讯协议，基于TCP协议实现。MQTT客户端需要通过消息代理（MQTT Broker）来进行消息的发布和订阅。MQTT协议的兼容性非常好，几乎支持所有平台，可以把各种物联网设备都连接起来。所以MQTT协议也是目前应用最广泛的物联网应用层协议。 CoAP协议受限应用协议（CoAP：Constrained Application Protocol）是6LowPAN协议栈中的应用层协议，基于REST（表述性状态传递）架构风格，支持REST交互。CoAP协议基于UDP协议 CoAP基于UDP协议，其设计初衷就是尽可能地方便地转换为HTTP协议。CoAP让用户可以像使用HTTP协议一样，在资源受限的物联网设备中使用CoAP协议。 AMQP协议高级消息队列协议（AMQP：Advanced Message Queuing Protocol）是一个提供统一消息服务的应用层标准高级消息队列协议，为面向消息的中间件设计。AMQP的工作原理 AMQP的工作原理与MQTT类似，也是基于发布-订阅机制。消息代理Broker的交换机组件（Exchange）会把接收到的消息，根据消息的主题，分配到不同的队列中，以便订阅者接收。RabbitMQ就是在AMQP协议基础上实现的一个消息系统，遵循Mozilla Public License开源协议。RabbitMQ在互联网应用中常被用作消息服务器。 STOMP协议简单(流)文本定向消息协议（STOMP: Simple (or Streaming) Text Orientated Messaging Protocol)，提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理（Broker）进行交互。STOMP协议由于设计简单，易于开发客户端，因此在多种语言和多种平台上得到广泛地应用。当前非常流行的开源消息服务器ActiveMQ、Apollo、RabbitMQ（需要插件）都支持STOMP协议。ActiveMQ支持TCP、XMPP、STOMP等协议进行消息传输 STOMP基于TCP协议，客户端和服务器之间的通信是通过“帧”（Frame）来实现，每个帧由多“行”（Line）组成。STOMP协议定义了帧结构。 Stomp帧格式STOMP帧第一行是命令，紧跟着键值对形式的Header内容。然后是一个空行，最后是Body内容。数据分发服务DDS数据分发服务（DDS：Data Distribution Service for Real-Time Systems），是面向实时系统的数据分布服务，是由OMG组织提出的协议。 DDS的数据分发的实时效率非常高，能做到秒级内同时分发百万条消息到众多设备。DDS在服务质量（QoS）上提供非常多的保障途径，因此适用于国防军事、工业控制这些高可靠性、可安全性应用领域的原因。不过DDS目前还只限于在有线网络部署，无线网络的可靠性可能满足不了DDS的QoS要求。 总结上面列出了一些比较常见的物联网应用层协议，但并不全面，还有一些相对更加小众的协议，公开资料也比较少。目前很难说哪种物联网应用层协议会实现垄断局面，还要看各自生态和市场需求的未来发展。如果希望了解更多关于物联网的信息，请继续关注“微说互联网”的“纵论物联网”系列。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[最近在网上看到一篇介绍物联网的系列文章《纵论物联网》，但是很遗憾，都是来回转载的，也没有找到出处，零零散散的，东一篇西一篇，看起来很不方便。现汇总收集如下，既做整理，也做收藏。纵论物联网（一）：无线技术分类纵论物联网（二）：LPWAN技术纵论物联网（三）：3GPP物联网技术纵论物联网（五）：除了Linux，还有什么物联网操作系统纵论物联网（六）：基于Linux的物联网操作系统纵论物联网（七）：面向智能家居的物联网解决方案纵论物联网（八）：面向可穿戴设备的无线物联网技术纵论物联网（九）：物联网设备的标识技术纵论物联网（十）：物联网应用层协议]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵论物联网（二）：LPWAN技术]]></title>
    <url>%2F2017%2F10%2F26%2F%E7%BA%B5%E8%AE%BA%E7%89%A9%E8%81%94%E7%BD%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ALPWAN%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[不同的物联网技术适用于不同的应用场景。对于需要远距离大范围覆盖的场景来说，我们熟悉的蓝牙、WiFi、Zigbee这些技术都不适合，我们需要低功耗广域网（LPWAN：Low Power Wide Area Network）技术。LPWAN技术的特点是： 覆盖远，支持大范围组网；连接终端节点多，可以同时连接成千上万的节点；功耗低，只有功耗低，才能保证续航能力，减少更换电池的麻烦；传输速率低，因为主要是传输一些传感数据和控制指令，不需要传输音视频等多媒体数据，所以也就不需要太高的速率，而且低功率也限制了传输速率。当然还有就是成本要低，这样才有应用推广的可能性。本文主要介绍一些目前比较有代表性的LPWAN技术，特别是使用免授权频段的无线技术。无线物联原本是GPRS的天下当移动蜂窝网络发展处于2G、3G和4G时代，对于需要广域覆盖的物联网应用来说，比如物流行业的车辆定位与跟踪，或者无人值守系统的故障监控，一般都采用传统的GPRS技术。但GPRS数据传输单元（DTU: Data Transfer unit）的功耗和续航能力都不够理想，而且受限于GPRS网络的覆盖，对于没有GPRS信号就没法使用GPRS来传输数据了。 GPRS的物联网应用架构图 为了应对日益强烈的物联网需求，国际电联ITU-T也在LTE以及后续的5G移动通信标准中推进适合物联网应用的广域网标准，如eMTC、NB-IoT等，目前这些新的M2M技术标准尚未达到可大规模商用的成熟度。在移动蜂窝网络面向物联网的新标准推出前，也有很多公司和组织开发了比GPRS更低功耗且容易部署的替代方案，一些方案目前正在被广泛应用中，比如LoRa，SigFox等。SigFox2009年，法国公司SigFox展示了自己的超窄带（UNB: Ultra Narrow Band）技术，被业界视为是LPWAN领域最早的开拓者。UNB技术每秒只能处理10到1000比特的数据，传输功耗水平非常低，却能支持成千上万的连接。SigFox无线链路使用免授权的ISM射频频段。频率根据国家法规有所不同，在欧洲广泛使用868MHz，在美国是915MHz。SIGFOX网络中单元的密度，在农村地区大约30-50km，在城市中常有更多的障碍物和噪声距离可能减少到3-10km之间。SigFox的UNB技术使用标准的二进制相移键控（BPSK: Binary Phase Shift Keying）的无线传输方法，采用非常窄的频谱改变无线载波相位对数据进行编码。 SigFox公司不仅是标准的制定者，同时也是网络运营者和云平台提供商，目标是与合作伙伴建造一个覆盖全球的IoT网络，独立于现有电信运营商的移动蜂窝网络。目前SigFox在欧洲已经部署了不少网络，在中国还没有部署。LoRaLoRa是美国Semtech公司推广的一种超远距离无线传输方案。2013年8月，Semtech公司发布了一种基于1GHz以下的超长距低功耗数据传输技术的芯片, LoRa是长距离（Long Range）的缩写。 其接受灵敏度达到了惊人的-148dbm，与业界其他先进水平的sub-GHz芯片相比，最高的接收灵敏度改善了20db以上，这确保了网络连接可靠性。LoRa使用线性调频扩频调制技术，工作在非授权频段，数据传输速率在0.3kbps~37.5kbps。LoRa还采用了自适应速率(ADR: Adaptive Data Rate)方案来控制速率和终端设备的发射功率，从而最大化终端设备的续航能力。LoRa与Sigfox最大的不同之处在于LoRa是技术提供商，不是网络运营商。谁都可以购买和运行LoRa设备，LoRa联盟也鼓励电信运营商部署LoRa网络。目前国内已经有一些LoRa的方案商。WeightlessWeightless是由一个非盈利全球标准组织Weightless SIG（Weightless Special Interest Group）提出的技术。与LoRa、SigFox类似，Weightless也是一种专为物联网设计的无线技术。Weightless既可以工作在Sub-GHz免授权频段，也可以工作在授权频段。通信距离可以达到10公里。Weightless有三个不同的开放标准：Weightless-N、Weightless-P和Weightless-W。如果考虑成本，可选择单向通信的Weightless-N。如果考虑高性能，可选择双向通信Weightless-P。如果当地TV空白频段可用，可选择Weightless-W。RPMARPMA技术的全称是随机相位多址接入（Random Phase Multiple Access）。由美国Ingenu公司开发，Ingenu在2008年成立，公司在2015年9月前的名称是ONRAMP。RPMA技术工作在2.4GHz免授权频段，支持全双工通信，这点是比SigFox和LoRa强的地方。SigFox采用的是单向传输，LoRa采用的是半双工的通讯方式。Ingenu为开发人员提供了收发器模组，这些模组可以连接到RPMA网络，这个网络是由Ingenu公司及其合作伙伴在全球范围内建立的网络，这与SigFox比较类似。RPMA网络将来自终端节点的信息转发至使用者的IT系统。RPMA也可适用于想要搭建私有网络的客户人群。结语随着各大电信运营商在原来LTE网络基础上大范围部署NB-IoT以及eMTC网络，未来物联网的无线技术竞争将更加激烈。 在各种技术在基本技术指标上没有明显差异的情况下，成本、整体解决方案、开发者生态以及整个产业链将会决定最终技术的命运。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音交互系统的自动化测试思考]]></title>
    <url>%2F2017%2F09%2F01%2F%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 机器人OS 不同于传统的OS，不同之处在于交互方式的不同。人机交互界面（HMI)，简化思考无外乎就是输入输出（I/O)，之前的自动化测试可以很大程度上覆盖需求，是否就是很大程度上模拟了输入输出，并分析了输出的结果（不知者无畏）? 长远考虑，从稳定性或者测试效率考虑，搞搞自动化测试应该利大于投入吧？ 原理上能否实现？基本思路如下图：结合机器人OS，输入有（asr/keyevent/mic matrix/visual) 输出有（tts/display/app/motion)，这些在framework部中基本都对应一个server，真实的输入输出由与其绑定的运行在其他进程中的service实现。server的作用基本就是消息转发。对应于系统的整体框架图，基本就是下图中红线框出的部分。特别说明AppServer 也作为一个输出Server，它输出的是对应用的调度动作。综上：在架构实现上需要在（替换/插入）测试service的地方需要在现有代码中做判断：在正常使用时加载正常的service，在测试环境下替换加载测试用的service。测试用service在独立apk中实现，通过service的绑定机制绑定到对应server中。 可以这样实现：基于以上原理，实现一个autotest的apk，在测试模式下替换了正常的AsrService，当机器人开始listen的时候从模拟asr的service中返回预先写好的剧本中的一句话，实现可控输入。操作说明：1、打开自动测试开关修改配置项 auto_test_replace_asr的值为true。2、编写剧本文件目前是固定的文件名（autotest.txt)，稍后实现可选择加载不同的剧本文件每行一个输入语句，换行即为下一条输入。将剧本 push 到 机器人的 sdcard下。例如：123456# 这是注释你好slient 2loop 5今天天气怎么样？end 3、安装机器人AutoTest.apk。4、重启机器人，等待进入执行脚本，执行过程中可根据具体测试用例，认为制造些异常（例如断网等），目前还不支持模拟摸头，唤醒词模拟等(lll￢ω￢)，所以需要手动5、测试过程中，更新autotest.txt 文件修改完重新push后，打开autotest 应用的界面，点击重新加载剧本即可。 长远实现：1、补全可自动化测试的模块实现HeadServiceTest, MicServiceTest, VisualServiceTest, 在自动化时挂载入系统模拟 这几类输入实现TTSServiceTest，DisplayServiceTest, MotionServiceTest, AppServiceTest, 在自动化时插入系统中，获取相应模块执行的结果并记录。2、脚本语法丰富（注释/Listen/Head/Mic/Visual）关键字的简单实现，记录结果的简单语法实现（Speak/App/Show/Do)3、分析：比较输入脚本和记录的输出结果，分析bug4、报告：根据分析结果提供可视化的报告。]]></content>
      <categories>
        <category>机器人OS</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于RT-Linux机器人控制系统实时性的探讨]]></title>
    <url>%2F2017%2F08%2F31%2F%E5%9F%BA%E4%BA%8ERT-Linux%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%97%B6%E6%80%A7%E7%9A%84%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 在机器人控制器的设计中，如何最大程度的提高机器人控制的实时性是一个关键问题。这里我们运用了将软件任务划分实时域与非实时域的思想，实现了一种将RT-Linux与Linux结合的实时机器人控制系统。该系统的优点是：提供了非常高效的满足底层硬件设备的实时性能，可以充分利用 Linux的强大功能；而且RT-Linux是完全开放源代码的免费软件，降低了开发成本。本文是一篇不知从何处舶来的文章，作于2016年11月3日… RT-Linux的系统结构 RT-Linux的基本思想就是使Linux运行在实时核心之下，如图1所示。RT—Linux是一个可加载的核心模块。一个小的RT-Linux实时内核同原来的Linux内核共同控制处理器。实时内核直接管理硬件中断，因此实时内核操纵着机器的响应时间，原来的Linux就无法影响实时任务了。在RT- Linux中设计了两类中断。软中断是正常的Linux中断，硬中断则是真正的实时中断，执行时几乎没有任何延迟。实现时，RT-Linux是通过在 Linux核心和中断处理器之间设计一个仿真软件来达到其目的的。 在RT-Linux中采用两种调度策略。一种是基于优先级的抢占式调度算法；另一种是lsmaelRipoll实现的 EDF（EarliestDeadlineFirst）算法。对于周期性任务可以采用单调率调度算法，即周期短的任务能够获得较高的优先级。调度策略将 Linux视为赋予最低优先级的实时任务。 Linux仅仅在实时系统没有其它任务时运行。Linux和实时任务之间的转换依据上述提及的软中断状态而定。RT-Linux通过这样一种设计方法，将标准的Linux核心改成一个可抢占的、具有低延迟中断处理的实时系统。 实时机器人控制系统的软／硬件结构硬件系统结构 整个实时机器人控制系统主要的硬件部件为：与IBM—PC兼容PentiumIII733MHzq-业控制微机（IPC），内存l28MB；三轴位置控制卡（PCL一832）；l0／100M自适应网卡、集线器等以太网连接设备；机器人本体为具有5个自由度的日产PT500机器人。 机器人控制器运行于一台工业控制微型计算机（IPC）上。在该IPC上安装了两块三轴位置控制卡。每块三轴位置控制卡能对三轴进行联动插补控制。每轴有专用位置芯片控制，构成一个伺服位置和速度环。放在DDA脉冲缓冲器中的脉冲数被传到DDA发生器，在下一个DDA周期中输出。然后由三轴位置控制卡将各轴对应的脉冲数解释为相应的电平信号，驱动伺服驱动器以驱动机器人本体的运动。 软件系统结构 整个机器人实时控制器的系统结构如图2所示，整个系统分为2个域：实时域和非实时域。实时域中实现的是实时设备驱动程序，负责PCL-832位置控制卡的控制与中断响应，驱动机器人本体运动；非实时域中实现的是上层的机器人控制界面和远程监控子系统；二者之问通过实时先进先出（RT-FIFO）缓冲队列进行数据交换。内核调度策略将Linux视为赋予最低优先级的实时任务，Linux中的非实时任务仅仅在实时系统没有其它任务时运行，以确保实时任务的最高实时优先级。 RT-Linux中的实时模块 实时域中的软件模块主要是三轴位置控制卡（PCL一832）的设备驱动程序。驱动程序是能够直接访问硬件的模块，具有应用程序不具备的处理中断和读写端口的能力，是嵌入操作系统核心的底层软件。三轴位置控制卡以毫秒级发出DDA中断请求，对DDA中断的响应的快慢是决定整个机器人控制器实时性能的关键指标。RT-Linux中的三轴位置控制卡的实时设备驱动程序必须处理以下事务： ① 响应三轴位置卡的插补周期中断（DDA），并输出位置脉冲数值； ② 响应三轴位置卡的误差溢出中断（Ov），通知应用程序进行相应处理； ③ 为应用程序提供服务，如读写I／O端口、设置参数、读取状态等。 Linux中的非实时模块 非实时域中的软件模块由机器人控制器和远程监控子系统组成。本地的机器人控制器负责将文本机器人指令解释成相应的位置脉冲数据，通过先进先出（RT- FIFO）缓冲队列发送给实时域中的驱动程序驱动机器人本体运动。同时具有权限的用户能够以离线编程方式或在线操作方式通过高速以太网分别与离线编程与仿真数据发生器和机器人控制器进行连接，实现离线编程和对机器人的实际控制。 实时系统的性能评估 实时系统的性能评估主要在8个方面进行。它们分别是任务换道性能、任务优先级性能、内存分配性能、任务内部通信性能、中断延迟时间、操作系统运行时效率、初始化时间和关机时间。而在机器人控制中最讲究的就是中断响应时问。因为就本项目而言，我们最关I～，RT-Linux系统对三轴位置控制卡（PCL一 832）的DDA中断的响应时间，所有工作的目的就是为了尽量减少中断响应时间。 测试环境及方法 用于测试的工业控制微机的硬件配置为IntelPentium（clockl20MHz），RAM64MB；服务器软件是用 RedHatLinux6.0（内核版本号2.2.5一l5），RT-Linux的版本号2.2；网络环境l0／100M自适应网卡。中断响应时间的快慢直接反映了这样一个过程的快慢：在用户层的用户进程通过系统调用将脉冲数据写入位于核心层的实时驱动程序的数据缓冲队列，在下一个DDA中断请求到来时，中断服务例程将数据缓冲队列中的脉冲数据写入三轴位置控制卡的动作控制芯片的缓冲区，驱动机器人本体运行。图3反映了上述过程。基于RT-Linux机器人控制系统实时性的探讨 测试结果 分别设置DDA周期为8、12、16、24ms的4种情况作了测试，经过计算，可以得出表1所示的结果。基于RT-Linux机器人控制系统实时性的探讨 表1 低负载下D DA中断响应处理时问测试结果 由此得出，在低负载下RT-Linux的测量时间要比Linux下快0.5—0.6ms左右，证明采用RT—Linux系统确实能够提高系统的实时性能。需要注意的是： ① RT—Linux直接接受硬件中断，所以我们将PCL一832卡的DDA中断和OV中断安装在实时域中，目的就是让RT-Linux最先捕获这两个实时中断，进行处理。 ② 如果用户应用层开辟大量的用户进程，则对于分时的标准Linux来说会受到很大程度的影响。 由测试结果可看出，RT-Linux系统中断响应比标准Linux延时时间短，这个结果也预示在系统高负载情况下RT-Linux系统中的实时性能的优势将更为明显。实际使用该实时机器人控制器时，机器人运行非常稳定，能够满足实时控制的需要。]]></content>
      <categories>
        <category>机器人OS</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷. 硝烟中的scrum和xp]]></title>
    <url>%2F2017%2F08%2F31%2F%E6%95%8F%E6%8D%B7%EF%BC%9A%E7%A1%9D%E7%83%9F%E4%B8%AD%E7%9A%84scrum%E5%92%8Cxp%2F</url>
    <content type="text"><![CDATA[最近在安排国庆的旅行计划，目的地是鲁迅的故乡绍兴。鲁迅有本散文集《朝花夕拾》，又名《旧事重提》。回顾整理以往的经验，故名《旧日往昔》。 本文是一篇读书笔记，作于2012年3月6日…scrum不能解决问题，解决问题靠开发团队自己出色的团队最重要的是有良好素质的团队，这些素质包括进取心、责任心、良好的习惯、热情，其次才是技术、流程scrum提供了一套实践方法，帮助软件团队养成良好的习惯 scrum原理 目标驱动，在统一的软件交付目标下组织团队 依靠团队的智慧做项目评估、计划乃至设计、开发、测试（？） 抓住项目的最基本开发属性. 周期+质量周期用T表示，质量用B表示（bug数目量化），scrum有助于T*B 尽量小， scrum的角色和职责 产品负责人(product owner)，定义开发目标、需要实现的features和优先级 scrum master，保证团队高效而不受打扰的工作，优化工作条件、过程 团队(team)，自组织的完成项目开发,使用一切可行手段保证进度和质量外围有user,customer,Management scrum过程 前期. 产品负责人整理业务需求，形成product backlog库 执行. 以sprint为单位进行迭代完成sprint backlog，每日例会+issues，sprint结束时交付可运行的产品 后期. sprint完成后通过sprint回顾发现问题和改进点，制定下个sprint要引入的新的实践? scrum的精髓 以上过程也没什么特别的，和UP的迭代几乎一样。精髓在于“检查并适应”，在三个角色、三种仪式（sprint计划、sprint回顾、每日例会）、三种制品（backlog、sprint backlog、燃尽图）的基础上，可以根据公司和项目情况，因地制宜的引入任何有利于缩短开发周期、提高产品质量的实践。 具体细节 sprint前. 产品负责人收集需求，形成backlog，backlog以统一格式定义，重要的属性有. 名称、重要性、估算时间、简单描述、如何演示等，详细的需求可以在其他需求文档中定义。产品负责人可以通过任何渠道、方式获取和确认需求。 sprint启动会议. 一个sprint周期为两周，一次sprint会议约一个下午，参与人员为3个角色都参加，scrum master主持会议。会议内容详细沟通产品负责人选定的重要性高的产品backlog细节，确保团队对需求的理解无误。团队根据需求理解将backlog拆分成任务，并给出每个backlog的估算时间，产品负责人和团队根据sprint内可用的人天和backlog的时间估算，选定需要排入本次sprint的backlog，scrum master和团队分派任务，制定sprint计划。 sprint中. 整理一面任务墙，将sprint内的backlog和任务按照未开始、进行中、已完成等状态进行归类（任务单位以小于等于1天为宜），同时展示sprint的燃尽图scrum master每天早上固定时间组织团队的每日例会 （站立会议，控制时间为10-15分钟），确认每个成员前一天完成的工作、当天要进行的工作、工作中碰到的问题、并更新任务墙。任何需求变更都进行实时评估，超过规划人天的backlog视情况进行拆分或者推迟其他重要性低的backlog。任何完成的backlog都需要演示给产品负责人和QA后才能提交测试。 sprint后. scrum master召集、组织sprint回顾会议。回顾会议以头脑风暴的方式review sprint过程和结果，发现和列举存在的问题，与会人员投票决定需要在下个sprint中解决1-3个问题，探讨解决方案，确定实践方式。 scrum精神 团队目标终于岗位职责 团队工作优于独立作战 高效沟通强于标准化的文档 高能动性、自组织的团队胜于角色划分清晰的流水线 务实的解决问题的方法好于经典理论 快速实践、快速反馈、持续优化 我们怎样编写产品Backlog其他人也可以添加backlog条目，但重要性必须由产品负责人决定迭代开发基本需求. 迭代要有固定时长（时间盒），不能超过六个星期。 在每一次迭代的结尾，代码都必须经过OA的测试，能够正常工作。Nokia的Scrum标准 Scrum团队必须要有产品负责任，而且团队都清楚这个人是谁。 产品负责人必须要有产品Backlog，其中包括团队对他进行的估算。 团队必须要有燃尽图，而且要了解他们自己的生产率。 在一个Sprint中，外人不能干预团队的工作。产品backlog 包括需求、故事、特性组成的列表，按重要性排序，包含了客户想要的东西，用客户的术语加以排序如何让产品backlog停留在业务层次上“给Events表添加索引” 应该 被 “提高后台系统中搜索事件的响应速度” 代替添加索引只是一种解决方案，而且还未必能真正解决问题，回归到问题的原始出发点，这个可以用《你的灯亮着吗》来指导 backlog条目 标识符（ID）， 名称（name）， 重要性（Importance），这个故事有多重要 如. 10或150 分数越高越重要 初始估算（Initial estimate）， 工作量估算（把3个人关在一起，大约需要4天时间） 如何做演示（How to demo）， （先这样做，然后那样做，就应该得到…的结果） 注释（Notes）如.格外的故事字段 Track（类别） Components（组件） Requestor（请求者） 我们怎样准备Spring计划 产品Backlog必须存在 只能有高一产品Backlog和一个产品负责人（对于一个产品而言） 所有重要的Backlog条目都已经根据重要性被评分过，不同的重要程度对应不同的分数。注意. 产品负责任之外的人也可以向产品Backlog中添加故事，但是他们不能说这个故事有多重要，这是产品负责任独有的权利，他们不能添加时间估算，这是开发团队独有的权利。Spring计划会议 sprint目标 团队成员名单 sprint backlog 故事列表。 确定好sprint演示日期。 确定好时间地点，供举行每日scrum会议。 产品负责人必须参加？（scope（范围）和重要性（importance）由产品负责人设置 estimate（估算）有团队设置 ） 用本能反应来估算工作时间（如. 兄弟在三天能完成故事A吗？） sprint会议开始前需要定一个大致的时间计划， 每个sprint的目标要有一个概要的描述， 团队成员名单以及每个人的投入程度， 其他 一个sprint包含多少故事由团队决定，而不是产品负责人或其他人，产品负责人只能通过修改故事范围、优先级来让团队选择哪些故事进入sprint， 定义完成. 放入测试环境可以测试 时间估算. 团队所有成员对故事进行估算，包括测试人员、开发人员，集合大家的估算确定最终确定故事力求在1-5人天完成 故事拆分成任务，故事是可以交付的，任务是不可交付的 技术故事. 需要完成但又是不可交付的东西，比如安装持续集成服务器，编写系统设计概览。 技术故事不由产品负责人管理，如果产品负责人可以对技术故事的优先级进行评估为什么都交给他呢？ bug: 如果开发完的功能被测试出bug，bug用jira进行了管理，也有优先级，建议将bug当做是sprint backlog的一部分，按照优先级进行评估是否进入sprint， 怎样让别人了解我们的sprint我们要让整个公司了解我们在做些什么，这件事情至关重要。否则其他人就会发出抱怨，甚或对我们的工作做出臆断。 使用sprint信息页，将sprint列举出来，将sprint信息放到wiki上，邮件通知到家 怎样编写sprint backlog一块白板，记录没开始的故事，今天开始的故事，这个sprint完成的故事。故事用白纸，任务用黄色贴纸，燃尽图. 横坐标是日期（去掉非工作日），竖坐标是工作量，story point，可以用人*时表示， 怎样布置团队房间让团队坐在一起， 怎样进行每日例会团队每个人自觉更新sprint backlog的状态， 怎样进行sprint演示所有sprint都结束于演示快速演示，演示我们实现了什么而不是我们怎么实现的， 怎样做sprint回顾这是改进的最佳时机，你不需要在回顾会议上得到什么好点子，在家中的浴盆里就能做得到！轮流发言，scrum master最后总结哪些做法可以保持，哪些做法可以改进，具体改进的想法， sprints之间的休整片刻，在启动新的 sprint 之前，每个人都应该至少度过一个不需要考虑 sprint 的夜晚。更好的是sprint结束在周五，这样就一个周末，最好结束在周四，周五大家搞一个LAB Day，（lab day也是要准备的。。） 如何制定发布计划处理固定价格的合同 我们怎样组合使用 Scrum和 XPScrum 注重的是管理和组织实践，而XP 关注的是实际的编程实践。CI. 把这一切搭建起来需要大量工作，但付出的每一分钟都物有所值。 怎样做测试把测试人员加入到Scrum团队中，测试人员就是验收先生]]></content>
      <categories>
        <category>旧日往昔</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android FileObserver 类使用指南]]></title>
    <url>%2F2017%2F08%2F30%2FAndroid-FileObserver%20%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[有一种知识就是知道与不知道的区别，我们遇到的很多困难都是这种类型，不知道死活都想不到，知道了也就不过如此最近我们的开发框架在做插件化的功能，用来已插件的形式加载场景和功能（这俩都是开发框架的概念），插件已一个独立apk的形式存在，放在固定的目录下不需要安装，框架启动时就会去加载apk中包裹的插件。有这么个需求，就是该目录下的这些个apk发生变动时 新增 , 删除 , 更新 时，能够load或unload或reload 其中对应的插件，说白了就是监控这个目录的变化。进入正文 inotify本文要讲的是android 的 FileObserver类，而inotify则是该类功能实现所依赖的基础。 Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。使用 inotify 很简单：创建一个文件描述符，附加一个或多个监视器（一个监视器 是一个路径和一组事件），然后使用 read 方法从描述符获取事件。read 并不会用光整个周期，它在事件发生之前是被阻塞的。 以上是百度百科对inotify的描述，FileObserver的原理大致就是如此，关于 inotify 了解到此即可。 FileObserver下面引用android源码中的注释，对于学习而言android的源码及源码的注释简直就是个巨大的宝藏123456789101112131415161718/** * Monitors files (using &lt;a href="http://en.wikipedia.org/wiki/Inotify"&gt;inotify&lt;/a&gt;) * to fire an event after files are accessed or changed by by any process on * the device (including this one). FileObserver is an abstract class; * subclasses must implement the event handler &#123;@link #onEvent(int, String)&#125;. * * &lt;p&gt;Each FileObserver instance monitors a single file or directory. * If a directory is monitored, events will be triggered for all files and * subdirectories inside the monitored directory.&lt;/p&gt; * * &lt;p&gt;An event mask is used to specify which changes or actions to report. * Event type constants are used to describe the possible changes in the * event mask as well as what actually happened in event callbacks.&lt;/p&gt; * * &lt;p class="caution"&gt;&lt;b&gt;Warning&lt;/b&gt;: If a FileObserver is garbage collected, it * will stop sending events. To ensure you keep receiving events, you must * keep a reference to the FileObserver instance from some other live object.&lt;/p&gt; */ FileObserver 可以监听的事件类型如下： 事件 说明 ACCESS 即文件被访问 MODIFY 文件被修改 ATTRIB 文件属性被修改，如 chmod、chown、touch 等 CLOSE_WRITE 可写文件被 close CLOSE_NOWRITE 不可写文件被 close OPEN 文件被 open MOVED_FROM 文件被移走，如 mv MOVED_TO 文件被移来，如 mv、cp CREATE 创建新文件 DELETE 文件被删除，如 rm DELETE_SELF 自删除，即一个可执行文件在执行时删除自己 MOVE_SELF 自移动，即一个可执行文件在执行时移动自己 CLOSE 文件被关闭，等同于(IN_CLOSE_WRITE IN_CLOSE_NOWRITE) ALL_EVENTS 包括上面的所有事件 FileObserver的实现也很简单，创建自己的obsever类继承自FileObserver即可，只需重写唯一的一个abstract方法 onEvent 。示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 class PluginFileObserver extends FileObserver &#123; private static final String TAG = "PluginFileObserver"; public static int PLUGIN_FILE_CHANGED = CREATE | DELETE | MODIFY | MOVED_FROM | MOVED_TO; private static ArrayList&lt;PluginFileObserver&gt; stubs = new ArrayList&lt;&gt;(); private Context mContext; private String mPath; private int mMask; public PluginFileObserver(Context context, String path) &#123; this(context, path, ALL_EVENTS); &#125; public PluginFileObserver(Context context, String path, int mask) &#123; super(path, mask); mContext = context; mPath = path; mMask = mask; stubs.add(this); &#125; @Override public void onEvent(int event, String path) &#123; Logger.i(TAG, "[PLUGIN] PluginFileObserver onEvent with event:" + event + " path:" + path); switch (event) &#123; case FileObserver.CREATE: case FileObserver.MOVED_TO: Logger.i(TAG, "[PLUGIN] PluginFileObserver will add plugin: " + path); break; case FileObserver.DELETE: case FileObserver.MOVED_FROM: Logger.i(TAG, "[PLUGIN] PluginFileObserver will remove plugin: " + path); break; case FileObserver.MODIFY: Logger.i(TAG, "[PLUGIN] PluginFileObserver will update plugin: " + path); break; default: Logger.i(TAG, "[PLUGIN] PluginFileObserver don't care this event"); break; &#125; &#125;&#125; 使用也很简单，创建FileObserver对象，指定要监控的路径，指定监控的事件 ，调用startWatching()启动监控，使用完毕调用stopWatching()停止监控。 12345 PluginFileObserver observer = new PluginFileObserver(mContext, pluginPath, PluginFileObserver.PLUGIN_FILE_CHANGED); //开始监控observer.startWatching();//停止监控observer.stopWatching(); 遇到一坑 必须调用startWatching()方法，否则接收不到事件 必须保证FileObserver对象不被GC回收，否则回收后接收不到事件 指定路径如果是个目录，对目录下的子目录内内容变动，接收不到事件，不过可以递归创建子目录的FileObserver。 有时候处理不当，会造成事件循环产生，先入死循环。 最坑 当你把代码写好了，要进行测试了，连接上adb shell 后，修改下目录下的文件已用来测试，结果收不到事件。对的，在adb shell 下操作对应的文件，收不到事件，若要测试，最好直接操作设备的文件管理器或者写代码创建删除文件测试。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom配置入门]]></title>
    <url>%2F2017%2F08%2F29%2Fatom%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[atom 编辑器就是这样一款利器，得益于其强大而方便的插件化安装，几乎可以满足你的任意写作需求。另外，它提供全平台支持，无论是windows还是ubuntu都有很好的支持，且使用体验完全一致。对于在多种操作系统上工作学习的同学来说，极大的减少了再各平台重复学习的成本。以上都是闲话… 获取atom 可从官方地址下载：Atom 各人有各人的需求，我主要是需要快速完成一些文档兼简要的写些另外的文档以记录一下完成这些文档学习到的新技能，理所当然的钟爱markdown。markdown 是一种可以使用普通的文本编辑器编写的标记语言。通过简单的语法标记，可以使文本具有一定的格式。 基本语法介绍 比如如下的简单格式： 123456789### 这是三级标题&gt;工欲善其事必先利其器——这是引用#### 简单语法- 标题- 列表- 待办事项- 引用- [ ] 这是未完成的待办事项- [x] 这是已完成的待办事项 经过markdown编辑器预览可以是： 再比如如下的内容是一个表格：1234| 序号 | 内容 || -- | -- || 1 | 这是第一行 || 2 | 这是第二行 | 经过markdown编辑器预览可以是： 另外还可以插入高亮的代码：1234567891011\```javapublic class Demo &#123; private String name; private int age; public Demo(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;\ 1234567891011121314151617181920经过markdown编辑器预览可以可以是：![markdown code](http://ovfro7ddi.bkt.clouddn.com/markdown%20code.png)### 实用插件配置#### __markdown 预览__![intro](https://user-images.githubusercontent.com/1908863/28227953-eb6eefa4-68a1-11e7-8769-96ea83facf3b.png)atom 默认已经安装了markdown的预览插件：markwon-preview 但是默认的往往功能不够强大，强烈建议卸载之（可以实用快捷键 __ctrl+shift+p__ 这个万能键，然后在弹出的框内输入uninstall package 就会列出提示，然后进入对应的界面卸载就可以了）建议安装插件：__markdown preview Enhanced__， 安装后使用快捷键 __ctrl+shift+m__ 进行预览，该预览插件支持 __mermaid__ 图形预览 和 __MathJax__ 数学公式预览markdown preview Enhanced 还有很多非常强大的功能： - 更多介绍可参考 [markdown preview enhanced 简介](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/) - 项目[gitup](https://github.com/shd101wyy/markdown-preview-enhanced)#### __atom-mermaid__ 图形预览如下是mermaid的官方说明：&gt;Generation of diagrams and flowcharts from text in a similar manner as markdown.在atom 中使用 则需要安装包 __atom-mermaid__下图是从官网的介绍中获取的一张图：![intro](http://y-takey.github.io/atom-mermaid-example.gif)正如官方的描述，mermaid的作用就是使用简单的文本语法，使用文本来绘制图。更多mermaid的用法可以参考 [mermaid 官方介绍](https://mermaidjs.github.io/)。__但是划重点了啊__ 在markdown中使用，需要将其当做代码块输入，示例如下： 12graph LRA --&gt;B 123456789而且必须指明语言类型为&quot;mermaid&quot;本文只解决了解的问题，此处不再做更详细的介绍，更多使用的详细语法，还请移步[官方介绍](https://mermaidjs.github.io/)#### __MathJax__ 数学公式如要在atom markdwon 预览使用 mathjax， 需要在 markdown-preview-enhanced 的设置项__【Math Rendering option】__选项中指明使用 mathjax 渲染。除此之外倒是没有发现需要独立安装其他package。- MathJax 项目的[github](https://github.com/mathjax/MathJax)- MathJax 具体的[使用文档](http://docs.mathjax.org/en/latest/start.html)在markdown 中使用math jax 有两种用法：一种是行内公式，公式内容写在两个$中间，例如： $(x^{(i)}, y^{(i)})$:ith training example, 代表训练集中的第i个数据123这种写法的展现效果如下：&gt;$(x^&#123;(i)&#125;, y^&#123;(i)&#125;)$:ith training example, 代表训练集中的第i个数据另外一种是独立行公式，公式前后以$$为标记，例如： $$h_\theta(X)=\theta_0+\theta_1X$$```这种写法的展现效果如下： $$h_\theta(X)=\theta_0+\theta_1X$$ 结语如上所述，介绍了atom 编辑markdown的一些插件和方法，至于一些更常用的操作，比如，如何导出pdf等，可以百度一下了。在atom 中使用markdown，可以有格式，有列表，有代码，有引用，有表格，有图标，有公式，基本可以满足所有的写作需求了。这还只是这些功能的皮毛而已，可见markdown真的是无敌的强大。]]></content>
      <categories>
        <category>Blog 写作 教程</category>
        <category>Atom 教程</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javah 命令详解]]></title>
    <url>%2F2017%2F08%2F19%2FJavah-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在JNI/NDK开发的过程中我们会遇到一个很关键的命令 javah 在ubuntu 上使用 man 命令查阅使用手册，可知 javah 命令的作用如下： javah - C Header and Stub File Generator. javah produces C header files and C source files from a Java class. These files provide the connective glue that allow your Java and C code tointeract.简单讲就是为java类中的navtive方法生成 c 语言的头文件。先看下ubuntu上的帮助如下：123456789101112131415$ javah --helpUsage: javah [options] &lt;classes&gt;where [options] include: -o &lt;file&gt; Output file (only one of -d or -o may be used) -d &lt;dir&gt; Output directory -v -verbose Enable verbose output -h --help -? Print this message -version Print version information -jni Generate JNI-style header file (default) -force Always write output files -classpath &lt;path&gt; Path from which to load classes -bootclasspath &lt;path&gt; Path from which to load bootstrap classes&lt;classes&gt; are specified with their fully qualified names(for example, java.lang.Object). 其中重要的几个参数 o d classpath 重点关注下。 遇到一坑在百度搜索 Android studio jni 开发，好多的文章都是这么写的： 再打开Terminal输入指令cd app/build/intermediates/classes/debug然后再输入指令javah -jni com.wobiancao.ndkjnidemo.ndk.JniUtils注意 这里javah -jni后面跟的是JniUtils类的全路径，如果javah报不存在之类的，是你的java环境没有配置好。摘自Android Studio ndk-Jni开发详细 注：本文不解决如何开始jni开发的问题，这个问题可参考Android Studio ndk-Jni开发详细 一般情况下这样写没啥问题，然后我的类是这个样子的时候，报错了：12345678910111213package com.test.mylibrary;import org.json.JSONObject;public class Test &#123; public static String doTest(JSONObject jsObj) &#123; test(); return ""; &#125; public static native void test();&#125; 错误如下：123456$ javah -jni com.test.mylibrary.TestError: Class org.json.JSONObject could not be found.$ javah -classpath ~/tools/adt-bundle/sdk/platforms/android-26/android.jar com.test.mylibrary.TestError: Could not find class file for &apos;com.test.mylibrary.Test&apos;.$ javah -classpath ./:~/tools/adt-bundle/sdk/platforms/android-26/android.jar com.test.mylibrary.TestError: Class org.json.JSONObject could not be found. 其实也没啥特别的就是import 了个JSONObject ，import 其他的类也没有问题，然后根据网上的各种经验指定classpath的路径，还是继续Error 。 解决其实也很简单，就是不要在build目录下执行即可，在src/main/java 目录下呢直接执行就可以了，不在src/main/java 目录下则指定classpath路径也可以，如下：12345$ javah -jni com.test.mylibrary.Test$ cd ../$ javah -classpath java -jni com.test.mylibrary.Test$ cd ../$ javah -classpath main/java -jni com.test.mylibrary.Test 其中 -jni 生成jni格式的头文件是默认的，所以不写也是可以的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 编码规范]]></title>
    <url>%2F2017%2F08%2F12%2Fjava-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1 介绍本规范参考java 官方编码规范，简化而来，更详细的介绍请参考Code Conventions for the Java TM Programming Language本规范适用但不限于OS Lite项目使用。 2 文件名这项目组列出了常用的文件名及其后缀。 2.1 文件后缀Java程序应用下列文件后缀： 文件类别 文件后缀 Java源文件 .java Java字节码文件 .class 2.2 常用文件常用的文件名包含： 文件名 用处 README.md 大的独立模块下用来说明该模块打使用注意事项等 3 文件组织一个文件由被空行分隔而成的段落以及标识每个段落的注释共同构成。超过2000行的程序难以浏览，应当尽量避免。 3.1 Java源文件若private类或interface与一个public类关系紧密，可以将它们放入同一个源文件，但是public类必须是这个文件中的第一个类或接口。 Java源文件应遵守以下规范： 开首注释 包和引入语句 类和接口声明 3.1.1 文件头注释为了方便生成api ref，所有的源文件都应当有文件头注释例如：1234567/*** Version information** Date** Copyright notice*/ 3.1.2 包和引入语句在多半Java源文件中，第一个非注释行是包语句。在它之后可以跟引入语句123package com.turing123.robotframe;import android.content.Context; 3.1.3 类和接口声明下表描述了类和接口声明 序号 类/接口声明的各项目 注解 1 类/接口文档注释（/*……/） 该注释中所需包含的信息，拜见”文档注释” 2 类或接口的声明 3 类的（静态）变量 开头是类的公共常量，最后是私有常量。 4 实例变量 同上 5 构造方法 6 成员方法 这些方法应当按功能分组。例如，一个私有的类方法可以置于两个公有的实例方法之间。其目标是为了更便于浏览代码。 4 缩进排版4个空格作为缩进排版的一个单位。 4.1 行长度尽量避免一行的长度跨越100个字符。 4.2 换行当一个表达式无法容纳在一行内时，可以根据如下规则断开之： 在一个逗号后面断开 在一个操纵符前面断开 新的一行应当与上一行同一级别表达式的开首处对齐 12public void prepare(@NonNull MessageInterceptor interceptor, @NonNull final RobotFramePreparedListener listener) if语句的换行,例如：123456if (behaviors == null || behaviors.behaviors == null || behaviors.behaviors.size() == 0) &#123; //do something&#125; 三元运算表达式打换行，例如：12345alpha = （aLongBooleanExpression） ？ beta : gamma;alpha = （aLongBooleanExpression）？ beta : gamma; 5 注释5.1 注释的格式程序可以有4种实现注释的风格：块（block）、单行（single-line）、尾端（trailing）和行末（end-of-line）。 5.1.1 块注释块注释每个文件的开端处以及每个方法之前。它们也可以被用于方法内部。在功能和方法内部的块注释应当和它们所描述的代码具有一样的缩进格局。 块注释可以以/**开头123456/** * Set NLP Sever's ApiKey and Secret. * * @param apiKey Your ApiKey. * @param secret Your Secret. */ 5.1.2 单行注释短注释可以显示在一行内,单行注释之前应当有一个空行。12345if （condition） &#123; /* Handle thecondition. */ ...&#125; 5.1.4 行末注释1234567891011121314151617if （foo &gt; 1） &#123; // Do adouble-flip. ...&#125;else &#123; return false; // Explain why here.&#125;//if （bar &gt; 1）&#123;//// // Do a triple-flip.// ...//&#125;//else &#123;// return false;//&#125; 5.2 文档注释文档注释描述Java的类、接口、方法以及字段（field）。每个文档注释都邑被置于注释定界符/*…/之中，一个注释对应一个类、接口或成员。该注释应位于声明之前，该注释将被用来生成javadoc api ref.12345678910/** * Provide ASR function */public final class ASR extends FunctionBase&#123; /** * Chat Mode: CHAT_MODE_AUTO * Robot framework's chat will auto running, you needn't care about asr and ask the cloud. */ public static final int CHAT_MODE_AUTO = 0;&#125; 6 声明6.1 每行声明变量的数量推荐一行一个声明，因为这样利于写注释12int level; // indentation levelint size; // size of table 6.2 初始化尽量在声明局部变量的同时初始化 6.3 布局只在代码块的开端处声明变量,不要在初次用到该变量时才声明它。12345678void myMethod（） &#123; int int1 = 0; // beginning of method block if （condition） &#123; int int2 = 0; // beginning of "if"block ... &#125;&#125; 6.4 类和接口的声明当编写类和接口是，应当遵守以下格局规范： 在方法名与其参数列表之前的左括号”（”间不要有空格 左大括号”{“位于声明语句同业的末尾 右大括号”}”另起一行，与响应的声明语句对齐，除非是一个空语句，”}”应紧跟在”{“之后1234567891011121314151617181920212223242526public class Behavior &#123; public String exception; public IntentInfo intent; public Recommend recommend; public List&lt;ResponseResult&gt; results; public List&lt;Sequence&gt; sequences; public Emotion emotion; public Behavior() &#123; &#125; public Behavior(String exception) &#123; this.exception = exception; &#125; public Behavior(String exception, IntentInfo intent, Recommend recommend, List&lt;ResponseResult&gt; results, List&lt;Sequence&gt; sequences, Emotion emotion) &#123; this.exception = exception; this.intent = intent; this.recommend = recommend; this.results = results; this.sequences = sequences; this.emotion = emotion; &#125;&#125; 7 语句7.1 简单语句123argv++; // Correctargc--; // Correctargv++; argc--; // AVOID! 7.2 复合语句 被括此中的语句应当较之复合语句缩进一个层次 左大括号”{“应位于复合语句开端行的行尾；右大括号”}”应另起一行并与复合语句首行对齐。 7.3 返回语句一个带返回值的return语句不应用小括号”（）” 7.4 if，if-else，if else-if else语句（if， if-else， if else-if elseStatements）if-else语句应当具有如下格示：1234567891011121314151617if （condition） &#123; statements;&#125;if （condition） &#123; statements;&#125; else &#123; statements;&#125;if （condition） &#123; statements;&#125; else if （condition） &#123; statements;&#125; else &#123; statements;&#125; 7.5 for语句一个for语句应当具有如下格示：123for （initialization; condition; ） &#123; statements;&#125; 一个空的for语句应当具有如下格示：1for （initialization; condition; ）; 7.6 while语句一个while语句应当具有如下格示：123while （condition） &#123; statements;&#125; 一个空的while语句应当具有如下格示：1while （condition）; 7.7 do-while语句一个do-while语句应当具有如下格示：123do &#123; statements;&#125; while （condition）; 7.8 switch语句一个switch语句应当具有如下格示：12345678910111213141516switch （condition） &#123;case ABC: statements; /* falls through */case DEF: statements; break;case XYZ: statements; break;default: statements; break;&#125; 7.9 try-catch语句一个try-catch语句应当具有如下格示：12345try &#123; statements;&#125; catch （ExceptionClass e） &#123; statements;&#125; 或1234567try &#123; statements;&#125; catch （ExceptionClass e） &#123; statements;&#125; finally &#123; statements;&#125; 8 空白8.1 空行空行将逻辑相干的代码段分隔开。 下列景象应当是应用两个空行： 一个源文件的两个片段（section）之间 类声明和接口声明之间 下列景象应当是应用一个空行： 两个方法之间 方法内的局部变量和方法的第一条语句之间 8.2 空格下列情况当应用空格： 一个紧跟着括号的关键字应当被空格分隔，例如：123while （true） &#123; ...&#125; 注意：空格不该该置于法名与其左括号之间。这将有助于区分关键字和方法调用。 空白应当位于参数列表中逗号的后面 所有的二元运算符，除了”.”，应当应用空格将之与操纵数分隔。一元操纵符和操纵数之间不因该加空格，比如：负号（”-“）、自增（”++”）和自减（”–”）。例如： 9 命名规范 标识符类型 命名规范 例子 包 一个独一包名的前缀老是全部小写的ASCII字母并且是一个域名，这类命名规范可能以特定目次名的构成来区分部 门（department），项目（project）。 com.turing123.robotframe 类 命名规范：类名是个一名词，采取大小写混淆的体式格式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。应用完全单词，避免缩写词 class Behavior 接口 命名规范：大小写规范与类名类似 interface IASRCallback 方法 方法名是一个动词，采取大小写混淆的体式格式，第一个单词的首字母小写，其后单词的首字母大写。 void onStartRecord() 变量 除了变量名外，所有实例，包含类，类常量，均采取大小写混淆的体式格式，第一个单词的首字母小写，其后单词的首字母大写。变量名不该以下划线或美元符号开首，尽管这在语法上是容许的。变量名应简短且富于描述。变量名的选用应当易于记忆，即，可以或许指出其用处。尽量避免单个字符的变量名，除非是一次性的姑且变量。姑且变量凡是被取名为i，j，k，m和n，它们一般用于整型；c，d，e，它们一般用于字符型。 char c; 实例变量 大小写规范和变量名类似 常量 类常量应当全部大写，单词间用下划线隔开 public static final int CHAT_MODE_AUTO = 0 10 Java源文件示例下面的例子，显示了一公共类的Java源程序（仅作为示例）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.turing123.robotframe;import android.content.Context;/** * &lt;p&gt; * The entry to use RobotFrame.&lt;br/&gt;&lt;br/&gt; * Usage:&lt;br/&gt; * The method &lt;font color="blue"&gt;prepare&lt;/font&gt; must be called prior to any method calling on this frame. * The normal steps to use this frame are as blow:&lt;br/&gt; * 1. call &lt;font color="blue"&gt;getInstance()&lt;/font&gt;&lt;br/&gt; * 2. call &lt;font color="blue"&gt;prepare(prepareListener)&lt;/font&gt;&lt;br/&gt; * 3. waiting for prepareListener callback&lt;br/&gt; * 4.1 if success, call &lt;font color="blue"&gt;start()&lt;/font&gt; to launch the robot up&lt;br/&gt; * 4.2 if error occurred, check and fix the issue according to error message&lt;br/&gt; * 5. if robot is attempting to shutdown, call method &lt;font color="blue"&gt;shutDown(shutdownListener)&lt;/font&gt; * first and wait until the shutdownListener called back.&lt;br/&gt; * &lt;p&gt; * &lt;strong&gt;&lt;font color="red"&gt;WARNING: Any violation from the steps above will cause unpredictable * behaviors.&lt;/font&gt;&lt;/strong&gt; */public class RobotFrameManager &#123; /** * Chat Mode: CHAT_MODE_AUTO * Robot framework's chat will auto running, you needn't care about asr and ask the cloud. */ public static final int CHAT_MODE_AUTO = 0; /** * Chat Mode: CHAT_MODE_MANUAL * Robot framework‘s Chat requires manual call ASR and ask the cloud. * In this mode, the output mode only is &#123;@link #OUTPUT_MODE_ASSEMBLE&#125; */ public static final int CHAT_MODE_MANUAL = 1; private static RobotFrameManager mInstance = null; private FrameService mService; private Context mContext; public RobotFrameManager(Context context) &#123; mContext = context; SystemProperties.getInstance().init(context); mService = new FrameService(context); PluginService.setUp(mContext); &#125; /** * Be RobotFrame prepared, must be called prior to any calling to other method * * @param states the Frame working mode and states(if has) * @param listener the callback listener */ public void prepare(int states, @NonNull final RobotFramePreparedListener listener) &#123; mService.prepare(states,listener); &#125; /** * The robot starting run */ public void start() throws IllegalStateException &#123; mService.start(); &#125; /** * Set NLP Sever's ApiKey and Secret. * * @param apiKey Your ApiKey. * @param secret Your Secret. */ public void setApiKeyAndSecret(String apiKey, String secret) &#123; Preconditions.checkNotNull(apiKey, true); Preconditions.checkNotNull(secret, true); Settings.init(mContext); Settings.put(SettingsKey.TURING_APIKEY, apiKey); Settings.put(SettingsKey.TURING_SECRET, secret); Settings.deInit(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习笔记（二）]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习资源 6、2 - 1 - Model Representation 【中文】 学习内容监督学习的特点：针对每一个问题都给出了正确的答案 监督学习的过程可描述为：通过把Training Set 喂给 Learning algorithm 得出一个 hypothesis，然后传入要预测的特征值给得到的 hypothesis，从而得到预测的结果。 线性回归模型 是典型的且最简单的监督学习模型。 符号表示监督学习中关于Traning Set 定义了一些符号： m: number of Training set x’s: “input” variable/features y’2: “output” variable/“target” variable (x, y): one training example, 代表一个训练集中的数据 $(x^{(i)}, y^{(i)})$:ith training example, 代表训练集中的第i个数据 单变量的线性回归可用如下表达式表示：$$h_\theta(X)=\theta_0+\theta_1X$$]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习学习笔记（一）]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景介绍AI 已是大势所趋，况且又处在这个行业，又在一家人工智能的公司工作做聊天机器人的技术工作。然而，所做的工作又与机器学习基本毫不相干，这么高大上又前景颇好的东西近在眼前确触碰不到，多么可惜啊… 学习资源不知如何入门，在B站偶然发现Andrew Ng 的机器学习教程，争取可以坚持学完。第一天入门，主要学习以下内容: 1、1 - 1 - Welcome to Machine Learning【中英】 2、1 - 2 - Welcome【中英】 3、1 - 3 - What is Machine Learning【中英】 4、1 - 4 - Supervised Learning 【中英】 5、1 - 5 - Unsupervised Learning 【中文】 学习内容这几节主要其实主要是讲了机器学习的概念机器学习可以按照如下分类： 监督学习 无监督学习 监督学习主要分为两大问题：分类问题 和 回归问题。 分类问题预期的是有限个数的离散输出结果，典型的例子：根据已有的肿瘤大小与肿瘤恶性还是良性的数据，预测肿瘤是良性还是恶性的。 回归问题预期的是连续的输出结果，典型的例子：根据已有的房价与房屋面积的数据，已知房屋面积预测房屋价格。 无监督学习典型的算法有聚类算法： eg1: social network analysis 根据好友的互动数据，自动分组人群 eg2: market segmentation 根据客户数据，自动分类细分市场 使用工具的最佳建议学习机器学习，如果使用c++或java语言开发，代码会非常多，且需要链接到各种库去处理特殊功能。机器学习的研究者通常的做法是，先使用octave或Matlab语言实现好原型，在用其他的语言进一步开发。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Quick Start]]></title>
    <url>%2F2017%2F07%2F29%2FHexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" Create a new draft1$ hexo new draft "My new draft" Publish draft1$ hexo publish [layout] &lt;filename&gt; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog 写作 教程</category>
        <category>Hexo 教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
